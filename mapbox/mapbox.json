[
  {
    "name": "Map",
    "desc": "The Map object represents the map on your page. It exposes methods and properties that enable you to programmatically change the map, and fires events as users interact with it. You create a Map by specifying a container and other options. Then Mapbox GL JS initializes the map on the page and returns your Map object.",
    "methods": {
      "scrollZoom": {
        "desc": "The map's ScrollZoomHandler, which implements zooming in and out with a scroll wheel or trackpad.\nFind more details and examples using scrollZoom in the ScrollZoomHandler section."
      },
      "boxZoom": {
        "desc": "The map's BoxZoomHandler, which implements zooming using a drag gesture with the Shift key pressed.\nFind more details and examples using boxZoom in the BoxZoomHandler section."
      },
      "dragRotate": {
        "desc": "The map's DragRotateHandler, which implements rotating the map while dragging with the right\nmouse button or with the Control key pressed. Find more details and examples using dragRotate\nin the DragRotateHandler section."
      },
      "dragPan": {
        "desc": "The map's DragPanHandler, which implements dragging the map with a mouse or touch gesture.\nFind more details and examples using dragPan in the DragPanHandler section."
      },
      "keyboard": {
        "desc": "The map's KeyboardHandler, which allows the user to zoom, rotate, and pan the map using keyboard\nshortcuts. Find more details and examples using keyboard in the KeyboardHandler section."
      },
      "doubleClickZoom": {
        "desc": "The map's DoubleClickZoomHandler, which allows the user to zoom by double clicking.\nFind more details and examples using doubleClickZoom in the DoubleClickZoomHandler section."
      },
      "touchZoomRotate": {
        "desc": "The map's TouchZoomRotateHandler, which allows the user to zoom or rotate the map with touch gestures.\nFind more details and examples using touchZoomRotate in the TouchZoomRotateHandler section."
      },
      "addControl": {
        "desc": "Adds an IControl to the map, calling control.onAdd(this).",
        "params": {
          "control": {
            "type": [
              "IControl"
            ],
            "desc": "The IControl to add."
          },
          "position": {
            "type": [
              "string?"
            ],
            "desc": "position on the map to which the control will be added. Valid values are 'top-left' , 'top-right' , 'bottom-left' , and 'bottom-right' . Defaults to 'top-right' ."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "removeControl": {
        "desc": "Removes the control from the map.",
        "params": {
          "control": {
            "type": [
              "IControl"
            ],
            "desc": "The IControl to remove."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "resize": {
        "desc": "Resizes the map according to the dimensions of its\ncontainer element.\nChecks if the map container size changed and updates the map if it has changed.\nThis method must be called after the map's container is resized programmatically\nor when the map is shown after being initially hidden with CSS.",
        "params": {
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be passed to movestart , move , resize , and moveend events that get triggered as a result of resize. This can be useful for differentiating the source of an event (for example, user-initiated or programmatically-triggered events)."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getBounds": {
        "desc": "Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not\nan axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.",
        "returns": {
          "type": "LngLatBounds",
          "desc": ": The geographical bounds of the map as LngLatBounds ."
        }
      },
      "getMaxBounds": {
        "desc": "Returns the maximum geographical bounds the map is constrained to, or null if none set.",
        "returns": {
          "type": "(LngLatBounds | null)",
          "desc": ": The map object."
        }
      },
      "setMaxBounds": {
        "desc": "Sets or clears the map's geographical bounds.\nPan and zoom operations are constrained within these bounds.\nIf a pan or zoom is performed that would\ndisplay regions outside these bounds, the map will\ninstead display a position and zoom level\nas close as possible to the operation's request while still\nremaining within the bounds.",
        "params": {
          "bounds": {
            "type": [
              "LngLatBoundsLike",
              "null",
              "undefined"
            ],
            "desc": "The maximum bounds to set. If null or undefined is provided, the function removes the map's maximum bounds."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "setMinZoom": {
        "desc": "Sets or clears the map's minimum zoom level.\nIf the map's current zoom level is lower than the new minimum,\nthe map will zoom to the new minimum.\nIt is not always possible to zoom out and reach the set minZoom.\nOther factors such as map height may restrict zooming. For example,\nif the map is 512px tall it will not be possible to zoom below zoom 0\nno matter what the minZoom is set to.",
        "params": {
          "minZoom": {
            "type": [
              "number",
              "null",
              "undefined"
            ],
            "desc": "The minimum zoom level to set (-2 - 24). If null or undefined is provided, the function removes the current minimum zoom (i.e. sets it to -2)."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getMinZoom": {
        "desc": "Returns the map's minimum allowable zoom level.",
        "returns": {
          "type": "number",
          "desc": ": minZoom"
        }
      },
      "setMaxZoom": {
        "desc": "Sets or clears the map's maximum zoom level.\nIf the map's current zoom level is higher than the new maximum,\nthe map will zoom to the new maximum.",
        "params": {
          "maxZoom": {
            "type": [
              "number",
              "null",
              "undefined"
            ],
            "desc": "The maximum zoom level to set. If null or undefined is provided, the function removes the current maximum zoom (sets it to 22)."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getMaxZoom": {
        "desc": "Returns the map's maximum allowable zoom level.",
        "returns": {
          "type": "number",
          "desc": ": maxZoom"
        }
      },
      "setMinPitch": {
        "desc": "Sets or clears the map's minimum pitch.\nIf the map's current pitch is lower than the new minimum,\nthe map will pitch to the new minimum.",
        "params": {
          "minPitch": {
            "type": [
              "number",
              "null",
              "undefined"
            ],
            "desc": "The minimum pitch to set (0-60). If null or undefined is provided, the function removes the current minimum pitch (i.e. sets it to 0)."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getMinPitch": {
        "desc": "Returns the map's minimum allowable pitch.",
        "returns": {
          "type": "number",
          "desc": ": minPitch"
        }
      },
      "setMaxPitch": {
        "desc": "Sets or clears the map's maximum pitch.\nIf the map's current pitch is higher than the new maximum,\nthe map will pitch to the new maximum.",
        "params": {
          "maxPitch": {
            "type": [
              "number",
              "null",
              "undefined"
            ],
            "desc": "The maximum pitch to set. If null or undefined is provided, the function removes the current maximum pitch (sets it to 60)."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getMaxPitch": {
        "desc": "Returns the map's maximum allowable pitch.",
        "returns": {
          "type": "number",
          "desc": ": maxPitch"
        }
      },
      "getRenderWorldCopies": {
        "desc": "Returns the state of renderWorldCopies. If true, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to false:\n\nWhen the map is zoomed out far enough that a single representation of the world does not fill the map's entire\ncontainer, there will be blank space beyond 180 and -180 degrees longitude.\nFeatures that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the\nmap and the other on the left edge of the map) at every zoom level.",
        "returns": {
          "type": "boolean",
          "desc": ": renderWorldCopies"
        }
      },
      "setRenderWorldCopies": {
        "desc": "Sets the state of renderWorldCopies.",
        "params": {
          "renderWorldCopies": {
            "type": [
              "boolean"
            ],
            "desc": "If true , multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to false : When the map is zoomed out far enough that a single representation of the world does not fill the map's entire container, there will be blank space beyond 180 and -180 degrees longitude. Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the map and the other on the left edge of the map) at every zoom level. undefined is treated as true, null is treated as false."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "project": {
        "desc": "Returns a Point representing pixel coordinates, relative to the map's container,\nthat correspond to the specified geographical location.",
        "params": {
          "lnglat": {
            "type": [
              "LngLatLike"
            ],
            "desc": "The geographical location to project."
          }
        },
        "returns": {
          "type": "Point",
          "desc": ": The Point corresponding to lnglat , relative to the map's container ."
        }
      },
      "unproject": {
        "desc": "Returns a LngLat representing geographical coordinates that correspond\nto the specified pixel coordinates.",
        "params": {
          "point": {
            "type": [
              "PointLike"
            ],
            "desc": "The pixel coordinates to unproject."
          }
        },
        "returns": {
          "type": "LngLat",
          "desc": ": The LngLat corresponding to point ."
        }
      },
      "isMoving": {
        "desc": "Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.",
        "returns": {
          "type": "boolean",
          "desc": ": True if the map is moving."
        }
      },
      "isZooming": {
        "desc": "Returns true if the map is zooming due to a camera animation or user gesture.",
        "returns": {
          "type": "boolean",
          "desc": ": True if the map is zooming."
        }
      },
      "isRotating": {
        "desc": "Returns true if the map is rotating due to a camera animation or user gesture.",
        "returns": {
          "type": "boolean",
          "desc": ": True if the map is rotating."
        }
      },
      "on": {
        "desc": "Adds a listener for events of a specified type occurring on features in a specified style layer.",
        "params": {
          "type": {
            "type": [
              "string"
            ],
            "desc": "The event type to listen for; one of 'mousedown' , 'mouseup' , 'click' , 'dblclick' , 'mousemove' , 'mouseenter' , 'mouseleave' , 'mouseover' , 'mouseout' , 'contextmenu' , 'touchstart' , 'touchend' , or 'touchcancel' . mouseenter and mouseover events are triggered when the cursor enters a visible portion of the specified layer from outside that layer or outside the map canvas. mouseleave and mouseout events are triggered when the cursor leaves a visible portion of the specified layer, or leaves the map canvas."
          },
          "layerId": {
            "type": [
              "string"
            ],
            "desc": "The ID of a style layer. Only events whose location is within a visible feature in this layer will trigger the listener. The event will have a features property containing an array of the matching features."
          },
          "listener": {
            "type": [
              "Function"
            ],
            "desc": "The function to be called when the event is fired."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "once": {
        "desc": "Adds a listener that will be called only once to a specified event type.",
        "params": {
          "type": {
            "type": [
              "string"
            ],
            "desc": "The event type to add a listener for."
          },
          "listener": {
            "type": [
              "Function"
            ],
            "desc": "The function to be called when the event is fired. The listener function is called with the data object passed to fire , extended with target and type properties."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "off": {
        "desc": "Removes an event listener previously added with Map#on.",
        "params": {
          "type": {
            "type": [
              "string"
            ],
            "desc": "The event type previously used to install the listener."
          },
          "listener": {
            "type": [
              "Function"
            ],
            "desc": "The function previously installed as a listener."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "queryRenderedFeatures": {
        "desc": "Returns an array of GeoJSON\nFeature objects\nrepresenting visible features that satisfy the query parameters.",
        "params": {
          "geometry": {
            "type": [
              "PointLike",
              "Array<PointLike>?"
            ],
            "desc": "The geometry of the query region: either a single point or southwest and northeast points describing a bounding box. Omitting this parameter (i.e. calling Map#queryRenderedFeatures with zero arguments, or with only a options argument) is equivalent to passing a bounding box encompassing the entire map viewport."
          },
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "Options object."
          }
        },
        "returns": {
          "type": "Array<Object>",
          "desc": ": An array of GeoJSON feature objects . The properties value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only string and numeric property values are supported (i.e. null, Array, and Object values are not supported). Each feature includes top-level layer, source, and sourceLayer properties. The layer property is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature. Only features that are currently rendered are included. Some features will not be included, like: Features from layers whose visibility property is \"none\". Features from layers whose zoom range excludes the current zoom level. Symbol features that have been hidden due to text or icon collision. Features from all other layers are included, including features that may have no visible contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to 0. The topmost rendered feature appears first in the returned array, and subsequent features are sorted by descending z-order. Features that are rendered multiple times (due to wrapping across the antimeridian at low zoom levels) are returned only once (though subject to the following caveat). Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple times in query results. For example, suppose there is a highway running through the bounding rectangle of a query. The results of the query will be those parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering."
        }
      },
      "querySourceFeatures": {
        "desc": "Returns an array of GeoJSON\nFeature objects\nrepresenting features within the specified vector tile or GeoJSON source that satisfy the query parameters.",
        "params": {
          "sourceId": {
            "type": [
              "string"
            ],
            "desc": "The ID of the vector tile or GeoJSON source to query."
          },
          "parameters": {
            "type": [
              "Object?"
            ],
            "desc": "Options object."
          }
        },
        "returns": {
          "type": "Array<Object>",
          "desc": ": An array of GeoJSON Feature objects . In contrast to Map#queryRenderedFeatures, this function returns all features matching the query parameters, whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently visible viewport. Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple times in query results. For example, suppose there is a highway running through the bounding rectangle of a query. The results of the query will be those parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering."
        }
      },
      "setStyle": {
        "desc": "Updates the map's Mapbox style object with a new value.\nIf a style is already set when this is used and options.diff is set to true, the map renderer will attempt to compare the given style\nagainst the map's current state and perform only the changes necessary to make the map style match the desired state. Changes in sprites\n(images used for icons and patterns) and glyphs (fonts for label text) cannot be diffed. If the sprites or fonts used in the current\nstyle and the given style are different in any way, the map renderer will force a full update, removing the current style and building\nthe given one from scratch.",
        "params": {
          "style": {
            "type": [
              "StyleSpecification",
              "string",
              "null"
            ],
            "desc": "A JSON object conforming to the schema described in the Mapbox Style Specification , or a URL to such JSON."
          },
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "Options object."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getStyle": {
        "desc": "Returns the map's Mapbox style object, which can be used to recreate the map's style.",
        "returns": {
          "type": "Object",
          "desc": ": The map's style object."
        }
      },
      "isStyleLoaded": {
        "desc": "Returns a Boolean indicating whether the map's style is fully loaded.",
        "returns": {
          "type": "boolean",
          "desc": ": A Boolean indicating whether the style is fully loaded."
        }
      },
      "addSource": {
        "desc": "Adds a source to the map's style.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the source to add. Must not conflict with existing sources."
          },
          "source": {
            "type": [
              "Object"
            ],
            "desc": "The source object, conforming to the Mapbox Style Specification's source definition or CanvasSourceOptions ."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "isSourceLoaded": {
        "desc": "Returns a Boolean indicating whether the source is loaded.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the source to be checked."
          }
        },
        "returns": {
          "type": "boolean",
          "desc": ": A Boolean indicating whether the source is loaded."
        }
      },
      "areTilesLoaded": {
        "desc": "Returns a Boolean indicating whether all tiles in the viewport from all sources on\nthe style are loaded.",
        "returns": {
          "type": "boolean",
          "desc": ": A Boolean indicating whether all tiles are loaded."
        }
      },
      "removeSource": {
        "desc": "Removes a source from the map's style.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the source to remove."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getSource": {
        "desc": "Returns the source with the specified ID in the map's style.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the source to get."
          }
        },
        "returns": {
          "type": "Object?",
          "desc": ": The style source with the specified ID, or undefined if the ID corresponds to no existing sources."
        }
      },
      "addImage": {
        "desc": "Add an image to the style. This image can be displayed on the map like any other icon in the style's\nsprite using the image's ID with\nicon-image,\nbackground-pattern,\nfill-pattern,\nor line-pattern.\nA Map#error event will be fired if there is not enough space in the sprite to add this image.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the image."
          },
          "image": {
            "type": [
              "HTMLImageElement",
              "ImageBitmap",
              "ImageData",
              "{width: number, height: number, data: Uint8Array",
              "Uint8ClampedArray}",
              "StyleImageInterface"
            ],
            "desc": "The image as an HTMLImageElement , ImageData , ImageBitmap or object with width , height , and data properties with the same format as ImageData ."
          },
          "options": {
            "type": [
              "$Shape<StyleImageMetadata>"
            ],
            "desc": "(default {})"
          }
        }
      },
      "updateImage": {
        "desc": "Update an existing image in a style. This image can be displayed on the map like any other icon in the style's\nsprite using the image's ID with\nicon-image,\nbackground-pattern,\nfill-pattern,\nor line-pattern.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the image."
          },
          "image": {
            "type": [
              "HTMLImageElement",
              "ImageBitmap",
              "ImageData",
              "{width: number, height: number, data: Uint8Array",
              "Uint8ClampedArray}",
              "StyleImageInterface"
            ],
            "desc": "The image as an HTMLImageElement , ImageData , ImageBitmap or object with width , height , and data properties with the same format as ImageData ."
          }
        }
      },
      "hasImage": {
        "desc": "Check whether or not an image with a specific ID exists in the style. This checks both images\nin the style's original sprite and any images\nthat have been added at runtime using Map#addImage.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the image."
          }
        },
        "returns": {
          "type": "boolean",
          "desc": ": A Boolean indicating whether the image exists."
        }
      },
      "removeImage": {
        "desc": "Remove an image from a style. This can be an image from the style's original\nsprite or any images\nthat have been added at runtime using Map#addImage.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the image."
          }
        }
      },
      "loadImage": {
        "desc": "Load an image from an external URL to be used with Map#addImage. External\ndomains must support CORS.",
        "params": {
          "url": {
            "type": [
              "string"
            ],
            "desc": "The URL of the image file. Image file must be in png, webp, or jpg format."
          },
          "callback": {
            "type": [
              "Function"
            ],
            "desc": "Expecting callback(error, data) . Called when the image has loaded or with an error argument if there is an error."
          }
        }
      },
      "listImages": {
        "desc": "Returns an Array of strings containing the IDs of all images currently available in the map.\nThis includes both images from the style's original sprite\nand any images that have been added at runtime using Map#addImage.",
        "returns": {
          "type": "Array<string>",
          "desc": ": An Array of strings containing the names of all sprites/images currently available in the map."
        }
      },
      "addLayer": {
        "desc": "Adds a Mapbox style layer\nto the map's style.\nA layer defines how data from a specified source will be styled. Read more about layer types\nand available paint and layout properties in the Mapbox Style Specification.",
        "params": {
          "layer": {
            "type": [
              "Object",
              "CustomLayerInterface"
            ],
            "desc": "The style layer to add, conforming to the Mapbox Style Specification's layer definition ."
          },
          "beforeId": {
            "type": [
              "string?"
            ],
            "desc": "The ID of an existing layer to insert the new layer before. If this argument is omitted, the layer will be appended to the end of the layers array."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "moveLayer": {
        "desc": "Moves a layer to a different z-position.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the layer to move."
          },
          "beforeId": {
            "type": [
              "string?"
            ],
            "desc": "The ID of an existing layer to insert the new layer before. If this argument is omitted, the layer will be appended to the end of the layers array."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "removeLayer": {
        "desc": "Removes the layer with the given ID from the map's style.\nIf no such layer exists, an error event is fired.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "id of the layer to remove"
          }
        }
      },
      "getLayer": {
        "desc": "Returns the layer with the specified ID in the map's style.",
        "params": {
          "id": {
            "type": [
              "string"
            ],
            "desc": "The ID of the layer to get."
          }
        },
        "returns": {
          "type": "Object?",
          "desc": ": The layer with the specified ID, or undefined if the ID corresponds to no existing layers."
        }
      },
      "setLayerZoomRange": {
        "desc": "Sets the zoom extent for the specified style layer. The zoom extent includes the\nminimum zoom level\nand maximum zoom level)\nat which the layer will be rendered.\nNote: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\nminimum zoom level of the source layer because the data does not exist at those zoom levels. If the minimum\nzoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\nlayer will not be rendered at all zoom levels in the zoom range.",
        "params": {
          "layerId": {
            "type": [
              "string"
            ],
            "desc": "The ID of the layer to which the zoom extent will be applied."
          },
          "minzoom": {
            "type": [
              "number"
            ],
            "desc": "The minimum zoom to set (0-24)."
          },
          "maxzoom": {
            "type": [
              "number"
            ],
            "desc": "The maximum zoom to set (0-24)."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "setFilter": {
        "desc": "Sets the filter for the specified style layer.",
        "params": {
          "layerId": {
            "type": [
              "string"
            ],
            "desc": "The ID of the layer to which the filter will be applied."
          },
          "filter": {
            "type": [
              "Array",
              "null",
              "undefined"
            ],
            "desc": "The filter, conforming to the Mapbox Style Specification's filter definition . If null or undefined is provided, the function removes any existing filter from the layer."
          },
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "(default {})"
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getFilter": {
        "desc": "Returns the filter applied to the specified style layer.",
        "params": {
          "layerId": {
            "type": [
              "string"
            ],
            "desc": "The ID of the style layer whose filter to get."
          }
        },
        "returns": {
          "type": "Array",
          "desc": ": The layer's filter."
        }
      },
      "setPaintProperty": {
        "desc": "Sets the value of a paint property in the specified style layer.",
        "params": {
          "layerId": {
            "type": [
              "string"
            ],
            "desc": "The ID of the layer to set the paint property in."
          },
          "name": {
            "type": [
              "string"
            ],
            "desc": "The name of the paint property to set."
          },
          "value": {
            "type": [
              "any"
            ],
            "desc": "The value of the paint property to set. Must be of a type appropriate for the property, as defined in the Mapbox Style Specification ."
          },
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "(default {})"
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getPaintProperty": {
        "desc": "Returns the value of a paint property in the specified style layer.",
        "params": {
          "layerId": {
            "type": [
              "string"
            ],
            "desc": "The ID of the layer to get the paint property from."
          },
          "name": {
            "type": [
              "string"
            ],
            "desc": "The name of a paint property to get."
          }
        },
        "returns": {
          "type": "any",
          "desc": ": The value of the specified paint property."
        }
      },
      "setLayoutProperty": {
        "desc": "Sets the value of a layout property in the specified style layer.",
        "params": {
          "layerId": {
            "type": [
              "string"
            ],
            "desc": "The ID of the layer to set the layout property in."
          },
          "name": {
            "type": [
              "string"
            ],
            "desc": "The name of the layout property to set."
          },
          "value": {
            "type": [
              "any"
            ],
            "desc": "The value of the layout property. Must be of a type appropriate for the property, as defined in the Mapbox Style Specification ."
          },
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "(default {})"
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getLayoutProperty": {
        "desc": "Returns the value of a layout property in the specified style layer.",
        "params": {
          "layerId": {
            "type": [
              "string"
            ],
            "desc": "The ID of the layer to get the layout property from."
          },
          "name": {
            "type": [
              "string"
            ],
            "desc": "The name of the layout property to get."
          }
        },
        "returns": {
          "type": "any",
          "desc": ": The value of the specified layout property."
        }
      },
      "setLight": {
        "desc": "Sets the any combination of light values.",
        "params": {
          "light": {
            "type": [
              "LightSpecification"
            ],
            "desc": "Light properties to set. Must conform to the Mapbox Style Specification ."
          },
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "(default {})"
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getLight": {
        "desc": "Returns the value of the light object.",
        "returns": {
          "type": "Object",
          "desc": ": light Light properties of the style."
        }
      },
      "setFeatureState": {
        "desc": "Sets the state of a feature. The state object is merged in with the existing state of the feature.\nFeatures are identified by their id attribute, which must be an integer or a string that can be\ncast to an integer.",
        "params": {
          "feature": {
            "type": [
              "Object"
            ],
            "desc": "Feature identifier. Feature objects returned from Map#queryRenderedFeatures or event handlers can be used as feature identifiers."
          },
          "state": {
            "type": [
              "Object"
            ],
            "desc": "A set of key-value pairs. The values should be valid JSON types. This method requires the feature.id attribute on data sets. For GeoJSON sources without feature ids, set the generateId option in the GeoJSONSourceSpecification to auto-assign them. This option assigns ids based on a feature's index in the source data. If you change feature data using map.getSource('some id').setData(..), you may need to re-apply state taking into account updated id values."
          }
        }
      },
      "removeFeatureState": {
        "desc": "Removes feature state, setting it back to the default behavior. If only\nsource is specified, removes all states of that source. If\ntarget.id is also specified, removes all keys for that feature's state.\nIf key is also specified, removes that key from that feature's state.\nFeatures are identified by their id attribute, which must be an integer or a string that can be\ncast to an integer.",
        "params": {
          "target": {
            "type": [
              "Object"
            ],
            "desc": "Identifier of where to set state: can be a source, a feature, or a specific key of feature. Feature objects returned from Map#queryRenderedFeatures or event handlers can be used as feature identifiers."
          },
          "key": {
            "type": [
              "string"
            ],
            "desc": "(optional) The key in the feature state to reset."
          }
        }
      },
      "getFeatureState": {
        "desc": "Gets the state of a feature.\nFeatures are identified by their id attribute, which must be an integer or a string that can be\ncast to an integer.",
        "params": {
          "feature": {
            "type": [
              "Object"
            ],
            "desc": "Feature identifier. Feature objects returned from Map#queryRenderedFeatures or event handlers can be used as feature identifiers."
          }
        },
        "returns": {
          "type": "Object",
          "desc": ": The state of the feature."
        }
      },
      "getContainer": {
        "desc": "Returns the map's containing HTML element.",
        "returns": {
          "type": "HTMLElement",
          "desc": ": The map's container."
        }
      },
      "getCanvasContainer": {
        "desc": "Returns the HTML element containing the map's <canvas> element.\nIf you want to add non-GL overlays to the map, you should append them to this element.\nThis is the element to which event bindings for map interactivity (such as panning and zooming) are\nattached. It will receive bubbled events from child elements such as the <canvas>, but not from\nmap controls.",
        "returns": {
          "type": "HTMLElement",
          "desc": ": The container of the map's <canvas> ."
        }
      },
      "getCanvas": {
        "desc": "Returns the map's <canvas> element.",
        "returns": {
          "type": "HTMLCanvasElement",
          "desc": ": The map's <canvas> element."
        }
      },
      "loaded": {
        "desc": "Returns a Boolean indicating whether the map is fully loaded.\nReturns false if the style is not yet fully loaded,\nor if there has been a change to the sources or style that\nhas not yet fully loaded.",
        "returns": {
          "type": "boolean",
          "desc": ": A Boolean indicating whether the map is fully loaded."
        }
      },
      "remove": {
        "desc": "Clean up and release all internal resources associated with this map.\nThis includes DOM elements, event bindings, web workers, and WebGL resources.\nUse this method when you are done using the map and wish to ensure that it no\nlonger consumes browser resources. Afterwards, you must not call any other\nmethods on the map."
      },
      "triggerRepaint": {
        "desc": "Trigger the rendering of a single frame. Use this method with custom layers to\nrepaint the map when the layer changes. Calling this multiple times before the\nnext frame is rendered will still result in only a single frame being rendered."
      },
      "showTileBoundaries": {
        "desc": "Gets and sets a Boolean indicating whether the map will render an outline\naround each tile and the tile ID. These tile boundaries are useful for\ndebugging.\nThe uncompressed file size of the first vector source is drawn in the top left\ncorner of each tile, next to the tile ID."
      },
      "showPadding": {
        "desc": "Gets and sets a Boolean indicating whether the map will visualize\nthe padding offsets."
      },
      "showCollisionBoxes": {
        "desc": "Gets and sets a Boolean indicating whether the map will render boxes\naround all symbols in the data source, revealing which symbols\nwere rendered or which were hidden due to collisions.\nThis information is useful for debugging."
      },
      "repaint": {
        "desc": "Gets and sets a Boolean indicating whether the map will\ncontinuously repaint. This information is useful for analyzing performance."
      },
      "version": {
        "desc": "The version of Mapbox GL JS in use as specified in package.json, CHANGELOG.md, and the GitHub release."
      },
      "getCenter": {
        "desc": "Returns the map's geographical centerpoint.",
        "returns": {
          "type": "LngLat",
          "desc": ": The map's geographical centerpoint."
        }
      },
      "setCenter": {
        "desc": "Sets the map's geographical centerpoint. Equivalent to jumpTo({center: center}).",
        "params": {
          "center": {
            "type": [
              "LngLatLike"
            ],
            "desc": "The centerpoint to set."
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "panBy": {
        "desc": "Pans the map by the specified offset.",
        "params": {
          "offset": {
            "type": [
              "PointLike"
            ],
            "desc": "x and y coordinates by which to pan the map."
          },
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "panTo": {
        "desc": "Pans the map to the specified location, with an animated transition.",
        "params": {
          "lnglat": {
            "type": [
              "LngLatLike"
            ],
            "desc": "The location to pan the map to."
          },
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getZoom": {
        "desc": "Returns the map's current zoom level.",
        "returns": {
          "type": "number",
          "desc": ": The map's current zoom level."
        }
      },
      "setZoom": {
        "desc": "Sets the map's zoom level. Equivalent to jumpTo({zoom: zoom}).",
        "params": {
          "zoom": {
            "type": [
              "number"
            ],
            "desc": "The zoom level to set (0-20)."
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "zoomTo": {
        "desc": "Zooms the map to the specified zoom level, with an animated transition.",
        "params": {
          "zoom": {
            "type": [
              "number"
            ],
            "desc": "The zoom level to transition to."
          },
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "zoomIn": {
        "desc": "Increases the map's zoom level by 1.",
        "params": {
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "zoomOut": {
        "desc": "Decreases the map's zoom level by 1.",
        "params": {
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getBearing": {
        "desc": "Returns the map's current bearing. The bearing is the compass direction that is \\\"up\\\"; for example, a bearing\nof 90° orients the map so that east is up.",
        "returns": {
          "type": "number",
          "desc": ": The map's current bearing."
        }
      },
      "setBearing": {
        "desc": "Sets the map's bearing (rotation). The bearing is the compass direction that is \\\"up\\\"; for example, a bearing\nof 90° orients the map so that east is up.\nEquivalent to jumpTo({bearing: bearing}).",
        "params": {
          "bearing": {
            "type": [
              "number"
            ],
            "desc": "The desired bearing."
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getPadding": {
        "desc": "Returns the current padding applied around the map viewport.",
        "returns": {
          "type": "PaddingOptions",
          "desc": ": The current padding around the map viewport."
        }
      },
      "setPadding": {
        "desc": "Sets the padding in pixels around the viewport.\nEquivalent to jumpTo({padding: padding}).",
        "params": {
          "padding": {
            "type": [
              "PaddingOptions"
            ],
            "desc": "The desired padding. Format: { left: number, right: number, top: number, bottom: number }"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "rotateTo": {
        "desc": "Rotates the map to the specified bearing, with an animated transition. The bearing is the compass direction\nthat is \\\"up\\\"; for example, a bearing of 90° orients the map so that east is up.",
        "params": {
          "bearing": {
            "type": [
              "number"
            ],
            "desc": "The desired bearing."
          },
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "resetNorth": {
        "desc": "Rotates the map so that north is up (0° bearing), with an animated transition.",
        "params": {
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "resetNorthPitch": {
        "desc": "Rotates and pitches the map so that north is up (0° bearing) and pitch is 0°, with an animated transition.",
        "params": {
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "snapToNorth": {
        "desc": "Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it (i.e. within the\nbearingSnap threshold).",
        "params": {
          "options": {
            "type": [
              "AnimationOptions?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "getPitch": {
        "desc": "Returns the map's current pitch (tilt).",
        "returns": {
          "type": "number",
          "desc": ": The map's current pitch, measured in degrees away from the plane of the screen."
        }
      },
      "setPitch": {
        "desc": "Sets the map's pitch (tilt). Equivalent to jumpTo({pitch: pitch}).",
        "params": {
          "pitch": {
            "type": [
              "number"
            ],
            "desc": "The pitch to set, measured in degrees away from the plane of the screen (0-60)."
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "cameraForBounds": {
        "desc": "",
        "params": {
          "bounds": {
            "type": [
              "LngLatBoundsLike"
            ],
            "desc": "Calculate the center for these bounds in the viewport and use the highest zoom level up to and including Map#getMaxZoom() that fits in the viewport. LatLngBounds represent a box that is always axis-aligned with bearing 0."
          },
          "options": {
            "type": [
              "CameraOptions?"
            ],
            "desc": "Options object"
          }
        },
        "returns": {
          "type": "(CameraOptions | void)",
          "desc": ": If map is able to fit to provided bounds, returns CameraOptions with center , zoom , and bearing . If map is unable to fit, method will warn and return undefined."
        }
      },
      "fitBounds": {
        "desc": "Pans and zooms the map to contain its visible area within the specified geographical bounds.\nThis function will also reset the map's bearing to 0 if bearing is nonzero.",
        "params": {
          "bounds": {
            "type": [
              "LngLatBoundsLike"
            ],
            "desc": "Center these bounds in the viewport and use the highest zoom level up to and including Map#getMaxZoom() that fits them in the viewport."
          },
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "Options supports all properties from AnimationOptions and CameraOptions in addition to the fields below."
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "fitScreenCoordinates": {
        "desc": "Pans, rotates and zooms the map to to fit the box made by points p0 and p1\nonce the map is rotated to the specified bearing. To zoom without rotating,\npass in the current map bearing.",
        "params": {
          "p0": {
            "type": [
              "PointLike"
            ],
            "desc": "First point on screen, in pixel coordinates"
          },
          "p1": {
            "type": [
              "PointLike"
            ],
            "desc": "Second point on screen, in pixel coordinates"
          },
          "bearing": {
            "type": [
              "number"
            ],
            "desc": "Desired map bearing at end of animation, in degrees"
          },
          "options": {
            "type": [
              "any?"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "jumpTo": {
        "desc": "Changes any combination of center, zoom, bearing, and pitch, without\nan animated transition. The map will retain its current values for any\ndetails not specified in options.",
        "params": {
          "options": {
            "type": [
              "CameraOptions"
            ],
            "desc": "Options object"
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "easeTo": {
        "desc": "Changes any combination of center, zoom, bearing, pitch, and padding with an animated transition\nbetween old and new values. The map will retain its current values for any\ndetails not specified in options.\nNote: The transition will happen instantly if the user has enabled\nthe reduced motion accesibility feature enabled in their operating system,\nunless 'options' includes essential: true.",
        "params": {
          "options": {
            "type": [
              "any"
            ],
            "desc": "Options describing the destination and animation of the transition. Accepts CameraOptions and AnimationOptions ."
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "flyTo": {
        "desc": "Changes any combination of center, zoom, bearing, and pitch, animating the transition along a curve that\nevokes flight. The animation seamlessly incorporates zooming and panning to help\nthe user maintain her bearings even after traversing a great distance.\nNote: The animation will be skipped, and this will behave equivalently to jumpTo\nif the user has the reduced motion accesibility feature enabled in their operating system,\nunless 'options' includes essential: true.",
        "params": {
          "options": {
            "type": [
              "Object"
            ],
            "desc": "Options describing the destination and animation of the transition. Accepts CameraOptions , AnimationOptions , and the following additional options."
          },
          "eventData": {
            "type": [
              "Object?"
            ],
            "desc": "Additional properties to be added to event objects of events triggered by this method."
          }
        },
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      },
      "stop": {
        "desc": "Stops any animated transition underway.",
        "returns": {
          "type": "Map",
          "desc": ": this"
        }
      }
    }
  },
  {
    "name": "accessToken",
    "desc": "Gets and sets the map's access token."
  },
  {
    "name": "baseApiUrl",
    "desc": "Gets and sets the map's default API URL for requesting tiles, styles, sprites, and glyphs"
  },
  {
    "name": "workerCount",
    "desc": "Gets and sets the number of web workers instantiated on a page with GL JS maps. By default, it is set to half the number of CPU cores (capped at 6). Make sure to set this property before creating any map instances for it to have effect."
  },
  {
    "name": "maxParallelImageRequests",
    "desc": "Gets and sets the maximum number of images (raster tiles, sprites, icons) to load in parallel, which affects performance in raster-heavy maps. 16 by default."
  },
  {
    "name": "supported",
    "desc": "Test whether the browser supports Mapbox GL JS."
  },
  {
    "name": "version",
    "desc": "The version of Mapbox GL JS in use as specified in package.json, CHANGELOG.md, and the GitHub release."
  },
  {
    "name": "setRTLTextPlugin",
    "desc": "Sets the map's RTL text plugin. Necessary for supporting the Arabic and Hebrew languages, which are written right-to-left. Mapbox Studio loads this plugin by default."
  },
  {
    "name": "getRTLTextPluginStatus",
    "desc": "Gets the map's RTL text plugin status. The status can be unavailable (i.e. not requested or removed), loading, loaded or error. If the status is loaded and the plugin is requested again, an error will be thrown."
  },
  {
    "name": "clearStorage",
    "desc": "Clears browser storage used by this library. Using this method flushes the Mapbox tile cache that is managed by this library. Tiles may still be cached by the browser in some cases. This API is supported on browsers where the Cache API is supported and enabled. This includes all major browsers when pages are served over https://, except Internet Explorer and Edge Mobile. When called in unsupported browsers or environments (private or incognito mode), the callback will be called with an error argument."
  },
  {
    "name": "AnimationOptions",
    "desc": "Options common to map movement methods that involve animation, such as Map#panBy and Map#easeTo, controlling the duration and easing function of the animation. All properties are optional."
  },
  {
    "name": "CameraOptions",
    "desc": "Options common to Map#jumpTo, Map#easeTo, and Map#flyTo, controlling the desired location, zoom, bearing, and pitch of the camera. All properties are optional, and when a property is omitted, the current camera value for that property will remain unchanged."
  },
  {
    "name": "PaddingOptions",
    "desc": "Options for setting padding on a call to Map#fitBounds. All properties of this object must be non-negative integers."
  },
  {
    "name": "RequestParameters",
    "desc": "A RequestParameters object to be returned from Map.options.transformRequest callbacks."
  },
  {
    "name": "StyleImageInterface",
    "desc": "Interface for dynamically generated style images. This is a specification for implementers to model: it is not an exported method or class. Images implementing this interface can be redrawn for every frame. They can be used to animate icons and patterns or make them respond to user input. Style images can implement a StyleImageInterface#render method. The method is called every frame and can be used to update the image.",
    "methods": {
      "onRemove": {
        "desc": "Optional method called when the icon is removed from the map with Map#removeImage.\nThis gives the image a chance to clean up resources and event listeners."
      },
      "render": {
        "desc": "This method is called once before every frame where the icon will be used.\nThe method can optionally update the image's data member with a new image.\nIf the method updates the image it must return true to commit the change.\nIf the method returns false or nothing the image is assumed to not have changed.\nIf updates are infrequent it maybe easier to use Map#updateImage to update\nthe image instead of implementing this method.",
        "returns": {
          "type": "boolean",
          "desc": ": true if this method updated the image. false if the image was not changed."
        }
      },
      "onAdd": {
        "desc": "Optional method called when the layer has been added to the Map with Map#addImage.",
        "params": {
          "map": {
            "type": [
              "Map"
            ],
            "desc": "The Map this custom layer was just added to."
          }
        }
      }
    }
  },
  {
    "name": "CustomLayerInterface",
    "desc": "Interface for custom style layers. This is a specification for implementers to model: it is not an exported method or class. Custom layers allow a user to render directly into the map's GL context using the map's camera. These layers can be added between any regular layers using Map#addLayer. Custom layers must have a unique id and must have the type of \"custom\". They must implement render and may implement prerender, onAdd and onRemove. They can trigger rendering using Map#triggerRepaint and they should appropriately handle Map.event:webglcontextlost and Map.event:webglcontextrestored. The renderingMode property controls whether the layer is treated as a \"2d\" or \"3d\" map layer. Use: \"renderingMode\": \"3d\" to use the depth buffer and share it with other layers \"renderingMode\": \"2d\" to add a layer with no depth. If you need to use the depth buffer for a \"2d\" layer you must use an offscreen framebuffer and CustomLayerInterface#prerender",
    "methods": {
      "onAdd": {
        "desc": "Optional method called when the layer has been added to the Map with Map#addLayer. This\ngives the layer a chance to initialize gl resources and register event listeners.",
        "params": {
          "map": {
            "type": [
              "Map"
            ],
            "desc": "The Map this custom layer was just added to."
          },
          "gl": {
            "type": [
              "WebGLRenderingContext"
            ],
            "desc": "The gl context for the map."
          }
        }
      },
      "onRemove": {
        "desc": "Optional method called when the layer has been removed from the Map with Map#removeLayer. This\ngives the layer a chance to clean up gl resources and event listeners.",
        "params": {
          "map": {
            "type": [
              "Map"
            ],
            "desc": "The Map this custom layer was just added to."
          },
          "gl": {
            "type": [
              "WebGLRenderingContext"
            ],
            "desc": "The gl context for the map."
          }
        }
      },
      "prerender": {
        "desc": "Optional method called during a render frame to allow a layer to prepare resources or render into a texture.\nThe layer cannot make any assumptions about the current GL state and must bind a framebuffer before rendering.",
        "params": {
          "gl": {
            "type": [
              "WebGLRenderingContext"
            ],
            "desc": "The map's gl context."
          },
          "matrix": {
            "type": [
              "Array<number>"
            ],
            "desc": "The map's camera matrix. It projects spherical mercator coordinates to gl coordinates. The mercator coordinate [0, 0] represents the top left corner of the mercator world and [1, 1] represents the bottom right corner. When the renderingMode is \"3d\" , the z coordinate is conformal. A box with identical x, y, and z lengths in mercator units would be rendered as a cube. MercatorCoordinate .fromLatLng can be used to project a LngLat to a mercator coordinate."
          }
        }
      },
      "render": {
        "desc": "Called during a render frame allowing the layer to draw into the GL context.\nThe layer can assume blending and depth state is set to allow the layer to properly\nblend and clip other layers. The layer cannot make any other assumptions about the\ncurrent GL state.\nIf the layer needs to render to a texture, it should implement the prerender method\nto do this and only use the render method for drawing directly into the main framebuffer.\nThe blend function is set to gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA). This expects\ncolors to be provided in premultiplied alpha form where the r, g and b values are already\nmultiplied by the a value. If you are unable to provide colors in premultiplied form you\nmay want to change the blend function to\ngl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA).",
        "params": {
          "gl": {
            "type": [
              "WebGLRenderingContext"
            ],
            "desc": "The map's gl context."
          },
          "matrix": {
            "type": [
              "Array<number>"
            ],
            "desc": "The map's camera matrix. It projects spherical mercator coordinates to gl coordinates. The spherical mercator coordinate [0, 0] represents the top left corner of the mercator world and [1, 1] represents the bottom right corner. When the renderingMode is \"3d\" , the z coordinate is conformal. A box with identical x, y, and z lengths in mercator units would be rendered as a cube. MercatorCoordinate .fromLatLng can be used to project a LngLat to a mercator coordinate."
          }
        }
      }
    }
  },
  {
    "name": "LngLat",
    "desc": "A LngLat object represents a given longitude and latitude coordinate, measured in degrees. Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON. Note that any Mapbox GL method that accepts a LngLat object as an argument or option can also accept an Array of two numbers and will perform an implicit conversion. This flexible type is documented as LngLatLike.",
    "methods": {
      "wrap": {
        "desc": "Returns a new LngLat object whose longitude is wrapped to the range (-180, 180).",
        "returns": {
          "type": "LngLat",
          "desc": ": The wrapped LngLat object."
        }
      },
      "toArray": {
        "desc": "Returns the coordinates represented as an array of two numbers.",
        "returns": {
          "type": "Array<number>",
          "desc": ": The coordinates represeted as an array of longitude and latitude."
        }
      },
      "toString": {
        "desc": "Returns the coordinates represent as a string.",
        "returns": {
          "type": "string",
          "desc": ": The coordinates represented as a string of the format 'LngLat(lng, lat)' ."
        }
      },
      "distanceTo": {
        "desc": "Returns the approximate distance between a pair of coordinates in meters\nUses the Haversine Formula (from R.W. Sinnott, \"Virtues of the Haversine\", Sky and Telescope, vol. 68, no. 2, 1984, p. 159)",
        "params": {
          "lngLat": {
            "type": [
              "LngLat"
            ],
            "desc": "coordinates to compute the distance to"
          }
        },
        "returns": {
          "type": "number",
          "desc": ": Distance in meters between the two coordinates."
        }
      },
      "toBounds": {
        "desc": "Returns a LngLatBounds from the coordinates extended by a given radius. The returned LngLatBounds completely contains the radius.",
        "params": {
          "radius": {
            "type": [
              "number"
            ],
            "desc": "(default 0)"
          }
        },
        "returns": {
          "type": "LngLatBounds",
          "desc": ": A new LngLatBounds object representing the coordinates extended by the radius ."
        }
      }
    }
  },
  {
    "name": "LngLatLike",
    "desc": "A LngLat object, an array of two numbers representing longitude and latitude, or an object with lng and lat or lon and lat properties."
  },
  {
    "name": "LngLatBounds",
    "desc": "A LngLatBounds object represents a geographical bounding box, defined by its southwest and northeast points in longitude and latitude. If no arguments are provided to the constructor, a null bounding box is created. Note that any Mapbox GL method that accepts a LngLatBounds object as an argument or option can also accept an Array of two LngLatLike constructs and will perform an implicit conversion. This flexible type is documented as LngLatBoundsLike.",
    "methods": {
      "setNorthEast": {
        "desc": "Set the northeast corner of the bounding box",
        "params": {
          "ne": {
            "type": [
              "LngLatLike"
            ],
            "desc": "a LngLatLike object describing the northeast corner of the bounding box."
          }
        },
        "returns": {
          "type": "LngLatBounds",
          "desc": ": this"
        }
      },
      "setSouthWest": {
        "desc": "Set the southwest corner of the bounding box",
        "params": {
          "sw": {
            "type": [
              "LngLatLike"
            ],
            "desc": "a LngLatLike object describing the southwest corner of the bounding box."
          }
        },
        "returns": {
          "type": "LngLatBounds",
          "desc": ": this"
        }
      },
      "extend": {
        "desc": "Extend the bounds to include a given LngLatLike or LngLatBoundsLike.",
        "params": {
          "obj": {
            "type": [
              "LngLatLike",
              "LngLatBoundsLike"
            ],
            "desc": "object to extend to"
          }
        },
        "returns": {
          "type": "LngLatBounds",
          "desc": ": this"
        }
      },
      "getCenter": {
        "desc": "Returns the geographical coordinate equidistant from the bounding box's corners.",
        "returns": {
          "type": "LngLat",
          "desc": ": The bounding box's center."
        }
      },
      "getSouthWest": {
        "desc": "Returns the southwest corner of the bounding box.",
        "returns": {
          "type": "LngLat",
          "desc": ": The southwest corner of the bounding box."
        }
      },
      "getNorthEast": {
        "desc": "Returns the northeast corner of the bounding box.",
        "returns": {
          "type": "LngLat",
          "desc": ": The northeast corner of the bounding box."
        }
      },
      "getNorthWest": {
        "desc": "Returns the northwest corner of the bounding box.",
        "returns": {
          "type": "LngLat",
          "desc": ": The northwest corner of the bounding box."
        }
      },
      "getSouthEast": {
        "desc": "Returns the southeast corner of the bounding box.",
        "returns": {
          "type": "LngLat",
          "desc": ": The southeast corner of the bounding box."
        }
      },
      "getWest": {
        "desc": "Returns the west edge of the bounding box.",
        "returns": {
          "type": "number",
          "desc": ": The west edge of the bounding box."
        }
      },
      "getSouth": {
        "desc": "Returns the south edge of the bounding box.",
        "returns": {
          "type": "number",
          "desc": ": The south edge of the bounding box."
        }
      },
      "getEast": {
        "desc": "Returns the east edge of the bounding box.",
        "returns": {
          "type": "number",
          "desc": ": The east edge of the bounding box."
        }
      },
      "getNorth": {
        "desc": "Returns the north edge of the bounding box.",
        "returns": {
          "type": "number",
          "desc": ": The north edge of the bounding box."
        }
      },
      "toArray": {
        "desc": "Returns the bounding box represented as an array.",
        "returns": {
          "type": "Array<Array<number>>",
          "desc": ": The bounding box represented as an array, consisting of the southwest and northeast coordinates of the bounding represented as arrays of numbers."
        }
      },
      "toString": {
        "desc": "Return the bounding box represented as a string.",
        "returns": {
          "type": "string",
          "desc": ": The bounding box represents as a string of the format 'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))' ."
        }
      },
      "isEmpty": {
        "desc": "Check if the bounding box is an empty/null-type box.",
        "returns": {
          "type": "boolean",
          "desc": ": True if bounds have been defined, otherwise false."
        }
      },
      "contains": {
        "desc": "Check if the point is within the bounding box.",
        "params": {
          "lnglat": {
            "type": [
              "LngLatLike"
            ],
            "desc": "geographic point to check against."
          }
        },
        "returns": {
          "type": "boolean",
          "desc": ": True if the point is within the bounding box."
        }
      }
    }
  },
  {
    "name": "LngLatBoundsLike",
    "desc": "A LngLatBounds object, an array of LngLatLike objects in [sw, ne] order, or an array of numbers in [west, south, east, north] order."
  },
  {
    "name": "Point",
    "desc": "A Point geometry object, which has x and y properties representing screen coordinates in pixels."
  },
  {
    "name": "PointLike",
    "desc": "A Point or an array of two numbers representing x and y screen coordinates in pixels."
  },
  {
    "name": "MercatorCoordinate",
    "desc": "A MercatorCoordinate object represents a projected three dimensional position. MercatorCoordinate uses the web mercator projection (EPSG:3857) with slightly different units: the size of 1 unit is the width of the projected world instead of the \"mercator meter\" the origin of the coordinate space is at the north-west corner instead of the middle For example, MercatorCoordinate(0, 0, 0) is the north-west corner of the mercator world and MercatorCoordinate(1, 1, 0) is the south-east corner. If you are familiar with vector tiles it may be helpful to think of the coordinate space as the 0/0/0 tile with an extent of 1. The z dimension of MercatorCoordinate is conformal. A cube in the mercator coordinate space would be rendered as a cube.",
    "methods": {
      "toLngLat": {
        "desc": "Returns the LngLat for the coordinate.",
        "returns": {
          "type": "LngLat",
          "desc": ": The LngLat object."
        }
      },
      "toAltitude": {
        "desc": "Returns the altitude in meters of the coordinate.",
        "returns": {
          "type": "number",
          "desc": ": The altitude in meters."
        }
      },
      "meterInMercatorCoordinateUnits": {
        "desc": "Returns the distance of 1 meter in MercatorCoordinate units at this latitude.\nFor coordinates in real world units using meters, this naturally provides the scale\nto transform into MercatorCoordinates.",
        "returns": {
          "type": "number",
          "desc": ": Distance of 1 meter in MercatorCoordinate units."
        }
      }
    }
  },
  {
    "name": "IControl",
    "desc": "Interface for interactive controls added to the map. This is a specification for implementers to model: it is not an exported method or class. Controls must implement onAdd and onRemove, and must own an element, which is often a div element. To use Mapbox GL JS's default control styling, add the mapboxgl-ctrl class to your control's node.",
    "methods": {
      "onAdd": {
        "desc": "Register a control on the map and give it a chance to register event listeners\nand resources. This method is called by Map#addControl\ninternally.",
        "params": {
          "map": {
            "type": [
              "Map"
            ],
            "desc": "the Map this control will be added to"
          }
        },
        "returns": {
          "type": "HTMLElement",
          "desc": ": The control's container element. This should be created by the control and returned by onAdd without being attached to the DOM: the map will insert the control's element into the DOM as necessary."
        }
      },
      "onRemove": {
        "desc": "Unregister a control on the map and give it a chance to detach event listeners\nand resources. This method is called by Map#removeControl\ninternally.",
        "params": {
          "map": {
            "type": [
              "Map"
            ],
            "desc": "the Map this control will be removed from"
          }
        },
        "returns": {
          "type": "undefined",
          "desc": ": there is no required return value for this method"
        }
      },
      "getDefaultPosition": {
        "desc": "Optionally provide a default position for this control. If this method\nis implemented and Map#addControl is called without the position\nparameter, the value returned by getDefaultPosition will be used as the\ncontrol's position.",
        "returns": {
          "type": "string",
          "desc": ": a control position, one of the values valid in addControl."
        }
      }
    }
  },
  {
    "name": "NavigationControl",
    "desc": "A NavigationControl control contains zoom buttons and a compass."
  },
  {
    "name": "GeolocateControl",
    "desc": "A GeolocateControl control provides a button that uses the browser's geolocation API to locate the user on the map. Not all browsers support geolocation, and some users may disable the feature. Geolocation support for modern browsers including Chrome requires sites to be served over HTTPS. If geolocation support is not available, the GeolocateControl will not be visible. The zoom level applied will depend on the accuracy of the geolocation provided by the device. The GeolocateControl has two modes. If trackUserLocation is false (default) the control acts as a button, which when pressed will set the map's camera to target the user location. If the user moves, the map won't update. This is most suited for the desktop. If trackUserLocation is true the control acts as a toggle button that when active the user's location is actively monitored for changes. In this mode the GeolocateControl has three interaction states: active - the map's camera automatically updates as the user's location changes, keeping the location dot in the center. Initial state and upon clicking the GeolocateControl button. passive - the user's location dot automatically updates, but the map's camera does not. Occurs upon the user initiating a map movement. disabled - occurs if Geolocation is not available, disabled or denied. These interaction states can't be controlled programmatically, rather they are set based on user interactions.",
    "methods": {
      "trigger": {
        "desc": "Trigger a geolocation",
        "returns": {
          "type": "boolean",
          "desc": ": Returns false if called before control was added to a map, otherwise returns true ."
        }
      }
    }
  },
  {
    "name": "AttributionControl",
    "desc": "An AttributionControl control presents the map's attribution information."
  },
  {
    "name": "ScaleControl",
    "desc": "A ScaleControl control displays the ratio of a distance on the map to the corresponding distance on the ground.",
    "methods": {
      "setUnit": {
        "desc": "Set the scale's unit of the distance",
        "params": {
          "unit": {
            "type": [
              "Unit"
            ],
            "desc": "Unit of the distance ( 'imperial' , 'metric' or 'nautical' )."
          }
        }
      }
    }
  },
  {
    "name": "FullscreenControl",
    "desc": "A FullscreenControl control contains a button for toggling the map in and out of fullscreen mode."
  },
  {
    "name": "Popup",
    "desc": "A popup component.",
    "methods": {
      "addTo": {
        "desc": "Adds the popup to a map.",
        "params": {
          "map": {
            "type": [
              "Map"
            ],
            "desc": "The Mapbox GL JS map to add the popup to."
          }
        },
        "returns": {
          "type": "Popup",
          "desc": ": this"
        }
      },
      "isOpen": {
        "desc": "",
        "returns": {
          "type": "boolean",
          "desc": ": true if the popup is open, false if it is closed."
        }
      },
      "remove": {
        "desc": "Removes the popup from the map it has been added to.",
        "returns": {
          "type": "Popup",
          "desc": ": this"
        }
      },
      "getLngLat": {
        "desc": "Returns the geographical location of the popup's anchor.\nThe longitude of the result may differ by a multiple of 360 degrees from the longitude previously\nset by setLngLat because Popup wraps the anchor longitude across copies of the world to keep\nthe popup on screen.",
        "returns": {
          "type": "LngLat",
          "desc": ": The geographical location of the popup's anchor."
        }
      },
      "setLngLat": {
        "desc": "Sets the geographical location of the popup's anchor, and moves the popup to it. Replaces trackPointer() behavior.",
        "params": {
          "lnglat": {
            "type": [
              "LngLatLike"
            ],
            "desc": "The geographical location to set as the popup's anchor."
          }
        },
        "returns": {
          "type": "Popup",
          "desc": ": this"
        }
      },
      "trackPointer": {
        "desc": "Tracks the popup anchor to the cursor position, on screens with a pointer device (will be hidden on touchscreens). Replaces the setLngLat behavior.\nFor most use cases, closeOnClick and closeButton should also be set to false here.",
        "returns": {
          "type": "Popup",
          "desc": ": this"
        }
      },
      "getElement": {
        "desc": "Returns the Popup's HTML element.",
        "returns": {
          "type": "HTMLElement",
          "desc": ": element"
        }
      },
      "setText": {
        "desc": "Sets the popup's content to a string of text.\nThis function creates a Text node in the DOM,\nso it cannot insert raw HTML. Use this method for security against XSS\nif the popup content is user-provided.",
        "params": {
          "text": {
            "type": [
              "string"
            ],
            "desc": "Textual content for the popup."
          }
        },
        "returns": {
          "type": "Popup",
          "desc": ": this"
        }
      },
      "setHTML": {
        "desc": "Sets the popup's content to the HTML provided as a string.\nThis method does not perform HTML filtering or sanitization, and must be\nused only with trusted content. Consider Popup#setText if\nthe content is an untrusted text string.",
        "params": {
          "html": {
            "type": [
              "string"
            ],
            "desc": "A string representing HTML content for the popup."
          }
        },
        "returns": {
          "type": "Popup",
          "desc": ": this"
        }
      },
      "getMaxWidth": {
        "desc": "Returns the popup's maximum width.",
        "returns": {
          "type": "string",
          "desc": ": The maximum width of the popup."
        }
      },
      "setMaxWidth": {
        "desc": "Sets the popup's maximum width. This is setting the CSS property max-width.\nAvailable values can be found here: https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
        "params": {
          "maxWidth": {
            "type": [
              "string"
            ],
            "desc": "A string representing the value for the maximum width."
          }
        },
        "returns": {
          "type": "Popup",
          "desc": ": this"
        }
      },
      "setDOMContent": {
        "desc": "Sets the popup's content to the element provided as a DOM node.",
        "params": {
          "htmlNode": {
            "type": [
              "Node"
            ],
            "desc": "A DOM node to be used as content for the popup."
          }
        },
        "returns": {
          "type": "Popup",
          "desc": ": this"
        }
      },
      "addClassName": {
        "desc": "Adds a CSS class to the popup container element.",
        "params": {
          "className": {
            "type": [
              "string"
            ],
            "desc": "Non-empty string with CSS class name to add to popup container"
          }
        }
      },
      "removeClassName": {
        "desc": "Removes a CSS class from the popup container element.",
        "params": {
          "className": {
            "type": [
              "string"
            ],
            "desc": "Non-empty string with CSS class name to remove from popup container"
          }
        }
      },
      "toggleClassName": {
        "desc": "Add or remove the given CSS class on the popup container, depending on whether the container currently has that class.",
        "params": {
          "className": {
            "type": [
              "string"
            ],
            "desc": "Non-empty string with CSS class name to add/remove"
          }
        },
        "returns": {
          "type": "boolean",
          "desc": ": if the class was removed return false, if class was added, then return true"
        }
      }
    }
  },
  {
    "name": "Marker",
    "desc": "Creates a marker component",
    "methods": {
      "addTo": {
        "desc": "Attaches the marker to a map",
        "params": {
          "map": {
            "type": [
              "Map"
            ],
            "desc": "The Mapbox GL JS map to add the marker to."
          }
        },
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "remove": {
        "desc": "Removes the marker from a map",
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "getLngLat": {
        "desc": "Get the marker's geographical location.\nThe longitude of the result may differ by a multiple of 360 degrees from the longitude previously\nset by setLngLat because Marker wraps the anchor longitude across copies of the world to keep\nthe marker on screen.",
        "returns": {
          "type": "LngLat",
          "desc": ": A LngLat describing the marker's location."
        }
      },
      "setLngLat": {
        "desc": "Set the marker's geographical position and move it.",
        "params": {
          "lnglat": {
            "type": [
              "LngLat"
            ],
            "desc": "A LngLat describing where the marker should be located."
          }
        },
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "getElement": {
        "desc": "Returns the Marker's HTML element.",
        "returns": {
          "type": "HTMLElement",
          "desc": ": element"
        }
      },
      "setPopup": {
        "desc": "Binds a Popup to the Marker",
        "params": {
          "popup": {
            "type": [
              "Popup?"
            ],
            "desc": "an instance of the Popup class. If undefined or null, any popup set on this Marker instance is unset"
          }
        },
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "getPopup": {
        "desc": "Returns the Popup instance that is bound to the Marker",
        "returns": {
          "type": "Popup",
          "desc": ": popup"
        }
      },
      "togglePopup": {
        "desc": "Opens or closes the bound popup, depending on the current state",
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "getOffset": {
        "desc": "Get the marker's offset.",
        "returns": {
          "type": "Point",
          "desc": ": The marker's screen coordinates in pixels."
        }
      },
      "setOffset": {
        "desc": "Sets the offset of the marker",
        "params": {
          "offset": {
            "type": [
              "PointLike"
            ],
            "desc": "The offset in pixels as a PointLike object to apply relative to the element's center. Negatives indicate left and up."
          }
        },
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "setDraggable": {
        "desc": "Sets the draggable property and functionality of the marker",
        "params": {
          "shouldBeDraggable": {
            "type": [
              "boolean"
            ],
            "desc": "(default false)"
          }
        },
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "isDraggable": {
        "desc": "Returns true if the marker can be dragged",
        "returns": {
          "type": "boolean",
          "desc": ": True if the marker is draggable."
        }
      },
      "setRotation": {
        "desc": "Sets the rotation property of the marker.",
        "params": {
          "rotation": {
            "type": [
              "number"
            ],
            "desc": "(default 0)"
          }
        },
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "getRotation": {
        "desc": "Returns the current rotation angle of the marker (in degrees).",
        "returns": {
          "type": "number",
          "desc": ": The current rotation angle of the marker."
        }
      },
      "setRotationAlignment": {
        "desc": "Sets the rotationAlignment property of the marker.",
        "params": {
          "alignment": {
            "type": [
              "string"
            ],
            "desc": "(default 'auto')"
          }
        },
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "getRotationAlignment": {
        "desc": "Returns the current rotationAlignment property of the marker.",
        "returns": {
          "type": "string",
          "desc": ": The current rotational alignment of the marker."
        }
      },
      "setPitchAlignment": {
        "desc": "Sets the pitchAlignment property of the marker.",
        "params": {
          "alignment": {
            "type": [
              "string?"
            ],
            "desc": "Sets the pitchAlignment property of the marker. If alignment is 'auto', it will automatically match rotationAlignment ."
          }
        },
        "returns": {
          "type": "Marker",
          "desc": ": this"
        }
      },
      "getPitchAlignment": {
        "desc": "Returns the current pitchAlignment property of the marker.",
        "returns": {
          "type": "string",
          "desc": ": The current pitch alignment of the marker in degrees."
        }
      }
    }
  },
  {
    "name": "BoxZoomHandler",
    "desc": "The BoxZoomHandler allows the user to zoom the map to fit within a bounding box. The bounding box is defined by clicking and holding shift while dragging the cursor.",
    "methods": {
      "isEnabled": {
        "desc": "Returns a Boolean indicating whether the \"box zoom\" interaction is enabled.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"box zoom\" interaction is enabled."
        }
      },
      "isActive": {
        "desc": "Returns a Boolean indicating whether the \"box zoom\" interaction is active, i.e. currently being used.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"box zoom\" interaction is active."
        }
      },
      "enable": {
        "desc": "Enables the \"box zoom\" interaction."
      },
      "disable": {
        "desc": "Disables the \"box zoom\" interaction."
      }
    }
  },
  {
    "name": "ScrollZoomHandler",
    "desc": "The ScrollZoomHandler allows the user to zoom the map by scrolling.",
    "methods": {
      "setZoomRate": {
        "desc": "Set the zoom rate of a trackpad",
        "params": {
          "zoomRate": {
            "type": [
              "number"
            ],
            "desc": "(default 1/100)"
          }
        }
      },
      "setWheelZoomRate": {
        "desc": "Set the zoom rate of a mouse wheel",
        "params": {
          "wheelZoomRate": {
            "type": [
              "number"
            ],
            "desc": "(default 1/450)"
          }
        }
      },
      "isEnabled": {
        "desc": "Returns a Boolean indicating whether the \"scroll to zoom\" interaction is enabled.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"scroll to zoom\" interaction is enabled."
        }
      },
      "enable": {
        "desc": "Enables the \"scroll to zoom\" interaction.",
        "params": {
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "Options object."
          }
        }
      },
      "disable": {
        "desc": "Disables the \"scroll to zoom\" interaction."
      }
    }
  },
  {
    "name": "DragPanHandler",
    "desc": "The DragPanHandler allows the user to pan the map by clicking and dragging the cursor.",
    "methods": {
      "isEnabled": {
        "desc": "Returns a Boolean indicating whether the \"drag to pan\" interaction is enabled.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"drag to pan\" interaction is enabled."
        }
      },
      "isActive": {
        "desc": "Returns a Boolean indicating whether the \"drag to pan\" interaction is active, i.e. currently being used.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"drag to pan\" interaction is active."
        }
      },
      "enable": {
        "desc": "Enables the \"drag to pan\" interaction.",
        "params": {
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "Options object"
          }
        }
      },
      "disable": {
        "desc": "Disables the \"drag to pan\" interaction."
      }
    }
  },
  {
    "name": "DragRotateHandler",
    "desc": "The DragRotateHandler allows the user to rotate the map by clicking and dragging the cursor while holding the right mouse button or ctrl key.",
    "methods": {
      "isEnabled": {
        "desc": "Returns a Boolean indicating whether the \"drag to rotate\" interaction is enabled.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"drag to rotate\" interaction is enabled."
        }
      },
      "isActive": {
        "desc": "Returns a Boolean indicating whether the \"drag to rotate\" interaction is active, i.e. currently being used.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"drag to rotate\" interaction is active."
        }
      },
      "enable": {
        "desc": "Enables the \"drag to rotate\" interaction."
      },
      "disable": {
        "desc": "Disables the \"drag to rotate\" interaction."
      }
    }
  },
  {
    "name": "KeyboardHandler",
    "desc": "The KeyboardHandler allows the user to zoom, rotate, and pan the map using the following keyboard shortcuts: = / +: Increase the zoom level by 1. Shift-= / Shift-+: Increase the zoom level by 2. -: Decrease the zoom level by 1. Shift--: Decrease the zoom level by 2. Arrow keys: Pan by 100 pixels. Shift+⇢: Increase the rotation by 15 degrees. Shift+⇠: Decrease the rotation by 15 degrees. Shift+⇡: Increase the pitch by 10 degrees. Shift+⇣: Decrease the pitch by 10 degrees.",
    "methods": {
      "isEnabled": {
        "desc": "Returns a Boolean indicating whether keyboard interaction is enabled.",
        "returns": {
          "type": "boolean",
          "desc": ": true if keyboard interaction is enabled."
        }
      },
      "enable": {
        "desc": "Enables keyboard interaction."
      },
      "disable": {
        "desc": "Disables keyboard interaction."
      }
    }
  },
  {
    "name": "DoubleClickZoomHandler",
    "desc": "The DoubleClickZoomHandler allows the user to zoom the map at a point by double clicking or double tapping.",
    "methods": {
      "isEnabled": {
        "desc": "Returns a Boolean indicating whether the \"double click to zoom\" interaction is enabled.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"double click to zoom\" interaction is enabled."
        }
      },
      "isActive": {
        "desc": "Returns a Boolean indicating whether the \"double click to zoom\" interaction is active, i.e. currently being used.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"double click to zoom\" interaction is active."
        }
      },
      "enable": {
        "desc": "Enables the \"double click to zoom\" interaction."
      },
      "disable": {
        "desc": "Disables the \"double click to zoom\" interaction."
      }
    }
  },
  {
    "name": "TouchZoomRotateHandler",
    "desc": "The TouchZoomRotateHandler allows the user to zoom and rotate the map by pinching on a touchscreen.",
    "methods": {
      "isEnabled": {
        "desc": "Returns a Boolean indicating whether the \"pinch to rotate and zoom\" interaction is enabled.",
        "returns": {
          "type": "boolean",
          "desc": ": true if the \"pinch to rotate and zoom\" interaction is enabled."
        }
      },
      "enable": {
        "desc": "Enables the \"pinch to rotate and zoom\" interaction.",
        "params": {
          "options": {
            "type": [
              "Object?"
            ],
            "desc": "Options object."
          }
        }
      },
      "disable": {
        "desc": "Disables the \"pinch to rotate and zoom\" interaction."
      },
      "disableRotation": {
        "desc": "Disables the \"pinch to rotate\" interaction, leaving the \"pinch to zoom\"\ninteraction enabled."
      },
      "enableRotation": {
        "desc": "Enables the \"pinch to rotate\" interaction."
      }
    }
  },
  {
    "name": "GeoJSONSource",
    "desc": "A source containing GeoJSON. (See the Style Specification for detailed documentation of options.)",
    "methods": {
      "setData": {
        "desc": "Sets the GeoJSON data and re-renders the map.",
        "params": {
          "data": {
            "type": [
              "Object",
              "string"
            ],
            "desc": "A GeoJSON data object or a URL to one. The latter is preferable in the case of large GeoJSON files."
          }
        },
        "returns": {
          "type": "GeoJSONSource",
          "desc": ": this"
        }
      },
      "getClusterExpansionZoom": {
        "desc": "For clustered sources, fetches the zoom at which the given cluster expands.",
        "params": {
          "clusterId": {
            "type": [
              "number"
            ],
            "desc": "The value of the cluster's cluster_id property."
          },
          "callback": {
            "type": [
              "Callback<number>"
            ],
            "desc": "A callback to be called when the zoom value is retrieved ( (error, zoom) => { ... } )."
          }
        },
        "returns": {
          "type": "GeoJSONSource",
          "desc": ": this"
        }
      },
      "getClusterChildren": {
        "desc": "For clustered sources, fetches the children of the given cluster on the next zoom level (as an array of GeoJSON features).",
        "params": {
          "clusterId": {
            "type": [
              "number"
            ],
            "desc": "The value of the cluster's cluster_id property."
          },
          "callback": {
            "type": [
              "Callback<Array<GeoJSONFeature>>"
            ],
            "desc": "A callback to be called when the features are retrieved ( (error, features) => { ... } )."
          }
        },
        "returns": {
          "type": "GeoJSONSource",
          "desc": ": this"
        }
      },
      "getClusterLeaves": {
        "desc": "For clustered sources, fetches the original points that belong to the cluster (as an array of GeoJSON features).",
        "params": {
          "clusterId": {
            "type": [
              "number"
            ],
            "desc": "The value of the cluster's cluster_id property."
          },
          "limit": {
            "type": [
              "number"
            ],
            "desc": "The maximum number of features to return."
          },
          "offset": {
            "type": [
              "number"
            ],
            "desc": "The number of features to skip (e.g. for pagination)."
          },
          "callback": {
            "type": [
              "Callback<Array<GeoJSONFeature>>"
            ],
            "desc": "A callback to be called when the features are retrieved ( (error, features) => { ... } )."
          }
        },
        "returns": {
          "type": "GeoJSONSource",
          "desc": ": this"
        }
      }
    }
  },
  {
    "name": "VideoSource",
    "desc": "A data source containing video. (See the Style Specification for detailed documentation of options.)",
    "methods": {
      "pause": {
        "desc": "Pauses the video."
      },
      "play": {
        "desc": "Plays the video."
      },
      "getVideo": {
        "desc": "Returns the HTML video element.",
        "returns": {
          "type": "HTMLVideoElement",
          "desc": ": The HTML video element."
        }
      },
      "setCoordinates": {
        "desc": "Sets the video's coordinates and re-renders the map.",
        "returns": {
          "type": "VideoSource",
          "desc": ": this"
        }
      }
    }
  },
  {
    "name": "ImageSource",
    "desc": "A data source containing an image. (See the Style Specification for detailed documentation of options.)",
    "methods": {
      "updateImage": {
        "desc": "Updates the image URL and, optionally, the coordinates. To avoid having the image flash after changing,\nset the raster-fade-duration paint property on the raster layer to 0.",
        "params": {
          "options": {
            "type": [
              "Object"
            ],
            "desc": "Options object."
          }
        },
        "returns": {
          "type": "ImageSource",
          "desc": ": this"
        }
      },
      "setCoordinates": {
        "desc": "Sets the image's coordinates and re-renders the map.",
        "params": {
          "coordinates": {
            "type": [
              "Array<Array<number>>"
            ],
            "desc": "Four geographical coordinates, represented as arrays of longitude and latitude numbers, which define the corners of the image. The coordinates start at the top left corner of the image and proceed in clockwise order. They do not have to represent a rectangle."
          }
        },
        "returns": {
          "type": "ImageSource",
          "desc": ": this"
        }
      }
    }
  },
  {
    "name": "CanvasSource",
    "desc": "A data source containing the contents of an HTML canvas. See CanvasSourceOptions for detailed documentation of options.",
    "methods": {
      "pause": {
        "desc": "Disables animation. The map will display a static copy of the canvas image."
      },
      "play": {
        "desc": "Enables animation. The image will be copied from the canvas to the map on each frame."
      },
      "getCanvas": {
        "desc": "Returns the HTML canvas element.",
        "returns": {
          "type": "HTMLCanvasElement",
          "desc": ": The HTML canvas element."
        }
      },
      "setCoordinates": {
        "desc": "Sets the canvas's coordinates and re-renders the map.",
        "params": {
          "coordinates": {
            "type": [
              "Array<Array<number>>"
            ],
            "desc": "Four geographical coordinates, represented as arrays of longitude and latitude numbers, which define the corners of the canvas. The coordinates start at the top left corner of the canvas and proceed in clockwise order. They do not have to represent a rectangle."
          }
        },
        "returns": {
          "type": "CanvasSource",
          "desc": ": this"
        }
      }
    }
  },
  {
    "name": "CanvasSourceOptions",
    "desc": "Options to add a canvas source type to the map."
  },
  {
    "name": "Evented",
    "desc": "Methods mixed in to other classes for event capabilities.",
    "methods": {
      "on": {
        "desc": "Adds a listener to a specified event type.",
        "params": {
          "type": {
            "type": [
              "string"
            ],
            "desc": "The event type to add a listen for."
          },
          "listener": {
            "type": [
              "Function"
            ],
            "desc": "The function to be called when the event is fired. The listener function is called with the data object passed to fire , extended with target and type properties."
          }
        },
        "returns": {
          "type": "Object",
          "desc": ": this"
        }
      },
      "off": {
        "desc": "Removes a previously registered event listener.",
        "params": {
          "type": {
            "type": [
              "string"
            ],
            "desc": "The event type to remove listeners for."
          },
          "listener": {
            "type": [
              "Function"
            ],
            "desc": "The listener function to remove."
          }
        },
        "returns": {
          "type": "Object",
          "desc": ": this"
        }
      },
      "once": {
        "desc": "Adds a listener that will be called only once to a specified event type.\nThe listener will be called first time the event fires after the listener is registered.",
        "params": {
          "type": {
            "type": [
              "string"
            ],
            "desc": "The event type to listen for."
          },
          "listener": {
            "type": [
              "Function"
            ],
            "desc": "The function to be called when the event is fired the first time."
          }
        },
        "returns": {
          "type": "Object",
          "desc": ": this"
        }
      }
    }
  },
  {
    "name": "MapMouseEvent",
    "desc": "MapMouseEvent is the event type for mouse-related map events.",
    "methods": {
      "type": {
        "desc": "The event type."
      },
      "originalEvent": {
        "desc": "The DOM event which caused the map event."
      },
      "point": {
        "desc": "The pixel coordinates of the mouse cursor, relative to the map and measured from the top left corner."
      },
      "lngLat": {
        "desc": "The geographic location on the map of the mouse cursor."
      },
      "preventDefault": {
        "desc": "Prevents subsequent default processing of the event by the map.\nCalling this method will prevent the following default map behaviors:\n\nOn mousedown events, the behavior of DragPanHandler\nOn mousedown events, the behavior of DragRotateHandler\nOn mousedown events, the behavior of BoxZoomHandler\nOn dblclick events, the behavior of DoubleClickZoomHandler"
      }
    }
  },
  {
    "name": "MapTouchEvent",
    "desc": "MapTouchEvent is the event type for touch-related map events.",
    "methods": {
      "type": {
        "desc": "The event type."
      },
      "target": {
        "desc": "The Map object that fired the event."
      },
      "originalEvent": {
        "desc": "The DOM event which caused the map event."
      },
      "lngLat": {
        "desc": "The geographic location on the map of the center of the touch event points."
      },
      "point": {
        "desc": "The pixel coordinates of the center of the touch event points, relative to the map and measured from the top left\ncorner."
      },
      "points": {
        "desc": "The array of pixel coordinates corresponding to a\ntouch event's touches property."
      },
      "lngLats": {
        "desc": "The geographical locations on the map corresponding to a\ntouch event's touches property."
      },
      "preventDefault": {
        "desc": "Prevents subsequent default processing of the event by the map.\nCalling this method will prevent the following default map behaviors:\n\nOn touchstart events, the behavior of DragPanHandler\nOn touchstart events, the behavior of TouchZoomRotateHandler"
      }
    }
  },
  {
    "name": "MapBoxZoomEvent",
    "desc": "A MapBoxZoomEvent is the event type for boxzoom-related map events. originalEvent can be a Map.event:click when the zoom is triggered by a UI event."
  },
  {
    "name": "MapDataEvent",
    "desc": "A MapDataEvent object is emitted with the Map.event:data and Map.event:dataloading events. Possible values for dataTypes are: 'source': The non-tile data associated with any source 'style': The style used by the map"
  },
  {
    "name": "EdgeInsets",
    "desc": "An EdgeInset object represents screen space padding applied to the edges of the viewport. This shifts the apprent center or the vanishing point of the map. This is useful for adding floating UI elements on top of the map and having the vanishing point shift as UI elements resize."
  },
  {
    "name": "MapWheelEvent",
    "desc": "MapWheelEvent is the event type for the wheel map event.",
    "methods": {
      "type": {
        "desc": "The event type."
      },
      "target": {
        "desc": "The Map object that fired the event."
      },
      "originalEvent": {
        "desc": "The DOM event which caused the map event."
      },
      "preventDefault": {
        "desc": "Prevents subsequent default processing of the event by the map.\nCalling this method will prevent the the behavior of ScrollZoomHandler."
      }
    }
  },
  {
    "name": "Debug",
    "desc": "This is a private namespace for utility functions that will get automatically stripped out in production builds."
  }
]
