[
  {
    "opcode": "37",
    "name": "AAA",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "ASCII adjust AL after addition."
  },
  {
    "opcode": "D5 0A",
    "name": "AAD",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "ASCII adjust AX before division."
  },
  {
    "opcode": "D5 ib",
    "name": "AAD",
    "operands": [
      {
        "type": "imm8"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Adjust AX before division to number base imm8."
  },
  {
    "opcode": "D4 0A",
    "name": "AAM",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "ASCII adjust AX after multiply."
  },
  {
    "opcode": "D4 ib",
    "name": "AAM",
    "operands": [
      {
        "type": "imm8"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Adjust AX after multiply to number base imm8."
  },
  {
    "opcode": "3F",
    "name": "AAS",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "ASCII adjust AL after subtraction."
  },
  {
    "opcode": "14 ib",
    "name": "ADC",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry imm8 to AL."
  },
  {
    "opcode": "15 iw",
    "name": "ADC",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry imm16 to AX."
  },
  {
    "opcode": "15 id",
    "name": "ADC",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry imm32 to EAX."
  },
  {
    "opcode": "REX.W + 15 id",
    "name": "ADC",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add with carry imm32 sign extended to 64-bits to RAX."
  },
  {
    "opcode": "80 /2 ib",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry imm8 to r/m8."
  },
  {
    "opcode": "REX + 80 /2 ib",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add with carry imm8 to r/m8."
  },
  {
    "opcode": "81 /2 iw",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry imm16 to r/m16."
  },
  {
    "opcode": "81 /2 id",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with CF imm32 to r/m32."
  },
  {
    "opcode": "REX.W + 81 /2 id",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add with CF imm32 sign extended to 64-bits to r/m64."
  },
  {
    "opcode": "83 /2 ib",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with CF sign-extended imm8 to r/m16."
  },
  {
    "opcode": "83 /2 ib",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with CF sign-extended imm8 into r/m32."
  },
  {
    "opcode": "REX.W + 83 /2 ib",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add with CF sign-extended imm8 into r/m64."
  },
  {
    "opcode": "10 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry byte register to r/m8."
  },
  {
    "opcode": "REX + 10 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add with carry byte register to r/m64."
  },
  {
    "opcode": "11 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry r16 to r/m16."
  },
  {
    "opcode": "11 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with CF r32 to r/m32."
  },
  {
    "opcode": "REX.W + 11 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add with CF r64 to r/m64."
  },
  {
    "opcode": "12 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry r/m8 to byte register."
  },
  {
    "opcode": "REX + 12 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add with carry r/m64 to byte register."
  },
  {
    "opcode": "13 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with carry r/m16 to r16."
  },
  {
    "opcode": "13 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add with CF r/m32 to r32."
  },
  {
    "opcode": "REX.W + 13 /r",
    "name": "ADC",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add with CF r/m64 to r64."
  },
  {
    "opcode": "66 0F 38 F6 /r",
    "name": "ADCX",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "ADX",
    "desc": "Unsigned addition of r32 with CF, r/m32 to r32, writes CF."
  },
  {
    "opcode": "66 REX.w 0F 38 F6 /r",
    "name": "ADCX",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "ADX",
    "desc": "Unsigned addition of r64 with CF, r/m64 to r64, writes CF."
  },
  {
    "opcode": "04 ib",
    "name": "ADD",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add imm8 to AL."
  },
  {
    "opcode": "05 iw",
    "name": "ADD",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add imm16 to AX."
  },
  {
    "opcode": "05 id",
    "name": "ADD",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add imm32 to EAX."
  },
  {
    "opcode": "REX.W + 05 id",
    "name": "ADD",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add imm32 sign-extended to 64-bits to RAX."
  },
  {
    "opcode": "80 /0 ib",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add imm8 to r/m8."
  },
  {
    "opcode": "REX + 80 /0 ib",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add sign-extended imm8 to r/m8."
  },
  {
    "opcode": "81 /0 iw",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add imm16 to r/m16."
  },
  {
    "opcode": "81 /0 id",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add imm32 to r/m32."
  },
  {
    "opcode": "REX.W + 81 /0 id",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add imm32 sign-extended to 64-bits to r/m64."
  },
  {
    "opcode": "83 /0 ib",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add sign-extended imm8 to r/m16."
  },
  {
    "opcode": "83 /0 ib",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add sign-extended imm8 to r/m32."
  },
  {
    "opcode": "REX.W + 83 /0 ib",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add sign-extended imm8 to r/m64."
  },
  {
    "opcode": "00 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add r8 to r/m8."
  },
  {
    "opcode": "REX + 00 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add r8 to r/m8."
  },
  {
    "opcode": "01 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add r16 to r/m16."
  },
  {
    "opcode": "01 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add r32 to r/m32."
  },
  {
    "opcode": "REX.W + 01 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add r64 to r/m64."
  },
  {
    "opcode": "02 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add r/m8 to r8."
  },
  {
    "opcode": "REX + 02 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add r/m8 to r8."
  },
  {
    "opcode": "03 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add r/m16 to r16."
  },
  {
    "opcode": "03 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add r/m32 to r32."
  },
  {
    "opcode": "REX.W + 03 /r",
    "name": "ADD",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Add r/m64 to r64."
  },
  {
    "opcode": "66 0F 58 /r",
    "name": "ADDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Add packed double-precision floating-point values from xmm2/mem to xmm1 and store result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 58 /r V",
    "name": "ADDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add packed double-precision floating-point values from xmm3/mem to xmm2 and store result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 58 /r V",
    "name": "ADDPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add packed double-precision floating-point values from ymm3/mem to ymm2 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 58 /r V",
    "name": "ADDPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Add packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 58 /r V",
    "name": "ADDPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Add packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 58 /r V",
    "name": "ADDPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Add packed double-precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1."
  },
  {
    "opcode": "NP 0F 58 /r",
    "name": "ADDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Add packed single-precision floating-point values from xmm2/m128 to xmm1 and store result in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 58 /r V",
    "name": "ADDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add packed single-precision floating-point values from xmm3/m128 to xmm2 and store result in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 58 /r V",
    "name": "ADDPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add packed single-precision floating-point values from ymm3/m256 to ymm2 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 58 /r V",
    "name": "ADDPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Add packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 58 /r V",
    "name": "ADDPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Add packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 58 /r V",
    "name": "ADDPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst {er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Add packed single-precision floating-point values from zmm3/m512/m32bcst to zmm2 and store result in zmm1 with writemask k1."
  },
  {
    "opcode": "F2 0F 58 /r",
    "name": "ADDSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Add the low double-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 58 /r V",
    "name": "ADDSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 58 /r V",
    "name": "ADDSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Add the low double-precision floating-point value from xmm3/m64 to xmm2 and store the result in xmm1 with writemask k1."
  },
  {
    "opcode": "F3 0F 58 /r",
    "name": "ADDSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Add the low single-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 58 /r V",
    "name": "ADDSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 58 /r V",
    "name": "ADDSS",
    "operands": [
      {
        "type": "xmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Add the low single-precision floating-point value from xmm3/m32 to xmm2 and store the result in xmm1with writemask k1."
  },
  {
    "opcode": "66 0F D0 /r",
    "name": "ADDSUBPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Add/subtract double-precision floating-point values from xmm2/m128 to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG D0 /r V",
    "name": "ADDSUBPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG D0 /r V",
    "name": "ADDSUBPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."
  },
  {
    "opcode": "F2 0F D0 /r",
    "name": "ADDSUBPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Add/subtract single-precision floating-point values from xmm2/m128 to xmm1."
  },
  {
    "opcode": "VEX.128.F2.0F.WIG D0 /r V",
    "name": "ADDSUBPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."
  },
  {
    "opcode": "VEX.256.F2.0F.WIG D0 /r V",
    "name": "ADDSUBPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."
  },
  {
    "opcode": "F3 0F 38 F6 /r",
    "name": "ADOX",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "ADX",
    "desc": "Unsigned addition of r32 with OF, r/m32 to r32, writes OF."
  },
  {
    "opcode": "F3 REX.w 0F 38 F6 /r",
    "name": "ADOX",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "ADX",
    "desc": "Unsigned addition of r64 with OF, r/m64 to r64, writes OF."
  },
  {
    "opcode": "66 0F 38 DE /r",
    "name": "AESDEC",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AES",
    "desc": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG DE /r V",
    "name": "AESDEC",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "Both AES and AVX flags",
    "desc": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
  },
  {
    "opcode": "66 0F 38 DF /r",
    "name": "AESDECLAST",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AES",
    "desc": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG DF /r V",
    "name": "AESDECLAST",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "Both AES and AVX flags",
    "desc": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
  },
  {
    "opcode": "66 0F 38 DC /r",
    "name": "AESENC",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AES",
    "desc": "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG DC /r V",
    "name": "AESENC",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "Both AES and AVX flags",
    "desc": "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1."
  },
  {
    "opcode": "66 0F 38 DD /r",
    "name": "AESENCLAST",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AES",
    "desc": "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG DD /r V",
    "name": "AESENCLAST",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "Both AES and AVX flags",
    "desc": "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1."
  },
  {
    "opcode": "66 0F 38 DB /r",
    "name": "AESIMC",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AES",
    "desc": "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG DB /r V",
    "name": "AESIMC",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "Both AES and AVX flags",
    "desc": "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."
  },
  {
    "opcode": "66 0F 3A DF /r ib",
    "name": "AESKEYGENASSIST",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AES",
    "desc": "Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG DF /r ib V",
    "name": "AESKEYGENASSIST",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "Both AES and AVX flags",
    "desc": "Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."
  },
  {
    "opcode": "24 ib",
    "name": "AND",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AL AND imm8."
  },
  {
    "opcode": "25 iw",
    "name": "AND",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AX AND imm16."
  },
  {
    "opcode": "25 id",
    "name": "AND",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "EAX AND imm32."
  },
  {
    "opcode": "REX.W + 25 id",
    "name": "AND",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "RAX AND imm32 sign-extended to 64-bits."
  },
  {
    "opcode": "80 /4 ib",
    "name": "AND",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m8 AND imm8."
  },
  {
    "opcode": "REX + 80 /4 ib",
    "name": "AND",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m8 AND imm8."
  },
  {
    "opcode": "81 /4 iw",
    "name": "AND",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 AND imm16."
  },
  {
    "opcode": "81 /4 id",
    "name": "AND",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 AND imm32."
  },
  {
    "opcode": "REX.W + 81 /4 id",
    "name": "AND",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 AND imm32 sign extended to 64-bits."
  },
  {
    "opcode": "83 /4 ib",
    "name": "AND",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 AND imm8 (sign-extended)."
  },
  {
    "opcode": "83 /4 ib",
    "name": "AND",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 AND imm8 (sign-extended)."
  },
  {
    "opcode": "REX.W + 83 /4 ib",
    "name": "AND",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 AND imm8 (sign-extended)."
  },
  {
    "opcode": "20 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m8 AND r8."
  },
  {
    "opcode": "REX + 20 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 AND r8 (sign-extended)."
  },
  {
    "opcode": "21 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 AND r16."
  },
  {
    "opcode": "21 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 AND r32."
  },
  {
    "opcode": "REX.W + 21 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 AND r32."
  },
  {
    "opcode": "22 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r8 AND r/m8."
  },
  {
    "opcode": "REX + 22 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 AND r8 (sign-extended)."
  },
  {
    "opcode": "23 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r16 AND r/m16."
  },
  {
    "opcode": "23 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r32 AND r/m32."
  },
  {
    "opcode": "REX.W + 23 /r",
    "name": "AND",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r64 AND r/m64."
  },
  {
    "opcode": "VEX.LZ.0F38.W0 F2 /r",
    "name": "ANDN",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI1",
    "desc": "Bitwise AND of inverted r32b with r/m32, store result in r32a."
  },
  {
    "opcode": "VEX.LZ. 0F38.W1 F2 /r",
    "name": "ANDN",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "BMI1",
    "desc": "Bitwise AND of inverted r64b with r/m64, store result in r64a."
  },
  {
    "opcode": "66 0F 55 /r",
    "name": "ANDNPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.66.0F 55 /r V",
    "name": "ANDNPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.66.0F 55/r V",
    "name": "ANDNPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 55 /r V",
    "name": "ANDNPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 55 /r V",
    "name": "ANDNPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 55 /r V",
    "name": "ANDNPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Return the bitwise logical AND NOT of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
  },
  {
    "opcode": "NP 0F 55 /r",
    "name": "ANDNPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F 55 /r V",
    "name": "ANDNPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.0F 55 /r V",
    "name": "ANDNPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 55 /r V",
    "name": "ANDNPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 55 /r V",
    "name": "ANDNPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 55 /r V",
    "name": "ANDNPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
  },
  {
    "opcode": "66 0F 54 /r",
    "name": "ANDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.66.0F 54 /r V",
    "name": "ANDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.66.0F 54 /r V",
    "name": "ANDPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 54 /r V",
    "name": "ANDPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 54 /r V",
    "name": "ANDPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 54 /r V",
    "name": "ANDPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Return the bitwise logical AND of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
  },
  {
    "opcode": "NP 0F 54 /r",
    "name": "ANDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F 54 /r V",
    "name": "ANDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.0F 54 /r V",
    "name": "ANDPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 54 /r V",
    "name": "ANDPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 54 /r V",
    "name": "ANDPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 54 /r V",
    "name": "ANDPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Return the bitwise logical AND of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
  },
  {
    "opcode": "63 /r",
    "name": "ARPL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "n. e.",
    "compatibility": "valid",
    "desc": "Adjust RPL of r/m16 to not less than RPL of r16."
  },
  {
    "opcode": "VEX.LZ.0F38.W0 F7 /r",
    "name": "BEXTR",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI1",
    "desc": "Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a."
  },
  {
    "opcode": "VEX.LZ.0F38.W1 F7 /r",
    "name": "BEXTR",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI1",
    "desc": "Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a"
  },
  {
    "opcode": "66 0F 3A 0D /r ib",
    "name": "BLENDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 0D /r ib V",
    "name": "BLENDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8[3:0]"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Select packed double-precision floating-point Values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.WIG 0D /r ib V",
    "name": "BLENDPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8[3:0]"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Select packed double-precision floating-point Values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1."
  },
  {
    "opcode": "66 0F 3A 0C /r ib",
    "name": "BLENDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 0C /r ib V",
    "name": "BLENDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.WIG 0C /r ib V",
    "name": "BLENDPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1."
  },
  {
    "opcode": "66 0F 38 15 /r",
    "name": "BLENDVPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "<XMM0>",
        "encoding": "implicit XMM0"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 4B /r /is4 V",
    "name": "BLENDVPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "xmm4",
        "encoding": "imm8[7:4]"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally copy double-precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 4B /r /is4 V",
    "name": "BLENDVPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "ymm4",
        "encoding": "imm8[7:4]"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally copy double-precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4."
  },
  {
    "opcode": "66 0F 38 14 /r",
    "name": "BLENDVPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "<XMM0>",
        "encoding": "implicit XMM0"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 4A /r /is4 V",
    "name": "BLENDVPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "xmm4",
        "encoding": "imm8[7:4]"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally copy single-precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 4A /r /is4 V",
    "name": "BLENDVPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "ymm4",
        "encoding": "imm8[7:4]"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally copy single-precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4."
  },
  {
    "opcode": "VEX.LZ.0F38.W0 F3 /3",
    "name": "BLSI",
    "operands": [
      {
        "type": "r32",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI1",
    "desc": "Extract lowest set bit from r/m32 and set that bit in r32."
  },
  {
    "opcode": "VEX.LZ.0F38.W1 F3 /3",
    "name": "BLSI",
    "operands": [
      {
        "type": "r64",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI1",
    "desc": "Extract lowest set bit from r/m64, and set that bit in r64."
  },
  {
    "opcode": "VEX.LZ.0F38.W0 F3 /2",
    "name": "BLSMSK",
    "operands": [
      {
        "type": "r32",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI1",
    "desc": "Set all lower bits in r32 to 1 starting from bit 0 to lowest set bit in r/m32."
  },
  {
    "opcode": "VEX.LZ.0F38.W1 F3 /2",
    "name": "BLSMSK",
    "operands": [
      {
        "type": "r64",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI1",
    "desc": "Set all lower bits in r64 to 1 starting from bit 0 to lowest set bit in r/m64."
  },
  {
    "opcode": "VEX.LZ.0F38.W0 F3 /1",
    "name": "BLSR",
    "operands": [
      {
        "type": "r32",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI1",
    "desc": "Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32."
  },
  {
    "opcode": "VEX.LZ.0F38.W1 F3 /1",
    "name": "BLSR",
    "operands": [
      {
        "type": "r64",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI1",
    "desc": "Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64."
  },
  {
    "opcode": "F3 0F 1A /r",
    "name": "BNDCL",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "ne",
    "support32": "v",
    "flag": "MPX",
    "desc": "Generate a #BR if the address in r/m32 is lower than the lower bound in bnd.LB."
  },
  {
    "opcode": "F3 0F 1A /r",
    "name": "BNDCL",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "MPX",
    "desc": "Generate a #BR if the address in r/m64 is lower than the lower bound in bnd.LB."
  },
  {
    "opcode": "F2 0F 1A /r",
    "name": "BNDCU",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "ne",
    "support32": "v",
    "flag": "MPX",
    "desc": "Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form)."
  },
  {
    "opcode": "F2 0F 1A /r",
    "name": "BNDCU",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "MPX",
    "desc": "Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form)."
  },
  {
    "opcode": "F2 0F 1B /r",
    "name": "BNDCN",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "ne",
    "support32": "v",
    "flag": "MPX",
    "desc": "Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form)."
  },
  {
    "opcode": "F2 0F 1B /r",
    "name": "BNDCN",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "MPX",
    "desc": "Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form)."
  },
  {
    "opcode": "NP 0F 1A /r",
    "name": "BNDLDX",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mib",
        "encoding": "SIB.base (r): Address of pointer SIB.index(r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MPX",
    "desc": "Load the bounds stored in a bound table entry (BTE) into bnd with address translation using the base of mib and conditional on the index of mib matching the pointer value in the BTE."
  },
  {
    "opcode": "F3 0F 1B /r",
    "name": "BNDMK",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "ne",
    "support32": "v",
    "flag": "MPX",
    "desc": "Make lower and upper bounds from m32 and store them in bnd."
  },
  {
    "opcode": "F3 0F 1B /r",
    "name": "BNDMK",
    "operands": [
      {
        "type": "bnd",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "MPX",
    "desc": "Make lower and upper bounds from m64 and store them in bnd."
  },
  {
    "opcode": "66 0F 1A /r",
    "name": "BNDMOV",
    "operands": [
      {
        "type": "bnd1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "bnd2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "ne",
    "support32": "v",
    "flag": "MPX",
    "desc": "Move lower and upper bound from bnd2/m64 to bound register bnd1."
  },
  {
    "opcode": "66 0F 1A /r",
    "name": "BNDMOV",
    "operands": [
      {
        "type": "bnd1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "bnd2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "MPX",
    "desc": "Move lower and upper bound from bnd2/m128 to bound register bnd1."
  },
  {
    "opcode": "66 0F 1B /r",
    "name": "BNDMOV",
    "operands": [
      {
        "type": "bnd1/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "bnd2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "ne",
    "support32": "v",
    "flag": "MPX",
    "desc": "Move lower and upper bound from bnd2 to bnd1/m64."
  },
  {
    "opcode": "66 0F 1B /r",
    "name": "BNDMOV",
    "operands": [
      {
        "type": "bnd1/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "bnd2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "MPX",
    "desc": "Move lower and upper bound from bnd2 to bound register bnd1/m128."
  },
  {
    "opcode": "NP 0F 1B /r",
    "name": "BNDSTX",
    "operands": [
      {
        "type": "mib",
        "encoding": "SIB.base (r): Address of pointer SIB.index(r)"
      },
      {
        "type": "bnd",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MPX",
    "desc": "Store the bounds in bnd and the pointer value in the index register of mib to a bound table entry (BTE) with address translation using the base of mib."
  },
  {
    "opcode": "62 /r",
    "name": "BOUND",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "m16&16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Check if r16 (array index) is within bounds specified by m16&16."
  },
  {
    "opcode": "62 /r",
    "name": "BOUND",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "m32&32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Check if r32 (array index) is within bounds specified by m32&32."
  },
  {
    "opcode": "0F BC /r",
    "name": "BSF",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Bit scan forward on r/m16."
  },
  {
    "opcode": "0F BC /r",
    "name": "BSF",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Bit scan forward on r/m32."
  },
  {
    "opcode": "REX.W + 0F BC /r",
    "name": "BSF",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Bit scan forward on r/m64."
  },
  {
    "opcode": "0F BD /r",
    "name": "BSR",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Bit scan reverse on r/m16."
  },
  {
    "opcode": "0F BD /r",
    "name": "BSR",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Bit scan reverse on r/m32."
  },
  {
    "opcode": "REX.W + 0F BD /r",
    "name": "BSR",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Bit scan reverse on r/m64."
  },
  {
    "opcode": "0F C8+rd",
    "name": "BSWAP",
    "operands": [
      {
        "type": "r32",
        "encoding": "opcode + rd (r, w)"
      }
    ],
    "support64": "valid*",
    "compatibility": "valid",
    "desc": "Reverses the byte order of a 32-bit register."
  },
  {
    "opcode": "REX.W + 0F C8+rd",
    "name": "BSWAP",
    "operands": [
      {
        "type": "r64",
        "encoding": "opcode + rd (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Reverses the byte order of a 64-bit register."
  },
  {
    "opcode": "0F A3 /r",
    "name": "BT",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag."
  },
  {
    "opcode": "0F A3 /r",
    "name": "BT",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag."
  },
  {
    "opcode": "REX.W + 0F A3 /r",
    "name": "BT",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store selected bit in CF flag."
  },
  {
    "opcode": "0F BA /4 ib",
    "name": "BT",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag."
  },
  {
    "opcode": "0F BA /4 ib",
    "name": "BT",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag."
  },
  {
    "opcode": "REX.W + 0F BA /4 ib",
    "name": "BT",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store selected bit in CF flag."
  },
  {
    "opcode": "0F BB /r",
    "name": "BTC",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and complement."
  },
  {
    "opcode": "0F BB /r",
    "name": "BTC",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and complement."
  },
  {
    "opcode": "REX.W + 0F BB /r",
    "name": "BTC",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store selected bit in CF flag and complement."
  },
  {
    "opcode": "0F BA /7 ib",
    "name": "BTC",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and complement."
  },
  {
    "opcode": "0F BA /7 ib",
    "name": "BTC",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and complement."
  },
  {
    "opcode": "REX.W + 0F BA /7 ib",
    "name": "BTC",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store selected bit in CF flag and complement."
  },
  {
    "opcode": "0F B3 /r",
    "name": "BTR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and clear."
  },
  {
    "opcode": "0F B3 /r",
    "name": "BTR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and clear."
  },
  {
    "opcode": "REX.W + 0F B3 /r",
    "name": "BTR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store selected bit in CF flag and clear."
  },
  {
    "opcode": "0F BA /6 ib",
    "name": "BTR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and clear."
  },
  {
    "opcode": "0F BA /6 ib",
    "name": "BTR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and clear."
  },
  {
    "opcode": "REX.W + 0F BA /6 ib",
    "name": "BTR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store selected bit in CF flag and clear."
  },
  {
    "opcode": "0F AB /r",
    "name": "BTS",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and set."
  },
  {
    "opcode": "0F AB /r",
    "name": "BTS",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and set."
  },
  {
    "opcode": "REX.W + 0F AB /r",
    "name": "BTS",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store selected bit in CF flag and set."
  },
  {
    "opcode": "0F BA /5 ib",
    "name": "BTS",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and set."
  },
  {
    "opcode": "0F BA /5 ib",
    "name": "BTS",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store selected bit in CF flag and set."
  },
  {
    "opcode": "REX.W + 0F BA /5 ib",
    "name": "BTS",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store selected bit in CF flag and set."
  },
  {
    "opcode": "VEX.LZ.0F38.W0 F5 /r",
    "name": "BZHI",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI2",
    "desc": "Zero bits in r/m32 starting with the position in r32b, write result to r32a."
  },
  {
    "opcode": "VEX.LZ.0F38.W1 F5 /r",
    "name": "BZHI",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI2",
    "desc": "Zero bits in r/m64 starting with the position in r64b, write result to r64a."
  },
  {
    "opcode": "E8 cw",
    "name": "CALL",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Call near, relative, displacement relative to next instruction."
  },
  {
    "opcode": "E8 cd",
    "name": "CALL",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode."
  },
  {
    "opcode": "FF /2",
    "name": "CALL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Call near, absolute indirect, address given in r/m16."
  },
  {
    "opcode": "FF /2",
    "name": "CALL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Call near, absolute indirect, address given in r/m32."
  },
  {
    "opcode": "FF /2",
    "name": "CALL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Call near, absolute indirect, address given in r/m64."
  },
  {
    "opcode": "9A cd",
    "name": "CALL",
    "operands": [
      {
        "type": "ptr16:16",
        "encoding": "Offset"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Call far, absolute, address given in operand."
  },
  {
    "opcode": "9A cp",
    "name": "CALL",
    "operands": [
      {
        "type": "ptr16:32",
        "encoding": "Offset"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Call far, absolute, address given in operand."
  },
  {
    "opcode": "FF /3",
    "name": "CALL",
    "operands": [
      {
        "type": "m16:16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16-bit offset from far pointer referenced in the instruction."
  },
  {
    "opcode": "FF /3",
    "name": "CALL",
    "operands": [
      {
        "type": "m16:32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction."
  },
  {
    "opcode": "REX.W FF /3",
    "name": "CALL",
    "operands": [
      {
        "type": "m16:64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction."
  },
  {
    "opcode": "98",
    "name": "CBW",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AX  sign-extend of AL."
  },
  {
    "opcode": "98",
    "name": "CWDE",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "EAX  sign-extend of AX."
  },
  {
    "opcode": "REX.W + 98",
    "name": "CDQE",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "RAX  sign-extend of EAX."
  },
  {
    "opcode": "NP 0F 01 CA",
    "name": "CLAC",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "SMAP",
    "desc": "Clear the AC flag in the EFLAGS register."
  },
  {
    "opcode": "F8",
    "name": "CLC",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Clear CF flag."
  },
  {
    "opcode": "FC",
    "name": "CLD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Clear DF flag."
  },
  {
    "opcode": "NP 0F 1C /0",
    "name": "CLDEMOTE",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "CLDEMOTE",
    "desc": "Hint to hardware to move the cache line containing m8 to a more distant level of the cache without writing back to memory."
  },
  {
    "opcode": "NP 0F AE /7",
    "name": "CLFLUSH",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Flushes cache line containing m8."
  },
  {
    "opcode": "NFx 66 0F AE /7",
    "name": "CLFLUSHOPT",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Flushes cache line containing m8."
  },
  {
    "opcode": "FA",
    "name": "CLI",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Clear interrupt flag; interrupts disabled when interrupt flag cleared."
  },
  {
    "opcode": "0F 06",
    "name": "CLTS",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Clears TS flag in CR0."
  },
  {
    "opcode": "66 0F AE /6",
    "name": "CLWB",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "CLWB",
    "desc": "Writes back modified cache line containing m8, and may retain the line in cache hierarchy in non-modified state."
  },
  {
    "opcode": "F5",
    "name": "CMC",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Complement CF flag."
  },
  {
    "opcode": "0F 47 /r",
    "name": "CMOVA",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if above (CF=0 and ZF=0)."
  },
  {
    "opcode": "0F 47 /r",
    "name": "CMOVA",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if above (CF=0 and ZF=0)."
  },
  {
    "opcode": "REX.W + 0F 47 /r",
    "name": "CMOVA",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if above (CF=0 and ZF=0)."
  },
  {
    "opcode": "0F 43 /r",
    "name": "CMOVAE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if above or equal (CF=0)."
  },
  {
    "opcode": "0F 43 /r",
    "name": "CMOVAE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if above or equal (CF=0)."
  },
  {
    "opcode": "REX.W + 0F 43 /r",
    "name": "CMOVAE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if above or equal (CF=0)."
  },
  {
    "opcode": "0F 42 /r",
    "name": "CMOVB",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if below (CF=1)."
  },
  {
    "opcode": "0F 42 /r",
    "name": "CMOVB",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if below (CF=1)."
  },
  {
    "opcode": "REX.W + 0F 42 /r",
    "name": "CMOVB",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if below (CF=1)."
  },
  {
    "opcode": "0F 46 /r",
    "name": "CMOVBE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if below or equal (CF=1 or ZF=1)."
  },
  {
    "opcode": "0F 46 /r",
    "name": "CMOVBE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if below or equal (CF=1 or ZF=1)."
  },
  {
    "opcode": "REX.W + 0F 46 /r",
    "name": "CMOVBE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if below or equal (CF=1 or ZF=1)."
  },
  {
    "opcode": "0F 42 /r",
    "name": "CMOVC",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if carry (CF=1)."
  },
  {
    "opcode": "0F 42 /r",
    "name": "CMOVC",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if carry (CF=1)."
  },
  {
    "opcode": "REX.W + 0F 42 /r",
    "name": "CMOVC",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if carry (CF=1)."
  },
  {
    "opcode": "0F 44 /r",
    "name": "CMOVE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if equal (ZF=1)."
  },
  {
    "opcode": "0F 44 /r",
    "name": "CMOVE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if equal (ZF=1)."
  },
  {
    "opcode": "REX.W + 0F 44 /r",
    "name": "CMOVE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if equal (ZF=1)."
  },
  {
    "opcode": "0F 4F /r",
    "name": "CMOVG",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if greater (ZF=0 and SF=OF)."
  },
  {
    "opcode": "0F 4F /r",
    "name": "CMOVG",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if greater (ZF=0 and SF=OF)."
  },
  {
    "opcode": "REX.W + 0F 4F /r",
    "name": "CMOVG",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v/n.e.",
    "compatibility": "na",
    "desc": "Move if greater (ZF=0 and SF=OF)."
  },
  {
    "opcode": "0F 4D /r",
    "name": "CMOVGE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if greater or equal (SF=OF)."
  },
  {
    "opcode": "0F 4D /r",
    "name": "CMOVGE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if greater or equal (SF=OF)."
  },
  {
    "opcode": "REX.W + 0F 4D /r",
    "name": "CMOVGE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if greater or equal (SF=OF)."
  },
  {
    "opcode": "0F 4C /r",
    "name": "CMOVL",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if less (SF= OF)."
  },
  {
    "opcode": "0F 4C /r",
    "name": "CMOVL",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if less (SF= OF)."
  },
  {
    "opcode": "REX.W + 0F 4C /r",
    "name": "CMOVL",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if less (SF= OF)."
  },
  {
    "opcode": "0F 4E /r",
    "name": "CMOVLE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if less or equal (ZF=1 or SF= OF)."
  },
  {
    "opcode": "0F 4E /r",
    "name": "CMOVLE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if less or equal (ZF=1 or SF= OF)."
  },
  {
    "opcode": "REX.W + 0F 4E /r",
    "name": "CMOVLE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if less or equal (ZF=1 or SF= OF)."
  },
  {
    "opcode": "0F 46 /r",
    "name": "CMOVNA",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not above (CF=1 or ZF=1)."
  },
  {
    "opcode": "0F 46 /r",
    "name": "CMOVNA",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not above (CF=1 or ZF=1)."
  },
  {
    "opcode": "REX.W + 0F 46 /r",
    "name": "CMOVNA",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not above (CF=1 or ZF=1)."
  },
  {
    "opcode": "0F 42 /r",
    "name": "CMOVNAE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not above or equal (CF=1)."
  },
  {
    "opcode": "0F 42 /r",
    "name": "CMOVNAE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not above or equal (CF=1)."
  },
  {
    "opcode": "REX.W + 0F 42 /r",
    "name": "CMOVNAE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not above or equal (CF=1)."
  },
  {
    "opcode": "0F 43 /r",
    "name": "CMOVNB",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not below (CF=0)."
  },
  {
    "opcode": "0F 43 /r",
    "name": "CMOVNB",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not below (CF=0)."
  },
  {
    "opcode": "REX.W + 0F 43 /r",
    "name": "CMOVNB",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not below (CF=0)."
  },
  {
    "opcode": "0F 47 /r",
    "name": "CMOVNBE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not below or equal (CF=0 and ZF=0)."
  },
  {
    "opcode": "0F 47 /r",
    "name": "CMOVNBE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not below or equal (CF=0 and ZF=0)."
  },
  {
    "opcode": "REX.W + 0F 47 /r",
    "name": "CMOVNBE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not below or equal (CF=0 and ZF=0)."
  },
  {
    "opcode": "0F 43 /r",
    "name": "CMOVNC",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not carry (CF=0)."
  },
  {
    "opcode": "0F 43 /r",
    "name": "CMOVNC",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not carry (CF=0)."
  },
  {
    "opcode": "REX.W + 0F 43 /r",
    "name": "CMOVNC",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not carry (CF=0)."
  },
  {
    "opcode": "0F 45 /r",
    "name": "CMOVNE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not equal (ZF=0)."
  },
  {
    "opcode": "0F 45 /r",
    "name": "CMOVNE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not equal (ZF=0)."
  },
  {
    "opcode": "REX.W + 0F 45 /r",
    "name": "CMOVNE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not equal (ZF=0)."
  },
  {
    "opcode": "0F 4E /r",
    "name": "CMOVNG",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not greater (ZF=1 or SF= OF)."
  },
  {
    "opcode": "0F 4E /r",
    "name": "CMOVNG",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not greater (ZF=1 or SF= OF)."
  },
  {
    "opcode": "REX.W + 0F 4E /r",
    "name": "CMOVNG",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not greater (ZF=1 or SF= OF)."
  },
  {
    "opcode": "0F 4C /r",
    "name": "CMOVNGE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not greater or equal (SF= OF)."
  },
  {
    "opcode": "0F 4C /r",
    "name": "CMOVNGE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not greater or equal (SF= OF)."
  },
  {
    "opcode": "REX.W + 0F 4C /r",
    "name": "CMOVNGE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not greater or equal (SF= OF)."
  },
  {
    "opcode": "0F 4D /r",
    "name": "CMOVNL",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not less (SF=OF)."
  },
  {
    "opcode": "0F 4D /r",
    "name": "CMOVNL",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not less (SF=OF)."
  },
  {
    "opcode": "REX.W + 0F 4D /r",
    "name": "CMOVNL",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not less (SF=OF)."
  },
  {
    "opcode": "0F 4F /r",
    "name": "CMOVNLE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not less or equal (ZF=0 and SF=OF)."
  },
  {
    "opcode": "0F 4F /r",
    "name": "CMOVNLE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not less or equal (ZF=0 and SF=OF)."
  },
  {
    "opcode": "REX.W + 0F 4F /r",
    "name": "CMOVNLE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not less or equal (ZF=0 and SF=OF)."
  },
  {
    "opcode": "0F 41 /r",
    "name": "CMOVNO",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not overflow (OF=0)."
  },
  {
    "opcode": "0F 41 /r",
    "name": "CMOVNO",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not overflow (OF=0)."
  },
  {
    "opcode": "REX.W + 0F 41 /r",
    "name": "CMOVNO",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not overflow (OF=0)."
  },
  {
    "opcode": "0F 4B /r",
    "name": "CMOVNP",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not parity (PF=0)."
  },
  {
    "opcode": "0F 4B /r",
    "name": "CMOVNP",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not parity (PF=0)."
  },
  {
    "opcode": "REX.W + 0F 4B /r",
    "name": "CMOVNP",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not parity (PF=0)."
  },
  {
    "opcode": "0F 49 /r",
    "name": "CMOVNS",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not sign (SF=0)."
  },
  {
    "opcode": "0F 49 /r",
    "name": "CMOVNS",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not sign (SF=0)."
  },
  {
    "opcode": "REX.W + 0F 49 /r",
    "name": "CMOVNS",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not sign (SF=0)."
  },
  {
    "opcode": "0F 45 /r",
    "name": "CMOVNZ",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not zero (ZF=0)."
  },
  {
    "opcode": "0F 45 /r",
    "name": "CMOVNZ",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not zero (ZF=0)."
  },
  {
    "opcode": "REX.W + 0F 45 /r",
    "name": "CMOVNZ",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if not zero (ZF=0)."
  },
  {
    "opcode": "0F 40 /r",
    "name": "CMOVO",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if overflow (OF=1)."
  },
  {
    "opcode": "0F 40 /r",
    "name": "CMOVO",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if overflow (OF=1)."
  },
  {
    "opcode": "REX.W + 0F 40 /r",
    "name": "CMOVO",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if overflow (OF=1)."
  },
  {
    "opcode": "0F 4A /r",
    "name": "CMOVP",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if parity (PF=1)."
  },
  {
    "opcode": "0F 4A /r",
    "name": "CMOVP",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if parity (PF=1)."
  },
  {
    "opcode": "REX.W + 0F 4A /r",
    "name": "CMOVP",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if parity (PF=1)."
  },
  {
    "opcode": "0F 4A /r",
    "name": "CMOVPE",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if parity even (PF=1)."
  },
  {
    "opcode": "0F 4A /r",
    "name": "CMOVPE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if parity even (PF=1)."
  },
  {
    "opcode": "REX.W + 0F 4A /r",
    "name": "CMOVPE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if parity even (PF=1)."
  },
  {
    "opcode": "0F 4B /r",
    "name": "CMOVPO",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if parity odd (PF=0)."
  },
  {
    "opcode": "0F 4B /r",
    "name": "CMOVPO",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if parity odd (PF=0)."
  },
  {
    "opcode": "REX.W + 0F 4B /r",
    "name": "CMOVPO",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if parity odd (PF=0)."
  },
  {
    "opcode": "0F 48 /r",
    "name": "CMOVS",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if sign (SF=1)."
  },
  {
    "opcode": "0F 48 /r",
    "name": "CMOVS",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if sign (SF=1)."
  },
  {
    "opcode": "REX.W + 0F 48 /r",
    "name": "CMOVS",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if sign (SF=1)."
  },
  {
    "opcode": "0F 44 /r",
    "name": "CMOVZ",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if zero (ZF=1)."
  },
  {
    "opcode": "0F 44 /r",
    "name": "CMOVZ",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if zero (ZF=1)."
  },
  {
    "opcode": "REX.W + 0F 44 /r",
    "name": "CMOVZ",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move if zero (ZF=1)."
  },
  {
    "opcode": "3C ib",
    "name": "CMP",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare imm8 with AL."
  },
  {
    "opcode": "3D iw",
    "name": "CMP",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX (r)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare imm16 with AX."
  },
  {
    "opcode": "3D id",
    "name": "CMP",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX (r)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare imm32 with EAX."
  },
  {
    "opcode": "REX.W + 3D id",
    "name": "CMP",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX (r)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare imm32 sign-extended to 64-bits with RAX."
  },
  {
    "opcode": "80 /7 ib",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare imm8 with r/m8."
  },
  {
    "opcode": "REX + 80 /7 ib",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare imm8 with r/m8."
  },
  {
    "opcode": "81 /7 iw",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare imm16 with r/m16."
  },
  {
    "opcode": "81 /7 id",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare imm32 with r/m32."
  },
  {
    "opcode": "REX.W + 81 /7 id",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare imm32 sign-extended to 64-bits with r/m64."
  },
  {
    "opcode": "83 /7 ib",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare imm8 with r/m16."
  },
  {
    "opcode": "83 /7 ib",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare imm8 with r/m32."
  },
  {
    "opcode": "REX.W + 83 /7 ib",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare imm8 with r/m64."
  },
  {
    "opcode": "38 /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare r8 with r/m8."
  },
  {
    "opcode": "REX + 38 /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare r8 with r/m8."
  },
  {
    "opcode": "39 /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare r16 with r/m16."
  },
  {
    "opcode": "39 /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare r32 with r/m32."
  },
  {
    "opcode": "REX.W + 39 /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare r64 with r/m64."
  },
  {
    "opcode": "3A /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare r/m8 with r8."
  },
  {
    "opcode": "REX + 3A /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare r/m8 with r8."
  },
  {
    "opcode": "3B /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare r/m16 with r16."
  },
  {
    "opcode": "3B /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare r/m32 with r32."
  },
  {
    "opcode": "REX.W + 3B /r",
    "name": "CMP",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare r/m64 with r64."
  },
  {
    "opcode": "66 0F C2 /r ib",
    "name": "CMPPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare packed double-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of imm8 as a comparison predicate."
  },
  {
    "opcode": "VEX.128.66.0F.WIG C2 /r ib V",
    "name": "CMPPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed double-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate."
  },
  {
    "opcode": "VEX.256.66.0F.WIG C2 /r ib V",
    "name": "CMPPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed double-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 C2 /r ib V",
    "name": "CMPPD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed double-precision floating-point values in xmm3/m128/m64bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 C2 /r ib V",
    "name": "CMPPD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed double-precision floating-point values in ymm3/m256/m64bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 C2 /r ib V",
    "name": "CMPPD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed double-precision floating-point values in zmm3/m512/m64bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "NP 0F C2 /r ib",
    "name": "CMPPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Compare packed single-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of imm8 as a comparison predicate."
  },
  {
    "opcode": "VEX.128.0F.WIG C2 /r ib V",
    "name": "CMPPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed single-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate."
  },
  {
    "opcode": "VEX.256.0F.WIG C2 /r ib V",
    "name": "CMPPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed single-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate."
  },
  {
    "opcode": "EVEX.128.0F.W0 C2 /r ib V",
    "name": "CMPPS",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed single-precision floating-point values in xmm3/m128/m32bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 C2 /r ib V",
    "name": "CMPPS",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed single-precision floating-point values in ymm3/m256/m32bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 C2 /r ib V",
    "name": "CMPPS",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed single-precision floating-point values in zmm3/m512/m32bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "A6",
    "name": "CMPS",
    "operands": [
      {
        "type": "m8"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly."
  },
  {
    "opcode": "A7",
    "name": "CMPS",
    "operands": [
      {
        "type": "m16"
      },
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
  },
  {
    "opcode": "A7",
    "name": "CMPS",
    "operands": [
      {
        "type": "m32"
      },
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly."
  },
  {
    "opcode": "REX.W + A7",
    "name": "CMPS",
    "operands": [
      {
        "type": "m64"
      },
      {
        "type": "m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
  },
  {
    "opcode": "A6",
    "name": "CMPSB",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly."
  },
  {
    "opcode": "A7",
    "name": "CMPSW",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
  },
  {
    "opcode": "A7",
    "name": "CMPSD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly."
  },
  {
    "opcode": "REX.W + A7",
    "name": "CMPSQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
  },
  {
    "opcode": "F2 0F C2 /r ib",
    "name": "CMPSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare low double-precision floating-point value in xmm2/m64 and xmm1 using bits 2:0 of imm8 as comparison predicate."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG C2 /r ib V",
    "name": "CMPSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare low double-precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 C2 /r ib V",
    "name": "CMPSD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare low double-precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "F3 0F C2 /r ib",
    "name": "CMPSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Compare low single-precision floating-point value in xmm2/m32 and xmm1 using bits 2:0 of imm8 as comparison predicate."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG C2 /r ib V",
    "name": "CMPSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 C2 /r ib V",
    "name": "CMPSS",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "0F B0/r",
    "name": "CMPXCHG",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid*",
    "desc": "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL."
  },
  {
    "opcode": "REX + 0F B0/r",
    "name": "CMPXCHG",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL."
  },
  {
    "opcode": "0F B1/r",
    "name": "CMPXCHG",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid*",
    "desc": "Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX."
  },
  {
    "opcode": "0F B1/r",
    "name": "CMPXCHG",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid*",
    "desc": "Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX."
  },
  {
    "opcode": "REX.W + 0F B1/r",
    "name": "CMPXCHG",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX."
  },
  {
    "opcode": "0F C7 /1",
    "name": "CMPXCHG8B",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid*",
    "desc": "Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX."
  },
  {
    "opcode": "REX.W + 0F C7 /1",
    "name": "CMPXCHG16B",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX."
  },
  {
    "opcode": "66 0F 2F /r",
    "name": "COMISD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "VEX.LIG.66.0F.WIG 2F /r V",
    "name": "COMISD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "EVEX.LIG.66.0F.W1 2F /r V",
    "name": "COMISD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "NP 0F 2F /r",
    "name": "COMISS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "VEX.LIG.0F.WIG 2F /r V",
    "name": "COMISS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "EVEX.LIG.0F.W0 2F /r V",
    "name": "COMISS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "0F A2",
    "name": "CPUID",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well)."
  },
  {
    "opcode": "F2 0F 38 F0 /r",
    "name": "CRC32",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Accumulate CRC32 on r/m8."
  },
  {
    "opcode": "F2 REX 0F 38 F0 /r",
    "name": "CRC32",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Accumulate CRC32 on r/m8."
  },
  {
    "opcode": "F2 0F 38 F1 /r",
    "name": "CRC32",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Accumulate CRC32 on r/m16."
  },
  {
    "opcode": "F2 0F 38 F1 /r",
    "name": "CRC32",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Accumulate CRC32 on r/m32."
  },
  {
    "opcode": "F2 REX.W 0F 38 F0 /r",
    "name": "CRC32",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Accumulate CRC32 on r/m8."
  },
  {
    "opcode": "F2 REX.W 0F 38 F1 /r",
    "name": "CRC32",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Accumulate CRC32 on r/m64."
  },
  {
    "opcode": "F3 0F E6 /r",
    "name": "CVTDQ2PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1."
  },
  {
    "opcode": "VEX.128.F3.0F.WIG E6 /r V",
    "name": "CVTDQ2PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1."
  },
  {
    "opcode": "VEX.256.F3.0F.WIG E6 /r V",
    "name": "CVTDQ2PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert four packed signed doubleword integers from xmm2/mem to four packed double-precision floating-point values in ymm1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W0 E6 /r V",
    "name": "CVTDQ2PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert 2 packed signed doubleword integers from xmm2/m128/m32bcst to eight packed double-precision floating-point values in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W0 E6 /r V",
    "name": "CVTDQ2PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert 4 packed signed doubleword integers from xmm2/m128/m32bcst to 4 packed double-precision floating-point values in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W0 E6 /r V",
    "name": "CVTDQ2PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "NP 0F 5B /r",
    "name": "CVTDQ2PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 5B /r V",
    "name": "CVTDQ2PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 5B /r V",
    "name": "CVTDQ2PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floating-point values in ymm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 5B /r V",
    "name": "CVTDQ2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed signed doubleword integers from xmm2/m128/m32bcst to four packed single-precision floating-point values in xmm1with writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 5B /r V",
    "name": "CVTDQ2PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed single-precision floating-point values in ymm1with writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 5B /r V",
    "name": "CVTDQ2PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert sixteen packed signed doubleword integers from zmm2/m512/m32bcst to sixteen packed single-precision floating-point values in zmm1with writemask k1."
  },
  {
    "opcode": "F2 0F E6 /r",
    "name": "CVTPD2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1."
  },
  {
    "opcode": "VEX.128.F2.0F.WIG E6 /r V",
    "name": "CVTPD2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1."
  },
  {
    "opcode": "VEX.256.F2.0F.WIG E6 /r V",
    "name": "CVTPD2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1."
  },
  {
    "opcode": "EVEX.128.F2.0F.W1 E6 /r V",
    "name": "CVTPD2DQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.W1 E6 /r V",
    "name": "CVTPD2DQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.W1 E6 /r V",
    "name": "CVTPD2DQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "66 0F 2D /r",
    "name": "CVTPD2PI",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Convert two packed double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm."
  },
  {
    "opcode": "66 0F 5A /r",
    "name": "CVTPD2PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 5A /r V",
    "name": "CVTPD2PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 5A /r V",
    "name": "CVTPD2PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert four packed double-precision floating-point values in ymm2/mem to four single-precision floating-point values in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 5A /r V",
    "name": "CVTPD2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two single-precision floating-point values in xmm1with writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 5A /r V",
    "name": "CVTPD2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four single-precision floating-point values in xmm1with writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 5A /r V",
    "name": "CVTPD2PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight single-precision floating-point values in ymm1with writemask k1."
  },
  {
    "opcode": "66 0F 2A /r",
    "name": "CVTPI2PD",
    "operands": [
      {
        "type": "xmm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm/m64*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm."
  },
  {
    "opcode": "NP 0F 2A /r",
    "name": "CVTPI2PS",
    "operands": [
      {
        "type": "xmm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm."
  },
  {
    "opcode": "66 0F 5B /r",
    "name": "CVTPS2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 5B /r V",
    "name": "CVTPS2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 5B /r V",
    "name": "CVTPS2DQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 5B /r V",
    "name": "CVTPS2DQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 5B /r V",
    "name": "CVTPS2DQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 5B /r V",
    "name": "CVTPS2DQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 subject to writemask k1."
  },
  {
    "opcode": "NP 0F 5A /r",
    "name": "CVTPS2PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 5A /r V",
    "name": "CVTPS2PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 5A /r V",
    "name": "CVTPS2PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert four packed single-precision floating-point values in xmm2/m128 to four packed double-precision floating-point values in ymm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 5A /r V",
    "name": "CVTPS2PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert two packed single-precision floating-point values in xmm2/m64/m32bcst to packed double-precision floating-point values in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 5A /r V",
    "name": "CVTPS2PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL",
    "desc": "Convert four packed single-precision floating-point values in xmm2/m128/m32bcst to packed double-precision floating-point values in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 5A /r V",
    "name": "CVTPS2PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert eight packed single-precision floating-point values in ymm2/m256/b32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "NP 0F 2D /r",
    "name": "CVTPS2PI",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Convert two packed single-precision floating-point values from xmm/m64 to two packed signed doubleword integers in mm."
  },
  {
    "opcode": "F2 0F 2D /r",
    "name": "CVTSD2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
  },
  {
    "opcode": "F2 REX.W 0F 2D /r",
    "name": "CVTSD2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE2",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64."
  },
  {
    "opcode": "VEX.LIG.F2.0F.W0 2D /r 1 V",
    "name": "CVTSD2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
  },
  {
    "opcode": "VEX.LIG.F2.0F.W1 2D /r 1 V",
    "name": "CVTSD2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W0 2D /r V",
    "name": "CVTSD2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 2D /r V",
    "name": "CVTSD2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64."
  },
  {
    "opcode": "F2 0F 5A /r",
    "name": "CVTSD2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 5A /r V",
    "name": "CVTSD2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 5A /r V",
    "name": "CVTSD2SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2 under writemask k1."
  },
  {
    "opcode": "F2 0F 2A /r",
    "name": "CVTSI2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert one signed doubleword integer from r32/m32 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "F2 REX.W 0F 2A /r",
    "name": "CVTSI2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE2",
    "desc": "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.W0 2A /r V",
    "name": "CVTSI2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.W1 2A /r V",
    "name": "CVTSI2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX",
    "desc": "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W0 2A /r V",
    "name": "CVTSI2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 2A /r V",
    "name": "CVTSI2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "r/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "F3 0F 2A /r",
    "name": "CVTSI2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "F3 REX.W 0F 2A /r",
    "name": "CVTSI2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE",
    "desc": "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.W0 2A /r V",
    "name": "CVTSI2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.W1 2A /r V",
    "name": "CVTSI2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX",
    "desc": "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 2A /r V",
    "name": "CVTSI2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "r/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W1 2A /r V",
    "name": "CVTSI2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "r/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "F3 0F 5A /r",
    "name": "CVTSS2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 5A /r V",
    "name": "CVTSS2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 5A /r V",
    "name": "CVTSS2SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2 under writemask k1."
  },
  {
    "opcode": "F3 0F 2D /r",
    "name": "CVTSS2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
  },
  {
    "opcode": "F3 REX.W 0F 2D /r",
    "name": "CVTSS2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
  },
  {
    "opcode": "VEX.LIG.F3.0F.W0 2D /r 1 V",
    "name": "CVTSS2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
  },
  {
    "opcode": "VEX.LIG.F3.0F.W1 2D /r 1 V",
    "name": "CVTSS2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 2D /r V",
    "name": "CVTSS2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W1 2D /r V",
    "name": "CVTSS2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
  },
  {
    "opcode": "66 0F E6 /r",
    "name": "CVTTPD2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E6 /r V",
    "name": "CVTTPD2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E6 /r V",
    "name": "CVTTPD2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 E6 /r V",
    "name": "CVTTPD2DQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 E6 /r V",
    "name": "CVTTPD2DQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 E6 /r V",
    "name": "CVTTPD2DQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "66 0F 2C /r",
    "name": "CVTTPD2PI",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Convert two packer double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm using truncation."
  },
  {
    "opcode": "F3 0F 5B /r",
    "name": "CVTTPS2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
  },
  {
    "opcode": "VEX.128.F3.0F.WIG 5B /r V",
    "name": "CVTTPS2DQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
  },
  {
    "opcode": "VEX.256.F3.0F.WIG 5B /r V",
    "name": "CVTTPS2DQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation."
  },
  {
    "opcode": "EVEX.128.F3.0F.W0 5B /r V",
    "name": "CVTTPS2DQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W0 5B /r V",
    "name": "CVTTPS2DQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W0 5B /r V",
    "name": "CVTTPS2DQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst {sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "NP 0F 2C /r",
    "name": "CVTTPS2PI",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation."
  },
  {
    "opcode": "F2 0F 2C /r",
    "name": "CVTTSD2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
  },
  {
    "opcode": "F2 REX.W 0F 2C /r",
    "name": "CVTTSD2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE2",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
  },
  {
    "opcode": "VEX.LIG.F2.0F.W0 2C /r 1 V",
    "name": "CVTTSD2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
  },
  {
    "opcode": "VEX.LIG.F2.0F.W1 2C /r 1 V",
    "name": "CVTTSD2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W0 2C /r V",
    "name": "CVTTSD2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 2C /r V",
    "name": "CVTTSD2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
  },
  {
    "opcode": "F3 0F 2C /r",
    "name": "CVTTSS2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
  },
  {
    "opcode": "F3 REX.W 0F 2C /r",
    "name": "CVTTSS2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
  },
  {
    "opcode": "VEX.LIG.F3.0F.W0 2C /r 1 V",
    "name": "CVTTSS2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
  },
  {
    "opcode": "VEX.LIG.F3.0F.W1 2C /r 1 V",
    "name": "CVTTSS2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 2C /r V",
    "name": "CVTTSS2SI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W1 2C /r V",
    "name": "CVTTSS2SI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
  },
  {
    "opcode": "99",
    "name": "CWD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "DX:AX  sign-extend of AX."
  },
  {
    "opcode": "99",
    "name": "CDQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "EDX:EAX  sign-extend of EAX."
  },
  {
    "opcode": "REX.W + 99",
    "name": "CQO",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "RDX:RAX sign-extend of RAX."
  },
  {
    "opcode": "27",
    "name": "DAA",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Decimal adjust AL after addition."
  },
  {
    "opcode": "2F",
    "name": "DAS",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Decimal adjust AL after subtraction."
  },
  {
    "opcode": "FE /1",
    "name": "DEC",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Decrement r/m8 by 1."
  },
  {
    "opcode": "REX + FE /1",
    "name": "DEC",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Decrement r/m8 by 1."
  },
  {
    "opcode": "FF /1",
    "name": "DEC",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Decrement r/m16 by 1."
  },
  {
    "opcode": "FF /1",
    "name": "DEC",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Decrement r/m32 by 1."
  },
  {
    "opcode": "REX.W + FF /1",
    "name": "DEC",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Decrement r/m64 by 1."
  },
  {
    "opcode": "48+rw",
    "name": "DEC",
    "operands": [
      {
        "type": "r16",
        "encoding": "opcode + rd (r, w)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Decrement r16 by 1."
  },
  {
    "opcode": "48+rd",
    "name": "DEC",
    "operands": [
      {
        "type": "r32",
        "encoding": "opcode + rd (r, w)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Decrement r32 by 1."
  },
  {
    "opcode": "F6 /6",
    "name": "DIV",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Unsigned divide AX by r/m8, with result stored in AL  Quotient, AH  Remainder."
  },
  {
    "opcode": "REX + F6 /6",
    "name": "DIV",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Unsigned divide AX by r/m8, with result stored in AL  Quotient, AH  Remainder."
  },
  {
    "opcode": "F7 /6",
    "name": "DIV",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Unsigned divide DX:AX by r/m16, with result stored in AX  Quotient, DX  Remainder."
  },
  {
    "opcode": "F7 /6",
    "name": "DIV",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Unsigned divide EDX:EAX by r/m32, with result stored in EAX  Quotient, EDX  Remainder."
  },
  {
    "opcode": "REX.W + F7 /6",
    "name": "DIV",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Unsigned divide RDX:RAX by r/m64, with result stored in RAX  Quotient, RDX  Remainder."
  },
  {
    "opcode": "66 0F 5E /r",
    "name": "DIVPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values in xmm2/mem."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 5E /r V",
    "name": "DIVPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 5E /r V",
    "name": "DIVPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 5E /r V",
    "name": "DIVPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/m128/m64bcst and write results to xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 5E /r V",
    "name": "DIVPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/m256/m64bcst and write results to ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 5E /r V",
    "name": "DIVPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Divide packed double-precision floating-point values in zmm2 by packed double-precision FP values in zmm3/m512/m64bcst and write results to zmm1 subject to writemask k1."
  },
  {
    "opcode": "NP 0F 5E /r",
    "name": "DIVPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values in xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F.WIG 5E /r V",
    "name": "DIVPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Divide packed single-precision floating-point values in xmm2 by packed single-precision floating-point values in xmm3/mem."
  },
  {
    "opcode": "VEX.256.0F.WIG 5E /r V",
    "name": "DIVPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Divide packed single-precision floating-point values in ymm2 by packed single-precision floating-point values in ymm3/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 5E /r V",
    "name": "DIVPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Divide packed single-precision floating-point values in xmm2 by packed single-precision floating-point values in xmm3/m128/m32bcst and write results to xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 5E /r V",
    "name": "DIVPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Divide packed single-precision floating-point values in ymm2 by packed single-precision floating-point values in ymm3/m256/m32bcst and write results to ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 5E /r V",
    "name": "DIVPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Divide packed single-precision floating-point values in zmm2 by packed single-precision floating-point values in zmm3/m512/m32bcst and write results to zmm1 subject to writemask k1."
  },
  {
    "opcode": "F2 0F 5E /r",
    "name": "DIVSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/m64."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 5E /r V",
    "name": "DIVSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 5E /r V",
    "name": "DIVSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."
  },
  {
    "opcode": "F3 0F 5E /r",
    "name": "DIVSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 5E /r V",
    "name": "DIVSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Divide low single-precision floating-point value in xmm2 by low single-precision floating-point value in xmm3/m32."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 5E /r V",
    "name": "DIVSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Divide low single-precision floating-point value in xmm2 by low single-precision floating-point value in xmm3/m32."
  },
  {
    "opcode": "66 0F 3A 41 /r ib",
    "name": "DPPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Selectively multiply packed DP floating-point values from xmm1 with packed DP floating-point values from xmm2, add and selectively store the packed DP floating-point values to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 41 /r ib V",
    "name": "DPPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Selectively multiply packed DP floating-point values from xmm2 with packed DP floating-point values from xmm3, add and selectively store the packed DP floating-point values to xmm1."
  },
  {
    "opcode": "66 0F 3A 40 /r ib",
    "name": "DPPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Selectively multiply packed SP floating-point values from xmm1 with packed SP floating-point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 40 /r ib V",
    "name": "DPPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.WIG 40 /r ib V",
    "name": "DPPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1."
  },
  {
    "opcode": "NP 0F 77",
    "name": "EMMS",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set the x87 FPU tag word to empty."
  },
  {
    "opcode": "C8 iw 00",
    "name": "ENTER",
    "operands": [
      {
        "type": "imm16",
        "encoding": "iw"
      },
      {
        "type": "0",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Create a stack frame for a procedure."
  },
  {
    "opcode": "C8 iw 01",
    "name": "ENTER",
    "operands": [
      {
        "type": "imm16",
        "encoding": "iw"
      },
      {
        "type": "1",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Create a stack frame with a nested pointer for a procedure."
  },
  {
    "opcode": "C8 iw ib",
    "name": "ENTER",
    "operands": [
      {
        "type": "imm16",
        "encoding": "iw"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Create a stack frame with nested pointers for a procedure."
  },
  {
    "opcode": "66 0F 3A 17 /r ib",
    "name": "EXTRACTPS",
    "operands": [
      {
        "type": "reg/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 17 /r ib V",
    "name": "EXTRACTPS",
    "operands": [
      {
        "type": "reg/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
  },
  {
    "opcode": "EVEX.128.66.0F3A.WIG 17 /r ib V",
    "name": "EXTRACTPS",
    "operands": [
      {
        "type": "reg/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
  },
  {
    "opcode": "D9 F0",
    "name": "F2XM1",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(0) with (2ST(0)  1)."
  },
  {
    "opcode": "D9 E1",
    "name": "FABS",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST with its absolute value."
  },
  {
    "opcode": "D8 /0",
    "name": "FADD",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add m32fp to ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DC /0",
    "name": "FADD",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add m64fp to ST(0) and store result in ST(0)."
  },
  {
    "opcode": "D8 C0+i",
    "name": "FADD",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add ST(0) to ST(i) and store result in ST(0)."
  },
  {
    "opcode": "DC C0+i",
    "name": "FADD",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add ST(i) to ST(0) and store result in ST(i)."
  },
  {
    "opcode": "DE C0+i",
    "name": "FADDP",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add ST(0) to ST(i), store result in ST(i), and pop the register stack."
  },
  {
    "opcode": "DE C1",
    "name": "FADDP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add ST(0) to ST(1), store result in ST(1), and pop the register stack."
  },
  {
    "opcode": "DA /0",
    "name": "FIADD",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add m32int to ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DE /0",
    "name": "FIADD",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Add m16int to ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DF /4",
    "name": "FBLD",
    "operands": [
      {
        "type": "m80bcd"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Convert BCD value to floating-point and push onto the FPU stack."
  },
  {
    "opcode": "DF /6",
    "name": "FBSTP",
    "operands": [
      {
        "type": "m80bcd"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m80bcd and pop ST(0)."
  },
  {
    "opcode": "D9 E0",
    "name": "FCHS",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Complements sign of ST(0)."
  },
  {
    "opcode": "9B DB E2",
    "name": "FCLEX",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Clear floating-point exception flags after checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "DB E2",
    "name": "FNCLEX*",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Clear floating-point exception flags without checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "DA C0+i",
    "name": "FCMOVB",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if below (CF=1)."
  },
  {
    "opcode": "DA C8+i",
    "name": "FCMOVE",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if equal (ZF=1)."
  },
  {
    "opcode": "DA D0+i",
    "name": "FCMOVBE",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if below or equal (CF=1 or ZF=1)."
  },
  {
    "opcode": "DA D8+i",
    "name": "FCMOVU",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if unordered (PF=1)."
  },
  {
    "opcode": "DB C0+i",
    "name": "FCMOVNB",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not below (CF=0)."
  },
  {
    "opcode": "DB C8+i",
    "name": "FCMOVNE",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not equal (ZF=0)."
  },
  {
    "opcode": "DB D0+i",
    "name": "FCMOVNBE",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not below or equal (CF=0 and ZF=0)."
  },
  {
    "opcode": "DB D8+i",
    "name": "FCMOVNU",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move if not unordered (PF=0)."
  },
  {
    "opcode": "D8 /2",
    "name": "FCOM",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with m32fp."
  },
  {
    "opcode": "DC /2",
    "name": "FCOM",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with m64fp."
  },
  {
    "opcode": "D8 D0+i",
    "name": "FCOM",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(i)."
  },
  {
    "opcode": "D8 D1",
    "name": "FCOM",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(1)."
  },
  {
    "opcode": "D8 /3",
    "name": "FCOMP",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with m32fp and pop register stack."
  },
  {
    "opcode": "DC /3",
    "name": "FCOMP",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with m64fp and pop register stack."
  },
  {
    "opcode": "D8 D8+i",
    "name": "FCOMP",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(i) and pop register stack."
  },
  {
    "opcode": "D8 D9",
    "name": "FCOMP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(1) and pop register stack."
  },
  {
    "opcode": "DE D9",
    "name": "FCOMPP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(1) and pop register stack twice."
  },
  {
    "opcode": "DB F0+i",
    "name": "FCOMI",
    "operands": [
      {
        "type": "ST"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(i) and set status flags accordingly."
  },
  {
    "opcode": "DF F0+i",
    "name": "FCOMIP",
    "operands": [
      {
        "type": "ST"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."
  },
  {
    "opcode": "DB E8+i",
    "name": "FUCOMI",
    "operands": [
      {
        "type": "ST"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."
  },
  {
    "opcode": "DF E8+i",
    "name": "FUCOMIP",
    "operands": [
      {
        "type": "ST"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."
  },
  {
    "opcode": "D9 FF",
    "name": "FCOS",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(0) with its approximate cosine."
  },
  {
    "opcode": "D9 F6",
    "name": "FDECSTP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Decrement TOP field in FPU status word."
  },
  {
    "opcode": "D8 /6",
    "name": "FDIV",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(0) by m32fp and store result in ST(0)."
  },
  {
    "opcode": "DC /6",
    "name": "FDIV",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(0) by m64fp and store result in ST(0)."
  },
  {
    "opcode": "D8 F0+i",
    "name": "FDIV",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(0) by ST(i) and store result in ST(0)."
  },
  {
    "opcode": "DC F8+i",
    "name": "FDIV",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(i) by ST(0) and store result in ST(i)."
  },
  {
    "opcode": "DE F8+i",
    "name": "FDIVP",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(i) by ST(0), store result in ST(i), and pop the register stack."
  },
  {
    "opcode": "DE F9",
    "name": "FDIVP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(1) by ST(0), store result in ST(1), and pop the register stack."
  },
  {
    "opcode": "DA /6",
    "name": "FIDIV",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(0) by m32int and store result in ST(0)."
  },
  {
    "opcode": "DE /6",
    "name": "FIDIV",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(0) by m16int and store result in ST(0)."
  },
  {
    "opcode": "D8 /7",
    "name": "FDIVR",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide m32fp by ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DC /7",
    "name": "FDIVR",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide m64fp by ST(0) and store result in ST(0)."
  },
  {
    "opcode": "D8 F8+i",
    "name": "FDIVR",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(i) by ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DC F0+i",
    "name": "FDIVR",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(0) by ST(i) and store result in ST(i)."
  },
  {
    "opcode": "DE F0+i",
    "name": "FDIVRP",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(0) by ST(i), store result in ST(i), and pop the register stack."
  },
  {
    "opcode": "DE F1",
    "name": "FDIVRP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide ST(0) by ST(1), store result in ST(1), and pop the register stack."
  },
  {
    "opcode": "DA /7",
    "name": "FIDIVR",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide m32int by ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DE /7",
    "name": "FIDIVR",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Divide m16int by ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DD C0+i",
    "name": "FFREE",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Sets tag for ST(i) to empty."
  },
  {
    "opcode": "DE /2",
    "name": "FICOM",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with m16int."
  },
  {
    "opcode": "DA /2",
    "name": "FICOM",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with m32int."
  },
  {
    "opcode": "DE /3",
    "name": "FICOMP",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with m16int and pop stack register."
  },
  {
    "opcode": "DA /3",
    "name": "FICOMP",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with m32int and pop stack register."
  },
  {
    "opcode": "DF /0",
    "name": "FILD",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push m16int onto the FPU register stack."
  },
  {
    "opcode": "DB /0",
    "name": "FILD",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push m32int onto the FPU register stack."
  },
  {
    "opcode": "DF /5",
    "name": "FILD",
    "operands": [
      {
        "type": "m64int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push m64int onto the FPU register stack."
  },
  {
    "opcode": "D9 F7",
    "name": "FINCSTP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Increment the TOP field in the FPU status register."
  },
  {
    "opcode": "9B DB E3",
    "name": "FINIT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Initialize FPU after checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "DB E3",
    "name": "FNINIT*",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Initialize FPU without checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "DF /2",
    "name": "FIST",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m16int."
  },
  {
    "opcode": "DB /2",
    "name": "FIST",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m32int."
  },
  {
    "opcode": "DF /3",
    "name": "FISTP",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m16int and pop register stack."
  },
  {
    "opcode": "DB /3",
    "name": "FISTP",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m32int and pop register stack."
  },
  {
    "opcode": "DF /7",
    "name": "FISTP",
    "operands": [
      {
        "type": "m64int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m64int and pop register stack."
  },
  {
    "opcode": "DF /1",
    "name": "FISTTP",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m16int with truncation."
  },
  {
    "opcode": "DB /1",
    "name": "FISTTP",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m32int with truncation."
  },
  {
    "opcode": "DD /1",
    "name": "FISTTP",
    "operands": [
      {
        "type": "m64int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store ST(0) in m64int with truncation."
  },
  {
    "opcode": "D9 /0",
    "name": "FLD",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push m32fp onto the FPU register stack."
  },
  {
    "opcode": "DD /0",
    "name": "FLD",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push m64fp onto the FPU register stack."
  },
  {
    "opcode": "DB /5",
    "name": "FLD",
    "operands": [
      {
        "type": "m80fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push m80fp onto the FPU register stack."
  },
  {
    "opcode": "D9 C0+i",
    "name": "FLD",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push ST(i) onto the FPU register stack."
  },
  {
    "opcode": "D9 E8",
    "name": "FLD1",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push +1.0 onto the FPU register stack."
  },
  {
    "opcode": "D9 E9",
    "name": "FLDL2T",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push log210 onto the FPU register stack."
  },
  {
    "opcode": "D9 EA",
    "name": "FLDL2E",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push log2e onto the FPU register stack."
  },
  {
    "opcode": "D9 EB",
    "name": "FLDPI",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push  onto the FPU register stack."
  },
  {
    "opcode": "D9 EC",
    "name": "FLDLG2",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push log102 onto the FPU register stack."
  },
  {
    "opcode": "D9 ED",
    "name": "FLDLN2",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push loge2 onto the FPU register stack."
  },
  {
    "opcode": "D9 EE",
    "name": "FLDZ",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push +0.0 onto the FPU register stack."
  },
  {
    "opcode": "D9 /5",
    "name": "FLDCW",
    "operands": [
      {
        "type": "m2byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load FPU control word from m2byte."
  },
  {
    "opcode": "D9 /4",
    "name": "FLDENV",
    "operands": [
      {
        "type": "m14/28byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load FPU environment from m14byte or m28byte."
  },
  {
    "opcode": "D8 /1",
    "name": "FMUL",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply ST(0) by m32fp and store result in ST(0)."
  },
  {
    "opcode": "DC /1",
    "name": "FMUL",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply ST(0) by m64fp and store result in ST(0)."
  },
  {
    "opcode": "D8 C8+i",
    "name": "FMUL",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply ST(0) by ST(i) and store result in ST(0)."
  },
  {
    "opcode": "DC C8+i",
    "name": "FMUL",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply ST(i) by ST(0) and store result in ST(i)."
  },
  {
    "opcode": "DE C8+i",
    "name": "FMULP",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack."
  },
  {
    "opcode": "DE C9",
    "name": "FMULP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack."
  },
  {
    "opcode": "DA /1",
    "name": "FIMUL",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply ST(0) by m32int and store result in ST(0)."
  },
  {
    "opcode": "DE /1",
    "name": "FIMUL",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply ST(0) by m16int and store result in ST(0)."
  },
  {
    "opcode": "D9 D0",
    "name": "FNOP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "No operation is performed."
  },
  {
    "opcode": "D9 F3",
    "name": "FPATAN",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack."
  },
  {
    "opcode": "D9 F8",
    "name": "FPREM",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1)."
  },
  {
    "opcode": "D9 F5",
    "name": "FPREM1",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1)."
  },
  {
    "opcode": "D9 F2",
    "name": "FPTAN",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(0) with its approximate tangent and push 1 onto the FPU stack."
  },
  {
    "opcode": "D9 FC",
    "name": "FRNDINT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Round ST(0) to an integer."
  },
  {
    "opcode": "DD /4",
    "name": "FRSTOR",
    "operands": [
      {
        "type": "m94/108byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load FPU state from m94byte or m108byte."
  },
  {
    "opcode": "9B DD /6",
    "name": "FSAVE",
    "operands": [
      {
        "type": "m94/108byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
  },
  {
    "opcode": "DD /6",
    "name": "FNSAVE*",
    "operands": [
      {
        "type": "m94/108byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
  },
  {
    "opcode": "D9 FD",
    "name": "FSCALE",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Scale ST(0) by ST(1)."
  },
  {
    "opcode": "D9 FE",
    "name": "FSIN",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(0) with the approximate of its sine."
  },
  {
    "opcode": "D9 FB",
    "name": "FSINCOS",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compute the sine and cosine of ST(0); replace ST(0) with the approximate sine, and push the approximate cosine onto the register stack."
  },
  {
    "opcode": "D9 FA",
    "name": "FSQRT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Computes square root of ST(0) and stores the result in ST(0)."
  },
  {
    "opcode": "D9 /2",
    "name": "FST",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Copy ST(0) to m32fp."
  },
  {
    "opcode": "DD /2",
    "name": "FST",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Copy ST(0) to m64fp."
  },
  {
    "opcode": "DD D0+i",
    "name": "FST",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Copy ST(0) to ST(i)."
  },
  {
    "opcode": "D9 /3",
    "name": "FSTP",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Copy ST(0) to m32fp and pop register stack."
  },
  {
    "opcode": "DD /3",
    "name": "FSTP",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Copy ST(0) to m64fp and pop register stack."
  },
  {
    "opcode": "DB /7",
    "name": "FSTP",
    "operands": [
      {
        "type": "m80fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Copy ST(0) to m80fp and pop register stack."
  },
  {
    "opcode": "DD D8+i",
    "name": "FSTP",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Copy ST(0) to ST(i) and pop register stack."
  },
  {
    "opcode": "9B D9 /7",
    "name": "FSTCW",
    "operands": [
      {
        "type": "m2byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "D9 /7",
    "name": "FNSTCW*",
    "operands": [
      {
        "type": "m2byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "9B D9 /6",
    "name": "FSTENV",
    "operands": [
      {
        "type": "m14/28byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."
  },
  {
    "opcode": "D9 /6",
    "name": "FNSTENV*",
    "operands": [
      {
        "type": "m14/28byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."
  },
  {
    "opcode": "9B DD /7",
    "name": "FSTSW",
    "operands": [
      {
        "type": "m2byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "9B DF E0",
    "name": "FSTSW",
    "operands": [
      {
        "type": "AX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU status word in AX register after checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "DD /7",
    "name": "FNSTSW*",
    "operands": [
      {
        "type": "m2byte"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "DF E0",
    "name": "FNSTSW*",
    "operands": [
      {
        "type": "AX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store FPU status word in AX register without checking for pending unmasked floating-point exceptions."
  },
  {
    "opcode": "D8 /4",
    "name": "FSUB",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract m32fp from ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DC /4",
    "name": "FSUB",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract m64fp from ST(0) and store result in ST(0)."
  },
  {
    "opcode": "D8 E0+i",
    "name": "FSUB",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(i) from ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DC E8+i",
    "name": "FSUB",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(0) from ST(i) and store result in ST(i)."
  },
  {
    "opcode": "DE E8+i",
    "name": "FSUBP",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(0) from ST(i), store result in ST(i), and pop register stack."
  },
  {
    "opcode": "DE E9",
    "name": "FSUBP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(0) from ST(1), store result in ST(1), and pop register stack."
  },
  {
    "opcode": "DA /4",
    "name": "FISUB",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract m32int from ST(0) and store result in ST(0)."
  },
  {
    "opcode": "DE /4",
    "name": "FISUB",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract m16int from ST(0) and store result in ST(0)."
  },
  {
    "opcode": "D8 /5",
    "name": "FSUBR",
    "operands": [
      {
        "type": "m32fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(0) from m32fp and store result in ST(0)."
  },
  {
    "opcode": "DC /5",
    "name": "FSUBR",
    "operands": [
      {
        "type": "m64fp"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(0) from m64fp and store result in ST(0)."
  },
  {
    "opcode": "D8 E8+i",
    "name": "FSUBR",
    "operands": [
      {
        "type": "ST(0)"
      },
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(0) from ST(i) and store result in ST(0)."
  },
  {
    "opcode": "DC E0+i",
    "name": "FSUBR",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(i) from ST(0) and store result in ST(i)."
  },
  {
    "opcode": "DE E0+i",
    "name": "FSUBRP",
    "operands": [
      {
        "type": "ST(i)"
      },
      {
        "type": "ST(0)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(i) from ST(0), store result in ST(i), and pop register stack."
  },
  {
    "opcode": "DE E1",
    "name": "FSUBRP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(1) from ST(0), store result in ST(1), and pop register stack."
  },
  {
    "opcode": "DA /5",
    "name": "FISUBR",
    "operands": [
      {
        "type": "m32int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(0) from m32int and store result in ST(0)."
  },
  {
    "opcode": "DE /5",
    "name": "FISUBR",
    "operands": [
      {
        "type": "m16int"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract ST(0) from m16int and store result in ST(0)."
  },
  {
    "opcode": "D9 E4",
    "name": "FTST",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with 0.0."
  },
  {
    "opcode": "DD E0+i",
    "name": "FUCOM",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(i)."
  },
  {
    "opcode": "DD E1",
    "name": "FUCOM",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(1)."
  },
  {
    "opcode": "DD E8+i",
    "name": "FUCOMP",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(i) and pop register stack."
  },
  {
    "opcode": "DD E9",
    "name": "FUCOMP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(1) and pop register stack."
  },
  {
    "opcode": "DA E9",
    "name": "FUCOMPP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare ST(0) with ST(1) and pop register stack twice."
  },
  {
    "opcode": "D9 E5",
    "name": "FXAM",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Classify value or number in ST(0)."
  },
  {
    "opcode": "D9 C8+i",
    "name": "FXCH",
    "operands": [
      {
        "type": "ST(i)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange the contents of ST(0) and ST(i)."
  },
  {
    "opcode": "D9 C9",
    "name": "FXCH",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange the contents of ST(0) and ST(1)."
  },
  {
    "opcode": "NP 0F AE /1",
    "name": "FXRSTOR",
    "operands": [
      {
        "type": "m512byte",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
  },
  {
    "opcode": "NP REX.W + 0F AE /1",
    "name": "FXRSTOR64",
    "operands": [
      {
        "type": "m512byte",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
  },
  {
    "opcode": "NP 0F AE /0",
    "name": "FXSAVE",
    "operands": [
      {
        "type": "m512byte",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
  },
  {
    "opcode": "NP REX.W + 0F AE /0",
    "name": "FXSAVE64",
    "operands": [
      {
        "type": "m512byte",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
  },
  {
    "opcode": "D9 F4",
    "name": "FXTRACT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack."
  },
  {
    "opcode": "D9 F1",
    "name": "FYL2X",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(1) with (ST(1)  log2ST(0)) and pop the register stack."
  },
  {
    "opcode": "D9 F9",
    "name": "FYL2XP1",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Replace ST(1) with ST(1)  log2(ST(0) + 1.0) and pop the register stack."
  },
  {
    "opcode": "66 0F3A CF /r /ib",
    "name": "GF2P8AFFINEINVQB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8 (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "GFNI",
    "desc": "Computes inverse affine transformation in the finite field GF(2^8)."
  },
  {
    "opcode": "66 0F3A CE /r /ib",
    "name": "GF2P8AFFINEQB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8 (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "GFNI",
    "desc": "Computes affine transformation in the finite field GF(2^8)."
  },
  {
    "opcode": "66 0F38 CF /r",
    "name": "GF2P8MULB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "GFNI",
    "desc": "Multiplies elements in the finite field GF(2^8)."
  },
  {
    "opcode": "66 0F 7C /r",
    "name": "HADDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 7C /r V",
    "name": "HADDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 7C /r V",
    "name": "HADDPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem."
  },
  {
    "opcode": "F2 0F 7C /r",
    "name": "HADDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1."
  },
  {
    "opcode": "VEX.128.F2.0F.WIG 7C /r V",
    "name": "HADDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.F2.0F.WIG 7C /r V",
    "name": "HADDPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem."
  },
  {
    "opcode": "F4",
    "name": "HLT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Halt"
  },
  {
    "opcode": "66 0F 7D /r",
    "name": "HSUBPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 7D /r V",
    "name": "HSUBPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 7D /r V",
    "name": "HSUBPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem."
  },
  {
    "opcode": "F2 0F 7D /r",
    "name": "HSUBPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1."
  },
  {
    "opcode": "VEX.128.F2.0F.WIG 7D /r V",
    "name": "HSUBPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.F2.0F.WIG 7D /r V",
    "name": "HSUBPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem."
  },
  {
    "opcode": "F6 /7",
    "name": "IDIV",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide AX by r/m8, with result stored in: AL  Quotient, AH  Remainder."
  },
  {
    "opcode": "REX + F6 /7",
    "name": "IDIV",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Signed divide AX by r/m8, with result stored in AL  Quotient, AH  Remainder."
  },
  {
    "opcode": "F7 /7",
    "name": "IDIV",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide DX:AX by r/m16, with result stored in AX  Quotient, DX  Remainder."
  },
  {
    "opcode": "F7 /7",
    "name": "IDIV",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide EDX:EAX by r/m32, with result stored in EAX  Quotient, EDX  Remainder."
  },
  {
    "opcode": "REX.W + F7 /7",
    "name": "IDIV",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Signed divide RDX:RAX by r/m64, with result stored in RAX  Quotient, RDX  Remainder."
  },
  {
    "opcode": "F6 /5",
    "name": "IMUL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AX AL  r/m byte."
  },
  {
    "opcode": "F7 /5",
    "name": "IMUL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "DX:AX  AX  r/m word."
  },
  {
    "opcode": "F7 /5",
    "name": "IMUL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "EDX:EAX  EAX  r/m32."
  },
  {
    "opcode": "REX.W + F7 /5",
    "name": "IMUL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "RDX:RAX  RAX  r/m64."
  },
  {
    "opcode": "0F AF /r",
    "name": "IMUL",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "word register  word register  r/m16."
  },
  {
    "opcode": "0F AF /r",
    "name": "IMUL",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "doubleword register  doubleword register  r/m32."
  },
  {
    "opcode": "REX.W + 0F AF /r",
    "name": "IMUL",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Quadword register  Quadword register  r/m64."
  },
  {
    "opcode": "6B /r ib",
    "name": "IMUL",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "word register  r/m16  sign-extended immediate byte."
  },
  {
    "opcode": "6B /r ib",
    "name": "IMUL",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "doubleword register  r/m32  sign-extended immediate byte."
  },
  {
    "opcode": "REX.W + 6B /r ib",
    "name": "IMUL",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Quadword register  r/m64  sign-extended immediate byte."
  },
  {
    "opcode": "69 /r iw",
    "name": "IMUL",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "word register  r/m16  immediate word."
  },
  {
    "opcode": "69 /r id",
    "name": "IMUL",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "doubleword register  r/m32  immediate doubleword."
  },
  {
    "opcode": "REX.W + 69 /r id",
    "name": "IMUL",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Quadword register  r/m64  immediate doubleword."
  },
  {
    "opcode": "E4 ib",
    "name": "IN",
    "operands": [
      {
        "type": "AL",
        "encoding": "imm8"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input byte from imm8 I/O port address into AL."
  },
  {
    "opcode": "E5 ib",
    "name": "IN",
    "operands": [
      {
        "type": "AX",
        "encoding": "imm8"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input word from imm8 I/O port address into AX."
  },
  {
    "opcode": "E5 ib",
    "name": "IN",
    "operands": [
      {
        "type": "EAX",
        "encoding": "imm8"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input dword from imm8 I/O port address into EAX."
  },
  {
    "opcode": "EC",
    "name": "IN",
    "operands": [
      {
        "type": "AL"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input byte from I/O port in DX into AL."
  },
  {
    "opcode": "ED",
    "name": "IN",
    "operands": [
      {
        "type": "AX"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input word from I/O port in DX into AX."
  },
  {
    "opcode": "ED",
    "name": "IN",
    "operands": [
      {
        "type": "EAX"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input doubleword from I/O port in DX into EAX."
  },
  {
    "opcode": "FE /0",
    "name": "INC",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Increment r/m byte by 1."
  },
  {
    "opcode": "REX + FE /0",
    "name": "INC",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Increment r/m byte by 1."
  },
  {
    "opcode": "FF /0",
    "name": "INC",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Increment r/m word by 1."
  },
  {
    "opcode": "FF /0",
    "name": "INC",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Increment r/m doubleword by 1."
  },
  {
    "opcode": "REX.W + FF /0",
    "name": "INC",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Increment r/m quadword by 1."
  },
  {
    "opcode": "40+ rw**",
    "name": "INC",
    "operands": [
      {
        "type": "r16",
        "encoding": "opcode + rd (r, w)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Increment word register by 1."
  },
  {
    "opcode": "40+ rd",
    "name": "INC",
    "operands": [
      {
        "type": "r32",
        "encoding": "opcode + rd (r, w)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Increment doubleword register by 1."
  },
  {
    "opcode": "6C",
    "name": "INS",
    "operands": [
      {
        "type": "m8"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.*"
  },
  {
    "opcode": "6D",
    "name": "INS",
    "operands": [
      {
        "type": "m16"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
  },
  {
    "opcode": "6D",
    "name": "INS",
    "operands": [
      {
        "type": "m32"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
  },
  {
    "opcode": "6C",
    "name": "INSB",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1"
  },
  {
    "opcode": "6D",
    "name": "INSW",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
  },
  {
    "opcode": "6D",
    "name": "INSD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
  },
  {
    "opcode": "66 0F 3A 21 /r ib",
    "name": "INSERTPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Insert a single-precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 21 /r ib V",
    "name": "INSERTPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Insert a single-precision floating-point value selected by imm8 from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by imm8 and write out the result and zero out destination elements in xmm1 as indicated in imm8."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 21 /r ib V",
    "name": "INSERTPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Insert a single-precision floating-point value selected by imm8 from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by imm8 and write out the result and zero out destination elements in xmm1 as indicated in imm8."
  },
  {
    "opcode": "CC",
    "name": "INT3",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Generate breakpoint trap."
  },
  {
    "opcode": "CD ib",
    "name": "INT",
    "operands": [
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Generate software interrupt with vector specified by immediate byte."
  },
  {
    "opcode": "CE",
    "name": "INTO",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Generate overflow trap if overflow flag is 1."
  },
  {
    "opcode": "F1",
    "name": "INT1",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Generate debug trap."
  },
  {
    "opcode": "0F 08",
    "name": "INVD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Flush internal caches; initiate flushing of external caches."
  },
  {
    "opcode": "0F 01/7",
    "name": "INVLPG",
    "operands": [
      {
        "type": "m",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Invalidate TLB entries for page containing m."
  },
  {
    "opcode": "66 0F 38 82 /r",
    "name": "INVPCID",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "ne",
    "support32": "v",
    "flag": "INVPCID",
    "desc": "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r32 and descriptor in m128."
  },
  {
    "opcode": "66 0F 38 82 /r",
    "name": "INVPCID",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "ne",
    "flag": "INVPCID",
    "desc": "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128."
  },
  {
    "opcode": "CF",
    "name": "IRET",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Interrupt return (16-bit operand size)."
  },
  {
    "opcode": "CF",
    "name": "IRETD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Interrupt return (32-bit operand size)."
  },
  {
    "opcode": "REX.W + CF",
    "name": "IRETQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Interrupt return (64-bit operand size)."
  },
  {
    "opcode": "EB cb",
    "name": "JMP",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits"
  },
  {
    "opcode": "E9 cw",
    "name": "JMP",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode."
  },
  {
    "opcode": "E9 cd",
    "name": "JMP",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits"
  },
  {
    "opcode": "FF /4",
    "name": "JMP",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near, absolute indirect, address = zero-extended r/m16. Not supported in 64-bit mode."
  },
  {
    "opcode": "FF /4",
    "name": "JMP",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode."
  },
  {
    "opcode": "FF /4",
    "name": "JMP",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Jump near, absolute indirect, RIP = 64-Bit offset from register or memory"
  },
  {
    "opcode": "EA cd",
    "name": "JMP",
    "operands": [
      {
        "type": "ptr16:16",
        "encoding": "Offset"
      }
    ],
    "support64": "inv.",
    "compatibility": "valid",
    "desc": "Jump far, absolute, address given in operand"
  },
  {
    "opcode": "EA cp",
    "name": "JMP",
    "operands": [
      {
        "type": "ptr16:32",
        "encoding": "Offset"
      }
    ],
    "support64": "inv.",
    "compatibility": "valid",
    "desc": "Jump far, absolute, address given in operand"
  },
  {
    "opcode": "FF /5",
    "name": "JMP",
    "operands": [
      {
        "type": "m16:16",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump far, absolute indirect, address given in m16:16"
  },
  {
    "opcode": "FF /5",
    "name": "JMP",
    "operands": [
      {
        "type": "m16:32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump far, absolute indirect, address given in m16:32."
  },
  {
    "opcode": "REX.W FF /5",
    "name": "JMP",
    "operands": [
      {
        "type": "m16:64",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Jump far, absolute indirect, address given in m16:64."
  },
  {
    "opcode": "77 cb",
    "name": "JA",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if above (CF=0 and ZF=0)."
  },
  {
    "opcode": "73 cb",
    "name": "JAE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if above or equal (CF=0)."
  },
  {
    "opcode": "72 cb",
    "name": "JB",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if below (CF=1)."
  },
  {
    "opcode": "76 cb",
    "name": "JBE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if below or equal (CF=1 or ZF=1)."
  },
  {
    "opcode": "72 cb",
    "name": "JC",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if carry (CF=1)."
  },
  {
    "opcode": "E3 cb",
    "name": "JCXZ",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Jump short if CX register is 0."
  },
  {
    "opcode": "E3 cb",
    "name": "JECXZ",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if ECX register is 0."
  },
  {
    "opcode": "E3 cb",
    "name": "JRCXZ",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Jump short if RCX register is 0."
  },
  {
    "opcode": "74 cb",
    "name": "JE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if equal (ZF=1)."
  },
  {
    "opcode": "7F cb",
    "name": "JG",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if greater (ZF=0 and SF=OF)."
  },
  {
    "opcode": "7D cb",
    "name": "JGE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if greater or equal (SF=OF)."
  },
  {
    "opcode": "7C cb",
    "name": "JL",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if less (SF= OF)."
  },
  {
    "opcode": "7E cb",
    "name": "JLE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if less or equal (ZF=1 or SF= OF)."
  },
  {
    "opcode": "76 cb",
    "name": "JNA",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not above (CF=1 or ZF=1)."
  },
  {
    "opcode": "72 cb",
    "name": "JNAE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not above or equal (CF=1)."
  },
  {
    "opcode": "73 cb",
    "name": "JNB",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not below (CF=0)."
  },
  {
    "opcode": "77 cb",
    "name": "JNBE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not below or equal (CF=0 and ZF=0)."
  },
  {
    "opcode": "73 cb",
    "name": "JNC",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not carry (CF=0)."
  },
  {
    "opcode": "75 cb",
    "name": "JNE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not equal (ZF=0)."
  },
  {
    "opcode": "7E cb",
    "name": "JNG",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not greater (ZF=1 or SF= OF)."
  },
  {
    "opcode": "7C cb",
    "name": "JNGE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not greater or equal (SF= OF)."
  },
  {
    "opcode": "7D cb",
    "name": "JNL",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not less (SF=OF)."
  },
  {
    "opcode": "7F cb",
    "name": "JNLE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not less or equal (ZF=0 and SF=OF)."
  },
  {
    "opcode": "71 cb",
    "name": "JNO",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not overflow (OF=0)."
  },
  {
    "opcode": "7B cb",
    "name": "JNP",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not parity (PF=0)."
  },
  {
    "opcode": "79 cb",
    "name": "JNS",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not sign (SF=0)."
  },
  {
    "opcode": "75 cb",
    "name": "JNZ",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if not zero (ZF=0)."
  },
  {
    "opcode": "70 cb",
    "name": "JO",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if overflow (OF=1)."
  },
  {
    "opcode": "7A cb",
    "name": "JP",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if parity (PF=1)."
  },
  {
    "opcode": "7A cb",
    "name": "JPE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if parity even (PF=1)."
  },
  {
    "opcode": "7B cb",
    "name": "JPO",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if parity odd (PF=0)."
  },
  {
    "opcode": "78 cb",
    "name": "JS",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if sign (SF=1)."
  },
  {
    "opcode": "74 cb",
    "name": "JZ",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump short if zero (ZF = 1)."
  },
  {
    "opcode": "0F 87 cw",
    "name": "JA",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if above (CF=0 and ZF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 87 cd",
    "name": "JA",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if above (CF=0 and ZF=0)."
  },
  {
    "opcode": "0F 83 cw",
    "name": "JAE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if above or equal (CF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 83 cd",
    "name": "JAE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if above or equal (CF=0)."
  },
  {
    "opcode": "0F 82 cw",
    "name": "JB",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if below (CF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 82 cd",
    "name": "JB",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if below (CF=1)."
  },
  {
    "opcode": "0F 86 cw",
    "name": "JBE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if below or equal (CF=1 or ZF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 86 cd",
    "name": "JBE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if below or equal (CF=1 or ZF=1)."
  },
  {
    "opcode": "0F 82 cw",
    "name": "JC",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if carry (CF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 82 cd",
    "name": "JC",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if carry (CF=1)."
  },
  {
    "opcode": "0F 84 cw",
    "name": "JE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if equal (ZF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 84 cd",
    "name": "JE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if equal (ZF=1)."
  },
  {
    "opcode": "0F 84 cw",
    "name": "JZ",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if 0 (ZF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 84 cd",
    "name": "JZ",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if 0 (ZF=1)."
  },
  {
    "opcode": "0F 8F cw",
    "name": "JG",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if greater (ZF=0 and SF=OF). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8F cd",
    "name": "JG",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if greater (ZF=0 and SF=OF)."
  },
  {
    "opcode": "0F 8D cw",
    "name": "JGE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if greater or equal (SF=OF). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8D cd",
    "name": "JGE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if greater or equal (SF=OF)."
  },
  {
    "opcode": "0F 8C cw",
    "name": "JL",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if less (SF= OF). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8C cd",
    "name": "JL",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if less (SF= OF)."
  },
  {
    "opcode": "0F 8E cw",
    "name": "JLE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if less or equal (ZF=1 or SF= OF). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8E cd",
    "name": "JLE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if less or equal (ZF=1 or SF= OF)."
  },
  {
    "opcode": "0F 86 cw",
    "name": "JNA",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not above (CF=1 or ZF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 86 cd",
    "name": "JNA",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not above (CF=1 or ZF=1)."
  },
  {
    "opcode": "0F 82 cw",
    "name": "JNAE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not above or equal (CF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 82 cd",
    "name": "JNAE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not above or equal (CF=1)."
  },
  {
    "opcode": "0F 83 cw",
    "name": "JNB",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not below (CF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 83 cd",
    "name": "JNB",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not below (CF=0)."
  },
  {
    "opcode": "0F 87 cw",
    "name": "JNBE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not below or equal (CF=0 and ZF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 87 cd",
    "name": "JNBE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not below or equal (CF=0 and ZF=0)."
  },
  {
    "opcode": "0F 83 cw",
    "name": "JNC",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not carry (CF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 83 cd",
    "name": "JNC",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not carry (CF=0)."
  },
  {
    "opcode": "0F 85 cw",
    "name": "JNE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not equal (ZF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 85 cd",
    "name": "JNE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not equal (ZF=0)."
  },
  {
    "opcode": "0F 8E cw",
    "name": "JNG",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not greater (ZF=1 or SF= OF). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8E cd",
    "name": "JNG",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not greater (ZF=1 or SF= OF)."
  },
  {
    "opcode": "0F 8C cw",
    "name": "JNGE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not greater or equal (SF= OF). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8C cd",
    "name": "JNGE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not greater or equal (SF= OF)."
  },
  {
    "opcode": "0F 8D cw",
    "name": "JNL",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not less (SF=OF). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8D cd",
    "name": "JNL",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not less (SF=OF)."
  },
  {
    "opcode": "0F 8F cw",
    "name": "JNLE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not less or equal (ZF=0 and SF=OF). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8F cd",
    "name": "JNLE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not less or equal (ZF=0 and SF=OF)."
  },
  {
    "opcode": "0F 81 cw",
    "name": "JNO",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not overflow (OF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 81 cd",
    "name": "JNO",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not overflow (OF=0)."
  },
  {
    "opcode": "0F 8B cw",
    "name": "JNP",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not parity (PF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8B cd",
    "name": "JNP",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not parity (PF=0)."
  },
  {
    "opcode": "0F 89 cw",
    "name": "JNS",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not sign (SF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 89 cd",
    "name": "JNS",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not sign (SF=0)."
  },
  {
    "opcode": "0F 85 cw",
    "name": "JNZ",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if not zero (ZF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 85 cd",
    "name": "JNZ",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if not zero (ZF=0)."
  },
  {
    "opcode": "0F 80 cw",
    "name": "JO",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if overflow (OF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 80 cd",
    "name": "JO",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if overflow (OF=1)."
  },
  {
    "opcode": "0F 8A cw",
    "name": "JP",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if parity (PF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8A cd",
    "name": "JP",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if parity (PF=1)."
  },
  {
    "opcode": "0F 8A cw",
    "name": "JPE",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if parity even (PF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8A cd",
    "name": "JPE",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if parity even (PF=1)."
  },
  {
    "opcode": "0F 8B cw",
    "name": "JPO",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if parity odd (PF=0). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 8B cd",
    "name": "JPO",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if parity odd (PF=0)."
  },
  {
    "opcode": "0F 88 cw",
    "name": "JS",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if sign (SF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 88 cd",
    "name": "JS",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if sign (SF=1)."
  },
  {
    "opcode": "0F 84 cw",
    "name": "JZ",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "n.s.",
    "compatibility": "valid",
    "desc": "Jump near if 0 (ZF=1). Not supported in 64-bit mode."
  },
  {
    "opcode": "0F 84 cd",
    "name": "JZ",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Jump near if 0 (ZF=1)."
  },
  {
    "opcode": "VEX.L1.0F.W0 4A /r",
    "name": "KADDW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Add 16 bits masks in k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W0 4A /r",
    "name": "KADDB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Add 8 bits masks in k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W1 4A /r",
    "name": "KADDQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Add 64 bits masks in k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W1 4A /r",
    "name": "KADDD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Add 32 bits masks in k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W0 42 /r",
    "name": "KANDNW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise AND NOT 16 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W0 42 /r",
    "name": "KANDNB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Bitwise AND NOT 8 bits masks k1 and k2 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W1 42 /r",
    "name": "KANDNQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise AND NOT 64 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W1 42 /r",
    "name": "KANDND",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise AND NOT 32 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W0 41 /r",
    "name": "KANDW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise AND 16 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W0 41 /r",
    "name": "KANDB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Bitwise AND 8 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W1 41 /r",
    "name": "KANDQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise AND 64 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W1 41 /r",
    "name": "KANDD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise AND 32 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L0.0F.W0 90 /r",
    "name": "KMOVW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move 16 bits mask from k2/m16 and store the result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F.W0 90 /r",
    "name": "KMOVB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Move 8 bits mask from k2/m8 and store the result in k1."
  },
  {
    "opcode": "VEX.L0.0F.W1 90 /r",
    "name": "KMOVQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move 64 bits mask from k2/m64 and store the result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F.W1 90 /r",
    "name": "KMOVD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move 32 bits mask from k2/m32 and store the result in k1."
  },
  {
    "opcode": "VEX.L0.0F.W0 91 /r",
    "name": "KMOVW",
    "operands": [
      {
        "type": "m16",
        "encoding": "ModRM:r/m (w, ModRM:[7:6] must not be 11b)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move 16 bits mask from k1 and store the result in m16."
  },
  {
    "opcode": "VEX.L0.66.0F.W0 91 /r",
    "name": "KMOVB",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (w, ModRM:[7:6] must not be 11b)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Move 8 bits mask from k1 and store the result in m8."
  },
  {
    "opcode": "VEX.L0.0F.W1 91 /r",
    "name": "KMOVQ",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w, ModRM:[7:6] must not be 11b)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move 64 bits mask from k1 and store the result in m64."
  },
  {
    "opcode": "VEX.L0.66.0F.W1 91 /r",
    "name": "KMOVD",
    "operands": [
      {
        "type": "m32",
        "encoding": "ModRM:r/m (w, ModRM:[7:6] must not be 11b)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move 32 bits mask from k1 and store the result in m32."
  },
  {
    "opcode": "VEX.L0.0F.W0 92 /r",
    "name": "KMOVW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move 16 bits mask from r32 to k1."
  },
  {
    "opcode": "VEX.L0.66.0F.W0 92 /r",
    "name": "KMOVB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Move 8 bits mask from r32 to k1."
  },
  {
    "opcode": "VEX.L0.F2.0F.W1 92 /r",
    "name": "KMOVQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "AVX512BW",
    "desc": "Move 64 bits mask from r64 to k1."
  },
  {
    "opcode": "VEX.L0.F2.0F.W0 92 /r",
    "name": "KMOVD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move 32 bits mask from r32 to k1."
  },
  {
    "opcode": "VEX.L0.0F.W0 93 /r",
    "name": "KMOVW",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move 16 bits mask from k1 to r32."
  },
  {
    "opcode": "VEX.L0.66.0F.W0 93 /r",
    "name": "KMOVB",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Move 8 bits mask from k1 to r32."
  },
  {
    "opcode": "VEX.L0.F2.0F.W1 93 /r",
    "name": "KMOVQ",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "AVX512BW",
    "desc": "Move 64 bits mask from k1 to r64."
  },
  {
    "opcode": "VEX.L0.F2.0F.W0 93 /r",
    "name": "KMOVD",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move 32 bits mask from k1 to r32."
  },
  {
    "opcode": "VEX.L0.0F.W0 44 /r",
    "name": "KNOTW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise NOT of 16 bits mask k2."
  },
  {
    "opcode": "VEX.L0.66.0F.W0 44 /r",
    "name": "KNOTB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Bitwise NOT of 8 bits mask k2."
  },
  {
    "opcode": "VEX.L0.0F.W1 44 /r",
    "name": "KNOTQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise NOT of 64 bits mask k2."
  },
  {
    "opcode": "VEX.L0.66.0F.W1 44 /r",
    "name": "KNOTD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise NOT of 32 bits mask k2."
  },
  {
    "opcode": "VEX.L0.0F.W0 98 /r",
    "name": "KORTESTW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise OR 16 bits masks k1 and k2 and update ZF and CF accordingly."
  },
  {
    "opcode": "VEX.L0.66.0F.W0 98 /r",
    "name": "KORTESTB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Bitwise OR 8 bits masks k1 and k2 and update ZF and CF accordingly."
  },
  {
    "opcode": "VEX.L0.0F.W1 98 /r",
    "name": "KORTESTQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise OR 64 bits masks k1 and k2 and update ZF and CF accordingly."
  },
  {
    "opcode": "VEX.L0.66.0F.W1 98 /r",
    "name": "KORTESTD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise OR 32 bits masks k1 and k2 and update ZF and CF accordingly."
  },
  {
    "opcode": "VEX.L1.0F.W0 45 /r",
    "name": "KORW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise OR 16 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W0 45 /r",
    "name": "KORB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Bitwise OR 8 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W1 45 /r",
    "name": "KORQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise OR 64 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W1 45 /r",
    "name": "KORD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise OR 32 bits masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F3A.W1 32 /r",
    "name": "KSHIFTLW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift left 16 bits in k2 by immediate and write result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F3A.W0 32 /r",
    "name": "KSHIFTLB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Shift left 8 bits in k2 by immediate and write result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F3A.W1 33 /r",
    "name": "KSHIFTLQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift left 64 bits in k2 by immediate and write result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F3A.W0 33 /r",
    "name": "KSHIFTLD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift left 32 bits in k2 by immediate and write result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F3A.W1 30 /r",
    "name": "KSHIFTRW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift right 16 bits in k2 by immediate and write result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F3A.W0 30 /r",
    "name": "KSHIFTRB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Shift right 8 bits in k2 by immediate and write result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F3A.W1 31 /r",
    "name": "KSHIFTRQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift right 64 bits in k2 by immediate and write result in k1."
  },
  {
    "opcode": "VEX.L0.66.0F3A.W0 31 /r",
    "name": "KSHIFTRD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift right 32 bits in k2 by immediate and write result in k1."
  },
  {
    "opcode": "VEX.L0.0F.W0 99 /r",
    "name": "KTESTW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Set ZF and CF depending on sign bit AND and ANDN of 16 bits mask register sources."
  },
  {
    "opcode": "VEX.L0.66.0F.W0 99 /r",
    "name": "KTESTB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Set ZF and CF depending on sign bit AND and ANDN of 8 bits mask register sources."
  },
  {
    "opcode": "VEX.L0.0F.W1 99 /r",
    "name": "KTESTQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Set ZF and CF depending on sign bit AND and ANDN of 64 bits mask register sources."
  },
  {
    "opcode": "VEX.L0.66.0F.W1 99 /r",
    "name": "KTESTD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "k2",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Set ZF and CF depending on sign bit AND and ANDN of 32 bits mask register sources."
  },
  {
    "opcode": "VEX.L1.66.0F.W0 4B /r",
    "name": "KUNPCKBW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Unpack 8-bit masks in k2 and k3 and write word result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W0 4B /r",
    "name": "KUNPCKWD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Unpack 16-bit masks in k2 and k3 and write doubleword result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W1 4B /r",
    "name": "KUNPCKDQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Unpack 32-bit masks in k2 and k3 and write quadword result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W0 46 /r",
    "name": "KXNORW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise XNOR 16-bit masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W0 46 /r",
    "name": "KXNORB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Bitwise XNOR 8-bit masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W1 46 /r",
    "name": "KXNORQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise XNOR 64-bit masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W1 46 /r",
    "name": "KXNORD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise XNOR 32-bit masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W0 47 /r",
    "name": "KXORW",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise XOR 16-bit masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W0 47 /r",
    "name": "KXORB",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Bitwise XOR 8-bit masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.0F.W1 47 /r",
    "name": "KXORQ",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise XOR 64-bit masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "VEX.L1.66.0F.W1 47 /r",
    "name": "KXORD",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k2",
        "encoding": "VEX.1vvv (r)"
      },
      {
        "type": "k3",
        "encoding": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise XOR 32-bit masks k2 and k3 and place result in k1."
  },
  {
    "opcode": "0F 02 /r",
    "name": "LAR",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r16/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r16  access rights referenced by r16/m16"
  },
  {
    "opcode": "0F 02 /r",
    "name": "LAR",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m161",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "reg  access rights referenced by r32/m16"
  },
  {
    "opcode": "F2 0F F0 /r",
    "name": "LDDQU",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mem",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Load unaligned data from mem and return double quadword in xmm1."
  },
  {
    "opcode": "VEX.128.F2.0F.WIG F0 /r V",
    "name": "LDDQU",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Load unaligned packed integer values from mem to xmm1."
  },
  {
    "opcode": "VEX.256.F2.0F.WIG F0 /r V",
    "name": "LDDQU",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Load unaligned packed integer values from mem to ymm1."
  },
  {
    "opcode": "NP 0F AE /2",
    "name": "LDMXCSR",
    "operands": [
      {
        "type": "m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Load MXCSR register from m32."
  },
  {
    "opcode": "VEX.LZ.0F.WIG AE /2 V",
    "name": "LDMXCSR",
    "operands": [
      {
        "type": "m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Load MXCSR register from m32."
  },
  {
    "opcode": "C5 /r",
    "name": "LDS",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Load DS:r16 with far pointer from memory."
  },
  {
    "opcode": "C5 /r",
    "name": "LDS",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Load DS:r32 with far pointer from memory."
  },
  {
    "opcode": "0F B2 /r",
    "name": "LSS",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load SS:r16 with far pointer from memory."
  },
  {
    "opcode": "0F B2 /r",
    "name": "LSS",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load SS:r32 with far pointer from memory."
  },
  {
    "opcode": "REX + 0F B2 /r",
    "name": "LSS",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load SS:r64 with far pointer from memory."
  },
  {
    "opcode": "C4 /r",
    "name": "LES",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Load ES:r16 with far pointer from memory."
  },
  {
    "opcode": "C4 /r",
    "name": "LES",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Load ES:r32 with far pointer from memory."
  },
  {
    "opcode": "0F B4 /r",
    "name": "LFS",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load FS:r16 with far pointer from memory."
  },
  {
    "opcode": "0F B4 /r",
    "name": "LFS",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load FS:r32 with far pointer from memory."
  },
  {
    "opcode": "REX + 0F B4 /r",
    "name": "LFS",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load FS:r64 with far pointer from memory."
  },
  {
    "opcode": "0F B5 /r",
    "name": "LGS",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load GS:r16 with far pointer from memory."
  },
  {
    "opcode": "0F B5 /r",
    "name": "LGS",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load GS:r32 with far pointer from memory."
  },
  {
    "opcode": "REX + 0F B5 /r",
    "name": "LGS",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m16:64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load GS:r64 with far pointer from memory."
  },
  {
    "opcode": "8D /r",
    "name": "LEA",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store effective address for m in register r16."
  },
  {
    "opcode": "8D /r",
    "name": "LEA",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store effective address for m in register r32."
  },
  {
    "opcode": "REX.W + 8D /r",
    "name": "LEA",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store effective address for m in register r64."
  },
  {
    "opcode": "C9",
    "name": "LEAVE",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set SP to BP, then pop BP."
  },
  {
    "opcode": "C9",
    "name": "LEAVE",
    "operands": [],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Set ESP to EBP, then pop EBP."
  },
  {
    "opcode": "C9",
    "name": "LEAVE",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set RSP to RBP, then pop RBP."
  },
  {
    "opcode": "NP 0F AE E8",
    "name": "LFENCE",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Serializes load operations."
  },
  {
    "opcode": "0F 01 /2",
    "name": "LGDT",
    "operands": [
      {
        "type": "m16&32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Load m into GDTR."
  },
  {
    "opcode": "0F 01 /3",
    "name": "LIDT",
    "operands": [
      {
        "type": "m16&32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Load m into IDTR."
  },
  {
    "opcode": "0F 01 /2",
    "name": "LGDT",
    "operands": [
      {
        "type": "m16&64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load m into GDTR."
  },
  {
    "opcode": "0F 01 /3",
    "name": "LIDT",
    "operands": [
      {
        "type": "m16&64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load m into IDTR."
  },
  {
    "opcode": "0F 00 /2",
    "name": "LLDT",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load segment selector r/m16 into LDTR."
  },
  {
    "opcode": "0F 01 /6",
    "name": "LMSW",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Loads r/m16 in machine status word of CR0."
  },
  {
    "opcode": "F0",
    "name": "LOCK",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Asserts LOCK# signal for duration of the accompanying instruction."
  },
  {
    "opcode": "AC",
    "name": "LODS",
    "operands": [
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
  },
  {
    "opcode": "AD",
    "name": "LODS",
    "operands": [
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
  },
  {
    "opcode": "AD",
    "name": "LODS",
    "operands": [
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
  },
  {
    "opcode": "REX.W + AD",
    "name": "LODS",
    "operands": [
      {
        "type": "m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load qword at address (R)SI into RAX."
  },
  {
    "opcode": "AC",
    "name": "LODSB",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
  },
  {
    "opcode": "AD",
    "name": "LODSW",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
  },
  {
    "opcode": "AD",
    "name": "LODSD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
  },
  {
    "opcode": "REX.W + AD",
    "name": "LODSQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load qword at address (R)SI into RAX."
  },
  {
    "opcode": "E2 cb",
    "name": "LOOP",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Decrement count; jump short if count = 0."
  },
  {
    "opcode": "E1 cb",
    "name": "LOOPE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Decrement count; jump short if count = 0 and ZF = 1."
  },
  {
    "opcode": "E0 cb",
    "name": "LOOPNE",
    "operands": [
      {
        "type": "rel8",
        "encoding": "Offset"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Decrement count; jump short if count = 0 and ZF = 0."
  },
  {
    "opcode": "0F 03 /r",
    "name": "LSL",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r16/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load: r16  segment limit, selector r16/m16."
  },
  {
    "opcode": "0F 03 /r",
    "name": "LSL",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m16*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load: r32  segment limit, selector r32/m16."
  },
  {
    "opcode": "REX.W + 0F 03 /r",
    "name": "LSL",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m16*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load: r64  segment limit, selector r32/m16"
  },
  {
    "opcode": "0F 00 /3",
    "name": "LTR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load r/m16 into task register."
  },
  {
    "opcode": "F3 0F BD /r",
    "name": "LZCNT",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "LZCNT",
    "desc": "Count the number of leading zero bits in r/m16, return result in r16."
  },
  {
    "opcode": "F3 0F BD /r",
    "name": "LZCNT",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "LZCNT",
    "desc": "Count the number of leading zero bits in r/m32, return result in r32."
  },
  {
    "opcode": "F3 REX.W 0F BD /r",
    "name": "LZCNT",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "LZCNT",
    "desc": "Count the number of leading zero bits in r/m64, return result in r64."
  },
  {
    "opcode": "66 0F F7 /r",
    "name": "MASKMOVDQU",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F7 /r V",
    "name": "MASKMOVDQU",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
  },
  {
    "opcode": "NP 0F F7 /r",
    "name": "MASKMOVQ",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "mm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI."
  },
  {
    "opcode": "66 0F 5F /r",
    "name": "MAXPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Return the maximum double-precision floating-point values between xmm1 and xmm2/m128."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 5F /r V",
    "name": "MAXPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the maximum double-precision floating-point values between xmm2 and xmm3/m128."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 5F /r V",
    "name": "MAXPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the maximum packed double-precision floating-point values between ymm2 and ymm3/m256."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 5F /r V",
    "name": "MAXPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Return the maximum packed double-precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 5F /r V",
    "name": "MAXPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Return the maximum packed double-precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 5F /r V",
    "name": "MAXPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Return the maximum packed double-precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "NP 0F 5F /r",
    "name": "MAXPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Return the maximum single-precision floating-point values between xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F.WIG 5F /r V",
    "name": "MAXPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the maximum single-precision floating-point values between xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.0F.WIG 5F /r V",
    "name": "MAXPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the maximum single-precision floating-point values between ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 5F /r V",
    "name": "MAXPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Return the maximum packed single-precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 5F /r V",
    "name": "MAXPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Return the maximum packed single-precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 5F /r V",
    "name": "MAXPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Return the maximum packed single-precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "F2 0F 5F /r",
    "name": "MAXSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Return the maximum scalar double-precision floating-point value between xmm2/m64 and xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 5F /r V",
    "name": "MAXSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the maximum scalar double-precision floating-point value between xmm3/m64 and xmm2."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 5F /r V",
    "name": "MAXSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Return the maximum scalar double-precision floating-point value between xmm3/m64 and xmm2."
  },
  {
    "opcode": "F3 0F 5F /r",
    "name": "MAXSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Return the maximum scalar single-precision floating-point value between xmm2/m32 and xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 5F /r V",
    "name": "MAXSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the maximum scalar single-precision floating-point value between xmm3/m32 and xmm2."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 5F /r V",
    "name": "MAXSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Return the maximum scalar single-precision floating-point value between xmm3/m32 and xmm2."
  },
  {
    "opcode": "66 0F 5D /r",
    "name": "MINPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Return the minimum double-precision floating-point values between xmm1 and xmm2/mem"
  },
  {
    "opcode": "VEX.128.66.0F.WIG 5D /r V",
    "name": "MINPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the minimum double-precision floating-point values between xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 5D /r V",
    "name": "MINPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 5D /r V",
    "name": "MINPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Return the minimum packed double-precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 5D /r V",
    "name": "MINPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Return the minimum packed double-precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 5D /r V",
    "name": "MINPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Return the minimum packed double-precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "NP 0F 5D /r",
    "name": "MINPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Return the minimum single-precision floating-point values between xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F.WIG 5D /r V",
    "name": "MINPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the minimum single-precision floating-point values between xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.0F.WIG 5D /r V",
    "name": "MINPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 5D /r V",
    "name": "MINPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Return the minimum packed single-precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 5D /r V",
    "name": "MINPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Return the minimum packed single-precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 5D /r V",
    "name": "MINPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Return the minimum packed single-precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "F2 0F 5D /r",
    "name": "MINSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Return the minimum scalar double-precision floating-point value between xmm2/m64 and xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 5D /r V",
    "name": "MINSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the minimum scalar double-precision floating-point value between xmm3/m64 and xmm2."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 5D /r V",
    "name": "MINSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Return the minimum scalar double-precision floating-point value between xmm3/m64 and xmm2."
  },
  {
    "opcode": "F3 0F 5D /r",
    "name": "MINSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Return the minimum scalar single-precision floating-point value between xmm2/m32 and xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 5D /r V",
    "name": "MINSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the minimum scalar single-precision floating-point value between xmm3/m32 and xmm2."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 5D /r V",
    "name": "MINSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Return the minimum scalar single-precision floating-point value between xmm3/m32 and xmm2."
  },
  {
    "opcode": "88 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move r8 to r/m8."
  },
  {
    "opcode": "REX + 88 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m8***",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r8***",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move r8 to r/m8."
  },
  {
    "opcode": "89 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move r16 to r/m16."
  },
  {
    "opcode": "89 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move r32 to r/m32."
  },
  {
    "opcode": "REX.W + 89 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move r64 to r/m64."
  },
  {
    "opcode": "8A /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move r/m8 to r8."
  },
  {
    "opcode": "REX + 8A /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r8***",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8***",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move r/m8 to r8."
  },
  {
    "opcode": "8B /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move r/m16 to r16."
  },
  {
    "opcode": "8B /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move r/m32 to r32."
  },
  {
    "opcode": "REX.W + 8B /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move r/m64 to r64."
  },
  {
    "opcode": "8C /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "Sreg**",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move segment register to r/m16."
  },
  {
    "opcode": "REX.W + 8C /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r16/r32/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "Sreg**",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move zero extended 16-bit segment register to r16/r32/r64/m16."
  },
  {
    "opcode": "REX.W + 8C /r",
    "name": "MOV",
    "operands": [
      {
        "type": "r64/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "Sreg**",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move zero extended 16-bit segment register to r64/m16."
  },
  {
    "opcode": "8E /r",
    "name": "MOV",
    "operands": [
      {
        "type": "Sreg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16**",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move r/m16 to segment register."
  },
  {
    "opcode": "REX.W + 8E /r",
    "name": "MOV",
    "operands": [
      {
        "type": "Sreg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64**",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move lower 16 bits of r/m64 to segment register."
  },
  {
    "opcode": "A0",
    "name": "MOV",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "moffs8*",
        "encoding": "Moffs"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move byte at (seg:offset) to AL."
  },
  {
    "opcode": "REX.W + A0",
    "name": "MOV",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "moffs8*",
        "encoding": "Moffs"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move byte at (offset) to AL."
  },
  {
    "opcode": "A1",
    "name": "MOV",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "moffs16*",
        "encoding": "Moffs"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move word at (seg:offset) to AX."
  },
  {
    "opcode": "A1",
    "name": "MOV",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "moffs32*",
        "encoding": "Moffs"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move doubleword at (seg:offset) to EAX."
  },
  {
    "opcode": "REX.W + A1",
    "name": "MOV",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "moffs64*",
        "encoding": "Moffs"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move quadword at (offset) to RAX."
  },
  {
    "opcode": "A2",
    "name": "MOV",
    "operands": [
      {
        "type": "moffs8",
        "encoding": "Moffs (w)"
      },
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move AL to (seg:offset)."
  },
  {
    "opcode": "REX.W + A2",
    "name": "MOV",
    "operands": [
      {
        "type": "moffs8***",
        "encoding": "Moffs (w)"
      },
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move AL to (offset)."
  },
  {
    "opcode": "A3",
    "name": "MOV",
    "operands": [
      {
        "type": "moffs16*",
        "encoding": "Moffs (w)"
      },
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move AX to (seg:offset)."
  },
  {
    "opcode": "A3",
    "name": "MOV",
    "operands": [
      {
        "type": "moffs32*",
        "encoding": "Moffs (w)"
      },
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move EAX to (seg:offset)."
  },
  {
    "opcode": "REX.W + A3",
    "name": "MOV",
    "operands": [
      {
        "type": "moffs64*",
        "encoding": "Moffs (w)"
      },
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move RAX to (offset)."
  },
  {
    "opcode": "B0+ rb ib",
    "name": "MOV",
    "operands": [
      {
        "type": "r8",
        "encoding": "opcode + rd (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move imm8 to r8."
  },
  {
    "opcode": "REX + B0+ rb ib",
    "name": "MOV",
    "operands": [
      {
        "type": "r8***",
        "encoding": "opcode + rd (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move imm8 to r8."
  },
  {
    "opcode": "B8+ rw iw",
    "name": "MOV",
    "operands": [
      {
        "type": "r16",
        "encoding": "opcode + rd (w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move imm16 to r16."
  },
  {
    "opcode": "B8+ rd id",
    "name": "MOV",
    "operands": [
      {
        "type": "r32",
        "encoding": "opcode + rd (w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move imm32 to r32."
  },
  {
    "opcode": "REX.W + B8+ rd io",
    "name": "MOV",
    "operands": [
      {
        "type": "r64",
        "encoding": "opcode + rd (w)"
      },
      {
        "type": "imm64",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move imm64 to r64."
  },
  {
    "opcode": "C6 /0 ib",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move imm8 to r/m8."
  },
  {
    "opcode": "REX + C6 /0 ib",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m8***",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move imm8 to r/m8."
  },
  {
    "opcode": "C7 /0 iw",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move imm16 to r/m16."
  },
  {
    "opcode": "C7 /0 id",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move imm32 to r/m32."
  },
  {
    "opcode": "REX.W + C7 /0 id",
    "name": "MOV",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32/64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move imm32 sign extended to 64-bits to r/m64."
  },
  {
    "opcode": "0F 20/r",
    "name": "MOV",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CR0CR7",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Move control register to r32."
  },
  {
    "opcode": "0F 20/r",
    "name": "MOV",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CR0CR7",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move extended control register to r64."
  },
  {
    "opcode": "REX.R + 0F 20 /0",
    "name": "MOV",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CR8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move extended CR8 to r64.1"
  },
  {
    "opcode": "0F 22 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "CR0CR7",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Move r32 to control register."
  },
  {
    "opcode": "0F 22 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "CR0CR7",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move r64 to extended control register."
  },
  {
    "opcode": "REX.R + 0F 22 /0",
    "name": "MOV",
    "operands": [
      {
        "type": "CR8",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move r64 to extended CR8.1"
  },
  {
    "opcode": "0F 21/r",
    "name": "MOV",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "DR0DR7",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Move debug register to r32."
  },
  {
    "opcode": "0F 21/r",
    "name": "MOV",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "DR0DR7",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move extended debug register to r64."
  },
  {
    "opcode": "0F 23 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "DR0DR7",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Move r32 to debug register."
  },
  {
    "opcode": "0F 23 /r",
    "name": "MOV",
    "operands": [
      {
        "type": "DR0DR7",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move r64 to extended debug register."
  },
  {
    "opcode": "66 0F 28 /r",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move aligned packed double-precision floating-point values from xmm2/mem to xmm1."
  },
  {
    "opcode": "66 0F 29 /r",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 28 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed double-precision floating-point values from xmm2/mem to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 29 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 28 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed double-precision floating-point values from ymm2/mem to ymm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 29 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed double-precision floating-point values from ymm1 to ymm2/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 28 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed double-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 28 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed double-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 28 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move aligned packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 29 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed double-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 29 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed double-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 29 /r V",
    "name": "MOVAPD",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move aligned packed double-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "NP 0F 28 /r",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
  },
  {
    "opcode": "NP 0F 29 /r",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F.WIG 28 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 29 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.256.0F.WIG 28 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed single-precision floating-point values from ymm2/mem to ymm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 29 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 28 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 28 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 28 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move aligned packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.0F.W0 29 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed single-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 29 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed single-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 29 /r V",
    "name": "MOVAPS",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move aligned packed single-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "NP 0F 6E /r",
    "name": "MOVD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Move doubleword from r/m32 to mm."
  },
  {
    "opcode": "NP REX.W + 0F 6E /r",
    "name": "MOVQ",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "MMX",
    "desc": "Move quadword from r/m64 to mm."
  },
  {
    "opcode": "NP 0F 7E /r",
    "name": "MOVD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "mm",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Move doubleword from mm to r/m32."
  },
  {
    "opcode": "NP REX.W + 0F 7E /r",
    "name": "MOVQ",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "mm",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "MMX",
    "desc": "Move quadword from mm to r/m64."
  },
  {
    "opcode": "66 0F 6E /r",
    "name": "MOVD",
    "operands": [
      {
        "type": "xmm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move doubleword from r/m32 to xmm."
  },
  {
    "opcode": "66 REX.W 0F 6E /r",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE2",
    "desc": "Move quadword from r/m64 to xmm."
  },
  {
    "opcode": "66 0F 7E /r",
    "name": "MOVD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move doubleword from xmm register to r/m32."
  },
  {
    "opcode": "66 REX.W 0F 7E /r",
    "name": "MOVQ",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE2",
    "desc": "Move quadword from xmm register to r/m64."
  },
  {
    "opcode": "VEX.128.66.0F.W0 6E /r V",
    "name": "MOVD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move doubleword from r/m32 to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.W1 6E /r V",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e1.",
    "flag": "AVX",
    "desc": "Move quadword from r/m64 to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.W0 7E /r V",
    "name": "MOVD",
    "operands": [
      {
        "type": "r32/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move doubleword from xmm1 register to r/m32."
  },
  {
    "opcode": "VEX.128.66.0F.W1 7E /r V",
    "name": "MOVQ",
    "operands": [
      {
        "type": "r64/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e1.",
    "flag": "AVX",
    "desc": "Move quadword from xmm1 register to r/m64."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 6E /r V",
    "name": "MOVD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move doubleword from r/m32 to xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 6E /r V",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Move quadword from r/m64 to xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 7E /r V",
    "name": "MOVD",
    "operands": [
      {
        "type": "r32/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move doubleword from xmm1 register to r/m32."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 7E /r V",
    "name": "MOVQ",
    "operands": [
      {
        "type": "r64/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Move quadword from xmm1 register to r/m64."
  },
  {
    "opcode": "F2 0F 12 /r",
    "name": "MOVDDUP",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Move double-precision floating-point value from xmm2/m64 and duplicate into xmm1."
  },
  {
    "opcode": "VEX.128.F2.0F.WIG 12 /r V",
    "name": "MOVDDUP",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move double-precision floating-point value from xmm2/m64 and duplicate into xmm1."
  },
  {
    "opcode": "VEX.256.F2.0F.WIG 12 /r V",
    "name": "MOVDDUP",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
  },
  {
    "opcode": "EVEX.128.F2.0F.W1 12 /r V",
    "name": "MOVDDUP",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move double-precision floating-point value from xmm2/m64 and duplicate each element into xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.W1 12 /r V",
    "name": "MOVDDUP",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move even index double-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.W1 12 /r V",
    "name": "MOVDDUP",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move even index double-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 subject to writemask k1."
  },
  {
    "opcode": "66 0F 38 F8 /r",
    "name": "MOVDIR64B",
    "operands": [
      {
        "type": "r16/r32/r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MOVDIR64B",
    "desc": "Move 64-bytes as direct-store with guaranteed 64-byte write atomicity from the source memory operand address to destination memory address specified as offset to ES segment in the register operand."
  },
  {
    "opcode": "NP 0F 38 F9 /r",
    "name": "MOVDIRI",
    "operands": [
      {
        "type": "m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MOVDIRI",
    "desc": "Move doubleword from r32 to m32 using direct store."
  },
  {
    "opcode": "NP REX.W + 0F 38 F9 /r",
    "name": "MOVDIRI",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "MOVDIRI",
    "desc": "Move quadword from r64 to m64 using direct store."
  },
  {
    "opcode": "66 0F 6F /r",
    "name": "MOVDQA",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move aligned packed integer values from xmm2/mem to xmm1."
  },
  {
    "opcode": "66 0F 7F /r",
    "name": "MOVDQA",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move aligned packed integer values from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 6F /r V",
    "name": "MOVDQA",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed integer values from xmm2/mem to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 7F /r V",
    "name": "MOVDQA",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed integer values from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 6F /r V",
    "name": "MOVDQA",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed integer values from ymm2/mem to ymm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 7F /r V",
    "name": "MOVDQA",
    "operands": [
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move aligned packed integer values from ymm1 to ymm2/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 6F /r V",
    "name": "MOVDQA32",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 6F /r V",
    "name": "MOVDQA32",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 6F /r V",
    "name": "MOVDQA32",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move aligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 7F /r V",
    "name": "MOVDQA32",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 7F /r V",
    "name": "MOVDQA32",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 7F /r V",
    "name": "MOVDQA32",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move aligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 6F /r V",
    "name": "MOVDQA64",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned quadword integer values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 6F /r V",
    "name": "MOVDQA64",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned quadword integer values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 6F /r V",
    "name": "MOVDQA64",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move aligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 7F /r V",
    "name": "MOVDQA64",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 7F /r V",
    "name": "MOVDQA64",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move aligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 7F /r V",
    "name": "MOVDQA64",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move aligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "F3 0F 6F /r",
    "name": "MOVDQU",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move unaligned packed integer values from xmm2/m128 to xmm1."
  },
  {
    "opcode": "F3 0F 7F /r",
    "name": "MOVDQU",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move unaligned packed integer values from xmm1 to xmm2/m128."
  },
  {
    "opcode": "VEX.128.F3.0F.WIG 6F /r V",
    "name": "MOVDQU",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed integer values from xmm2/m128 to xmm1."
  },
  {
    "opcode": "VEX.128.F3.0F.WIG 7F /r V",
    "name": "MOVDQU",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed integer values from xmm1 to xmm2/m128."
  },
  {
    "opcode": "VEX.256.F3.0F.WIG 6F /r V",
    "name": "MOVDQU",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed integer values from ymm2/m256 to ymm1."
  },
  {
    "opcode": "VEX.256.F3.0F.WIG 7F /r V",
    "name": "MOVDQU",
    "operands": [
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed integer values from ymm1 to ymm2/m256."
  },
  {
    "opcode": "EVEX.128.F2.0F.W0 6F /r V",
    "name": "MOVDQU8",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Move unaligned packed byte integer values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.W0 6F /r V",
    "name": "MOVDQU8",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Move unaligned packed byte integer values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.W0 6F /r V",
    "name": "MOVDQU8",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move unaligned packed byte integer values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.F2.0F.W0 7F /r V",
    "name": "MOVDQU8",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Move unaligned packed byte integer values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.W0 7F /r V",
    "name": "MOVDQU8",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Move unaligned packed byte integer values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.W0 7F /r V",
    "name": "MOVDQU8",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move unaligned packed byte integer values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "EVEX.128.F2.0F.W1 6F /r V",
    "name": "MOVDQU16",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Move unaligned packed word integer values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.W1 6F /r V",
    "name": "MOVDQU16",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Move unaligned packed word integer values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.W1 6F /r V",
    "name": "MOVDQU16",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move unaligned packed word integer values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.F2.0F.W1 7F /r V",
    "name": "MOVDQU16",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Move unaligned packed word integer values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.W1 7F /r V",
    "name": "MOVDQU16",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Move unaligned packed word integer values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.W1 7F /r V",
    "name": "MOVDQU16",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Move unaligned packed word integer values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W0 6F /r V",
    "name": "MOVDQU32",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/mm128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W0 6F /r V",
    "name": "MOVDQU32",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W0 6F /r V",
    "name": "MOVDQU32",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move unaligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W0 7F /r V",
    "name": "MOVDQU32",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W0 7F /r V",
    "name": "MOVDQU32",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W0 7F /r V",
    "name": "MOVDQU32",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move unaligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W1 6F /r V",
    "name": "MOVDQU64",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed quadword integer values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W1 6F /r V",
    "name": "MOVDQU64",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed quadword integer values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W1 6F /r V",
    "name": "MOVDQU64",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move unaligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W1 7F /r V",
    "name": "MOVDQU64",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W1 7F /r V",
    "name": "MOVDQU64",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W1 7F /r V",
    "name": "MOVDQU64",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move unaligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "NP 0F 12 /r",
    "name": "MOVHLPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 12 /r V",
    "name": "MOVHLPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2."
  },
  {
    "opcode": "EVEX.128.0F.W0 12 /r V",
    "name": "MOVHLPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2."
  },
  {
    "opcode": "66 0F 16 /r",
    "name": "MOVHPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move double-precision floating-point value from m64 to high quadword of xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 16 /r V",
    "name": "MOVHPD",
    "operands": [
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge double-precision floating-point value from m64 and the low quadword of xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 16 /r V",
    "name": "MOVHPD",
    "operands": [
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Merge double-precision floating-point value from m64 and the low quadword of xmm1."
  },
  {
    "opcode": "66 0F 17 /r",
    "name": "MOVHPD",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move double-precision floating-point value from high quadword of xmm1 to m64."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 17 /r V",
    "name": "MOVHPD",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move double-precision floating-point value from high quadword of xmm1 to m64."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 17 /r V",
    "name": "MOVHPD",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move double-precision floating-point value from high quadword of xmm1 to m64."
  },
  {
    "opcode": "NP 0F 16 /r",
    "name": "MOVHPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move two packed single-precision floating-point values from m64 to high quadword of xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 16 /r V",
    "name": "MOVHPS",
    "operands": [
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 16 /r V",
    "name": "MOVHPS",
    "operands": [
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."
  },
  {
    "opcode": "NP 0F 17 /r",
    "name": "MOVHPS",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
  },
  {
    "opcode": "VEX.128.0F.WIG 17 /r V",
    "name": "MOVHPS",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
  },
  {
    "opcode": "EVEX.128.0F.W0 17 /r V",
    "name": "MOVHPS",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
  },
  {
    "opcode": "NP 0F 16 /r",
    "name": "MOVLHPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 16 /r V",
    "name": "MOVLHPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2."
  },
  {
    "opcode": "EVEX.128.0F.W0 16 /r V",
    "name": "MOVLHPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2."
  },
  {
    "opcode": "66 0F 12 /r",
    "name": "MOVLPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move double-precision floating-point value from m64 to low quadword of xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 12 /r V",
    "name": "MOVLPD",
    "operands": [
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge double-precision floating-point value from m64 and the high quadword of xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 12 /r V",
    "name": "MOVLPD",
    "operands": [
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Merge double-precision floating-point value from m64 and the high quadword of xmm1."
  },
  {
    "opcode": "66 0F 13/r",
    "name": "MOVLPD",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move double-precision floating-point value from low quadword of xmm1 to m64."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 13/r V",
    "name": "MOVLPD",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move double-precision floating-point value from low quadword of xmm1 to m64."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 13/r V",
    "name": "MOVLPD",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move double-precision floating-point value from low quadword of xmm1 to m64."
  },
  {
    "opcode": "NP 0F 12 /r",
    "name": "MOVLPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move two packed single-precision floating-point values from m64 to low quadword of xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 12 /r V",
    "name": "MOVLPS",
    "operands": [
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 12 /r V",
    "name": "MOVLPS",
    "operands": [
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."
  },
  {
    "opcode": "0F 13/r",
    "name": "MOVLPS",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
  },
  {
    "opcode": "VEX.128.0F.WIG 13/r V",
    "name": "MOVLPS",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
  },
  {
    "opcode": "EVEX.128.0F.W0 13/r V",
    "name": "MOVLPS",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
  },
  {
    "opcode": "66 0F 50 /r",
    "name": "MOVMSKPD",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 50 /r V",
    "name": "MOVMSKPD",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract 2-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 50 /r V",
    "name": "MOVMSKPD",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract 4-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed."
  },
  {
    "opcode": "NP 0F 50 /r",
    "name": "MOVMSKPS",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros."
  },
  {
    "opcode": "VEX.128.0F.WIG 50 /r V",
    "name": "MOVMSKPS",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract 4-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed."
  },
  {
    "opcode": "VEX.256.0F.WIG 50 /r V",
    "name": "MOVMSKPS",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract 8-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed."
  },
  {
    "opcode": "66 0F E7 /r",
    "name": "MOVNTDQ",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move packed integer values in xmm1 to m128 using non-temporal hint."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E7 /r V",
    "name": "MOVNTDQ",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move packed integer values in xmm1 to m128 using non-temporal hint."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E7 /r V",
    "name": "MOVNTDQ",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move packed integer values in ymm1 to m256 using non-temporal hint."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 E7 /r V",
    "name": "MOVNTDQ",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move packed integer values in xmm1 to m128 using non-temporal hint."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 E7 /r V",
    "name": "MOVNTDQ",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move packed integer values in zmm1 to m256 using non-temporal hint."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 E7 /r V",
    "name": "MOVNTDQ",
    "operands": [
      {
        "type": "m512",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move packed integer values in zmm1 to m512 using non-temporal hint."
  },
  {
    "opcode": "66 0F 38 2A /r",
    "name": "MOVNTDQA",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Move double quadword from m128 to xmm1 using non-temporal hint if WC memory type."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 2A /r V",
    "name": "MOVNTDQA",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move double quadword from m128 to xmm using non-temporal hint if WC memory type."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 2A /r V",
    "name": "MOVNTDQA",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 2A /r V",
    "name": "MOVNTDQA",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move 128-bit data from m128 to xmm using non-temporal hint if WC memory type."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 2A /r V",
    "name": "MOVNTDQA",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 2A /r V",
    "name": "MOVNTDQA",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move 512-bit data from m512 to zmm using non-temporal hint if WC memory type."
  },
  {
    "opcode": "NP 0F C3 /r",
    "name": "MOVNTI",
    "operands": [
      {
        "type": "m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move doubleword from r32 to m32 using non-temporal hint."
  },
  {
    "opcode": "NP REX.W + 0F C3 /r",
    "name": "MOVNTI",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move quadword from r64 to m64 using non-temporal hint."
  },
  {
    "opcode": "66 0F 2B /r",
    "name": "MOVNTPD",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 2B /r V",
    "name": "MOVNTPD",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 2B /r V",
    "name": "MOVNTPD",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move packed double-precision values in ymm1 to m256 using non-temporal hint."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 2B /r V",
    "name": "MOVNTPD",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 2B /r V",
    "name": "MOVNTPD",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move packed double-precision values in ymm1 to m256 using non-temporal hint."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 2B /r V",
    "name": "MOVNTPD",
    "operands": [
      {
        "type": "m512",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move packed double-precision values in zmm1 to m512 using non-temporal hint."
  },
  {
    "opcode": "NP 0F 2B /r",
    "name": "MOVNTPS",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move packed single-precision values xmm1 to mem using non-temporal hint."
  },
  {
    "opcode": "VEX.128.0F.WIG 2B /r V",
    "name": "MOVNTPS",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move packed single-precision values xmm1 to mem using non-temporal hint."
  },
  {
    "opcode": "VEX.256.0F.WIG 2B /r V",
    "name": "MOVNTPS",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move packed single-precision values ymm1 to mem using non-temporal hint."
  },
  {
    "opcode": "EVEX.128.0F.W0 2B /r V",
    "name": "MOVNTPS",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move packed single-precision values in xmm1 to m128 using non-temporal hint."
  },
  {
    "opcode": "EVEX.256.0F.W0 2B /r V",
    "name": "MOVNTPS",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move packed single-precision values in ymm1 to m256 using non-temporal hint."
  },
  {
    "opcode": "EVEX.512.0F.W0 2B /r V",
    "name": "MOVNTPS",
    "operands": [
      {
        "type": "m512",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move packed single-precision values in zmm1 to m512 using non-temporal hint."
  },
  {
    "opcode": "NP 0F E7 /r",
    "name": "MOVNTQ",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "mm",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move quadword from mm to m64 using non-temporal hint."
  },
  {
    "opcode": "NP 0F 6F /r",
    "name": "MOVQ",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Move quadword from mm/m64 to mm."
  },
  {
    "opcode": "NP 0F 7F /r",
    "name": "MOVQ",
    "operands": [
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "mm",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Move quadword from mm to mm/m64."
  },
  {
    "opcode": "F3 0F 7E /r",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move quadword from xmm2/mem64 to xmm1."
  },
  {
    "opcode": "VEX.128.F3.0F.WIG 7E /r V",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move quadword from xmm2 to xmm1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W1 7E /r V",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move quadword from xmm2/m64 to xmm1."
  },
  {
    "opcode": "66 0F D6 /r",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move quadword from xmm1 to xmm2/mem64."
  },
  {
    "opcode": "VEX.128.66.0F.WIG D6 /r V",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move quadword from xmm2 register to xmm1/m64."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 D6 /r V",
    "name": "MOVQ",
    "operands": [
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move quadword from xmm2 register to xmm1/m64."
  },
  {
    "opcode": "F3 0F D6 /r",
    "name": "MOVQ2DQ",
    "operands": [
      {
        "type": "xmm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move quadword from mmx to low quadword of xmm."
  },
  {
    "opcode": "A4",
    "name": "MOVS",
    "operands": [
      {
        "type": "m8"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
  },
  {
    "opcode": "A5",
    "name": "MOVS",
    "operands": [
      {
        "type": "m16"
      },
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
  },
  {
    "opcode": "A5",
    "name": "MOVS",
    "operands": [
      {
        "type": "m32"
      },
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
  },
  {
    "opcode": "REX.W + A5",
    "name": "MOVS",
    "operands": [
      {
        "type": "m64"
      },
      {
        "type": "m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move qword from address (R|E)SI to (R|E)DI."
  },
  {
    "opcode": "A4",
    "name": "MOVSB",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
  },
  {
    "opcode": "A5",
    "name": "MOVSW",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
  },
  {
    "opcode": "A5",
    "name": "MOVSD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
  },
  {
    "opcode": "REX.W + A5",
    "name": "MOVSQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move qword from address (R|E)SI to (R|E)DI."
  },
  {
    "opcode": "F2 0F 10 /r",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move scalar double-precision floating-point value from xmm2 to xmm1 register."
  },
  {
    "opcode": "F2 0F 10 /r",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Load scalar double-precision floating-point value from m64 to xmm1 register."
  },
  {
    "opcode": "F2 0F 11 /r",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move scalar double-precision floating-point value from xmm2 register to xmm1/m64."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 10 /r V",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 10 /r V",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Load scalar double-precision floating-point value from m64 to xmm1 register."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 11 /r V",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 11 /r V",
    "name": "MOVSD",
    "operands": [
      {
        "type": "m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Store scalar double-precision floating-point value from xmm1 register to m64."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 10 /r V",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 10 /r V",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Load scalar double-precision floating-point value from m64 to xmm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 11 /r V",
    "name": "MOVSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 11 /r V",
    "name": "MOVSD",
    "operands": [
      {
        "type": "m64 {k1}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Store scalar double-precision floating-point value from xmm1 register to m64 under writemask k1."
  },
  {
    "opcode": "F3 0F 16 /r",
    "name": "MOVSHDUP",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
  },
  {
    "opcode": "VEX.128.F3.0F.WIG 16 /r V",
    "name": "MOVSHDUP",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
  },
  {
    "opcode": "VEX.256.F3.0F.WIG 16 /r V",
    "name": "MOVSHDUP",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W0 16 /r V",
    "name": "MOVSHDUP",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move odd index single-precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask."
  },
  {
    "opcode": "EVEX.256.F3.0F.W0 16 /r V",
    "name": "MOVSHDUP",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move odd index single-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask."
  },
  {
    "opcode": "EVEX.512.F3.0F.W0 16 /r V",
    "name": "MOVSHDUP",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move odd index single-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask."
  },
  {
    "opcode": "F3 0F 12 /r",
    "name": "MOVSLDUP",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE3",
    "desc": "Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
  },
  {
    "opcode": "VEX.128.F3.0F.WIG 12 /r V",
    "name": "MOVSLDUP",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
  },
  {
    "opcode": "VEX.256.F3.0F.WIG 12 /r V",
    "name": "MOVSLDUP",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W0 12 /r V",
    "name": "MOVSLDUP",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move even index single-precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask."
  },
  {
    "opcode": "EVEX.256.F3.0F.W0 12 /r V",
    "name": "MOVSLDUP",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move even index single-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask."
  },
  {
    "opcode": "EVEX.512.F3.0F.W0 12 /r V",
    "name": "MOVSLDUP",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move even index single-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask."
  },
  {
    "opcode": "F3 0F 10 /r",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Merge scalar single-precision floating-point value from xmm2 to xmm1 register."
  },
  {
    "opcode": "F3 0F 10 /r",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Load scalar single-precision floating-point value from m32 to xmm1 register."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 10 /r V",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register"
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 10 /r V",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Load scalar single-precision floating-point value from m32 to xmm1 register."
  },
  {
    "opcode": "F3 0F 11 /r",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move scalar single-precision floating-point value from xmm1 register to xmm2/m32."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 11 /r V",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 11 /r V",
    "name": "MOVSS",
    "operands": [
      {
        "type": "m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move scalar single-precision floating-point value from xmm1 register to m32."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 10 /r V",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 10 /r V",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move scalar single-precision floating-point values from m32 to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 11 /r V",
    "name": "MOVSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 11 /r V",
    "name": "MOVSS",
    "operands": [
      {
        "type": "m32 {k1}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move scalar single-precision floating-point values from xmm1 to m32 under writemask k1."
  },
  {
    "opcode": "0F BE /r",
    "name": "MOVSX",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move byte to word with sign-extension."
  },
  {
    "opcode": "0F BE /r",
    "name": "MOVSX",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move byte to doubleword with sign-extension."
  },
  {
    "opcode": "REX.W + 0F BE /r",
    "name": "MOVSX",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move byte to quadword with sign-extension."
  },
  {
    "opcode": "0F BF /r",
    "name": "MOVSX",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move word to doubleword, with sign-extension."
  },
  {
    "opcode": "REX.W + 0F BF /r",
    "name": "MOVSX",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move word to quadword with sign-extension."
  },
  {
    "opcode": "63 /r*",
    "name": "MOVSXD",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move word to word with sign-extension."
  },
  {
    "opcode": "63 /r*",
    "name": "MOVSXD",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move doubleword to doubleword with sign-extension."
  },
  {
    "opcode": "REX.W + 63 /r",
    "name": "MOVSXD",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move doubleword to quadword with sign-extension."
  },
  {
    "opcode": "66 0F 10 /r",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move unaligned packed double-precision floating-point from xmm2/mem to xmm1."
  },
  {
    "opcode": "66 0F 11 /r",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 10 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed double-precision floating-point from xmm2/mem to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 11 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 10 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed double-precision floating-point from ymm2/mem to ymm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 11 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 10 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed double-precision floating-point from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 11 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed double-precision floating-point from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 10 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed double-precision floating-point from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 11 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed double-precision floating-point from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 10 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move unaligned packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 11 /r V",
    "name": "MOVUPD",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move unaligned packed double-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "NP 0F 10 /r",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
  },
  {
    "opcode": "NP 0F 11 /r",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F.WIG 10 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 11 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
  },
  {
    "opcode": "VEX.256.0F.WIG 10 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed single-precision floating-point from ymm2/mem to ymm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 11 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 10 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 10 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 10 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move unaligned packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.0F.W0 11 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "xmm2/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed single-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 11 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "ymm2/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Move unaligned packed single-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 11 /r V",
    "name": "MOVUPS",
    "operands": [
      {
        "type": "zmm2/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Move unaligned packed single-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
  },
  {
    "opcode": "0F B6 /r",
    "name": "MOVZX",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move byte to word with zero-extension."
  },
  {
    "opcode": "0F B6 /r",
    "name": "MOVZX",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move byte to doubleword, zero-extension."
  },
  {
    "opcode": "REX.W + 0F B6 /r",
    "name": "MOVZX",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move byte to quadword, zero-extension."
  },
  {
    "opcode": "0F B7 /r",
    "name": "MOVZX",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move word to doubleword, zero-extension."
  },
  {
    "opcode": "REX.W + 0F B7 /r",
    "name": "MOVZX",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move word to quadword, zero-extension."
  },
  {
    "opcode": "66 0F 3A 42 /r ib",
    "name": "MPSADBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 42 /r ib V",
    "name": "MPSADBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by imm8."
  },
  {
    "opcode": "VEX.256.66.0F3A.WIG 42 /r ib V",
    "name": "MPSADBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1. Starting offsets within ymm2 and xmm3/m128 are determined by imm8."
  },
  {
    "opcode": "F6 /4",
    "name": "MUL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Unsigned multiply (AX  AL  r/m8)."
  },
  {
    "opcode": "REX + F6 /4",
    "name": "MUL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Unsigned multiply (AX  AL  r/m8)."
  },
  {
    "opcode": "F7 /4",
    "name": "MUL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Unsigned multiply (DX:AX  AX  r/m16)."
  },
  {
    "opcode": "F7 /4",
    "name": "MUL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Unsigned multiply (EDX:EAX  EAX  r/m32)."
  },
  {
    "opcode": "REX.W + F7 /4",
    "name": "MUL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Unsigned multiply (RDX:RAX  RAX  r/m64)."
  },
  {
    "opcode": "66 0F 59 /r",
    "name": "MULPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Multiply packed double-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 59 /r V",
    "name": "MULPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply packed double-precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 59 /r V",
    "name": "MULPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply packed double-precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 59 /r V",
    "name": "MULPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 59 /r V",
    "name": "MULPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 59 /r V",
    "name": "MULPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values in zmm3/m512/m64bcst with zmm2 and store result in zmm1."
  },
  {
    "opcode": "NP 0F 59 /r",
    "name": "MULPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Multiply packed single-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 59 /r V",
    "name": "MULPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply packed single-precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 59 /r V",
    "name": "MULPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply packed single-precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 59 /r V",
    "name": "MULPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1."
  },
  {
    "opcode": "EVEX.256.0F.W0 59 /r V",
    "name": "MULPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1."
  },
  {
    "opcode": "EVEX.512.0F.W0 59 /r V",
    "name": "MULPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst {er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values in zmm3/m512/m32bcst with zmm2 and store result in zmm1."
  },
  {
    "opcode": "F2 0F 59 /r",
    "name": "MULSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Multiply the low double-precision floating-point value in xmm2/m64 by low double-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 59 /r V",
    "name": "MULSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply the low double-precision floating-point value in xmm3/m64 by low double-precision floating-point value in xmm2."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 59 /r V",
    "name": "MULSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64 {er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply the low double-precision floating-point value in xmm3/m64 by low double-precision floating-point value in xmm2."
  },
  {
    "opcode": "F3 0F 59 /r",
    "name": "MULSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Multiply the low single-precision floating-point value in xmm2/m32 by the low single-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 59 /r V",
    "name": "MULSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply the low single-precision floating-point value in xmm3/m32 by the low single-precision floating-point value in xmm2."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 59 /r V",
    "name": "MULSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32 {er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply the low single-precision floating-point value in xmm3/m32 by the low single-precision floating-point value in xmm2."
  },
  {
    "opcode": "VEX.LZ.F2.0F38.W0 F6 /r",
    "name": "MULX",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "encoding": "RDX/EDX is implied 64/32 bits source"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI2",
    "desc": "Unsigned multiply of r/m32 with EDX without affecting arithmetic flags."
  },
  {
    "opcode": "VEX.LZ.F2.0F38.W1 F6 /r",
    "name": "MULX",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "encoding": "RDX/EDX is implied 64/32 bits source"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI2",
    "desc": "Unsigned multiply of r/m64 with RDX without affecting arithmetic flags."
  },
  {
    "opcode": "0F 01 C9",
    "name": "MWAIT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."
  },
  {
    "opcode": "F6 /3",
    "name": "NEG",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Two's complement negate r/m8."
  },
  {
    "opcode": "REX + F6 /3",
    "name": "NEG",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Two's complement negate r/m8."
  },
  {
    "opcode": "F7 /3",
    "name": "NEG",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Two's complement negate r/m16."
  },
  {
    "opcode": "F7 /3",
    "name": "NEG",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Two's complement negate r/m32."
  },
  {
    "opcode": "REX.W + F7 /3",
    "name": "NEG",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Two's complement negate r/m64."
  },
  {
    "opcode": "NP 90",
    "name": "NOP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "One byte no-operation instruction."
  },
  {
    "opcode": "NP 0F 1F /0",
    "name": "NOP",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multi-byte no-operation instruction."
  },
  {
    "opcode": "NP 0F 1F /0",
    "name": "NOP",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multi-byte no-operation instruction."
  },
  {
    "opcode": "F6 /2",
    "name": "NOT",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Reverse each bit of r/m8."
  },
  {
    "opcode": "REX + F6 /2",
    "name": "NOT",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Reverse each bit of r/m8."
  },
  {
    "opcode": "F7 /2",
    "name": "NOT",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Reverse each bit of r/m16."
  },
  {
    "opcode": "F7 /2",
    "name": "NOT",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Reverse each bit of r/m32."
  },
  {
    "opcode": "REX.W + F7 /2",
    "name": "NOT",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Reverse each bit of r/m64."
  },
  {
    "opcode": "0C ib",
    "name": "OR",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AL OR imm8."
  },
  {
    "opcode": "0D iw",
    "name": "OR",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AX OR imm16."
  },
  {
    "opcode": "0D id",
    "name": "OR",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "EAX OR imm32."
  },
  {
    "opcode": "REX.W + 0D id",
    "name": "OR",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "RAX OR imm32 (sign-extended)."
  },
  {
    "opcode": "80 /1 ib",
    "name": "OR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m8 OR imm8."
  },
  {
    "opcode": "REX + 80 /1 ib",
    "name": "OR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m8 OR imm8."
  },
  {
    "opcode": "81 /1 iw",
    "name": "OR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 OR imm16."
  },
  {
    "opcode": "81 /1 id",
    "name": "OR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 OR imm32."
  },
  {
    "opcode": "REX.W + 81 /1 id",
    "name": "OR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 OR imm32 (sign-extended)."
  },
  {
    "opcode": "83 /1 ib",
    "name": "OR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 OR imm8 (sign-extended)."
  },
  {
    "opcode": "83 /1 ib",
    "name": "OR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 OR imm8 (sign-extended)."
  },
  {
    "opcode": "REX.W + 83 /1 ib",
    "name": "OR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 OR imm8 (sign-extended)."
  },
  {
    "opcode": "08 /r",
    "name": "OR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m8 OR r8."
  },
  {
    "opcode": "REX + 08 /r",
    "name": "OR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m8 OR r8."
  },
  {
    "opcode": "09 /r",
    "name": "OR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 OR r16."
  },
  {
    "opcode": "09 /r",
    "name": "OR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 OR r32."
  },
  {
    "opcode": "REX.W + 09 /r",
    "name": "OR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 OR r64."
  },
  {
    "opcode": "0A /r",
    "name": "OR",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r8 OR r/m8."
  },
  {
    "opcode": "REX + 0A /r",
    "name": "OR",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r8 OR r/m8."
  },
  {
    "opcode": "0B /r",
    "name": "OR",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r16 OR r/m16."
  },
  {
    "opcode": "0B /r",
    "name": "OR",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r32 OR r/m32."
  },
  {
    "opcode": "REX.W + 0B /r",
    "name": "OR",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r64 OR r/m64."
  },
  {
    "opcode": "66 0F 56/r",
    "name": "ORPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Return the bitwise logical OR of packed double-precision floating-point values in xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.66.0F 56 /r V",
    "name": "ORPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.66.0F 56 /r V",
    "name": "ORPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 56 /r V",
    "name": "ORPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 56 /r V",
    "name": "ORPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 56 /r V",
    "name": "ORPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Return the bitwise logical OR of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
  },
  {
    "opcode": "NP 0F 56 /r",
    "name": "ORPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Return the bitwise logical OR of packed single-precision floating-point values in xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F 56 /r V",
    "name": "ORPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.0F 56 /r V",
    "name": "ORPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 56 /r V",
    "name": "ORPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 56 /r V",
    "name": "ORPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 56 /r V",
    "name": "ORPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Return the bitwise logical OR of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
  },
  {
    "opcode": "E6 ib",
    "name": "OUT",
    "operands": [
      {
        "type": "imm8",
        "encoding": "imm8"
      },
      {
        "type": "AL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output byte in AL to I/O port address imm8."
  },
  {
    "opcode": "E7 ib",
    "name": "OUT",
    "operands": [
      {
        "type": "imm8",
        "encoding": "imm8"
      },
      {
        "type": "AX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output word in AX to I/O port address imm8."
  },
  {
    "opcode": "E7 ib",
    "name": "OUT",
    "operands": [
      {
        "type": "imm8",
        "encoding": "imm8"
      },
      {
        "type": "EAX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output doubleword in EAX to I/O port address imm8."
  },
  {
    "opcode": "EE",
    "name": "OUT",
    "operands": [
      {
        "type": "DX"
      },
      {
        "type": "AL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output byte in AL to I/O port address in DX."
  },
  {
    "opcode": "EF",
    "name": "OUT",
    "operands": [
      {
        "type": "DX"
      },
      {
        "type": "AX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output word in AX to I/O port address in DX."
  },
  {
    "opcode": "EF",
    "name": "OUT",
    "operands": [
      {
        "type": "DX"
      },
      {
        "type": "EAX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output doubleword in EAX to I/O port address in DX."
  },
  {
    "opcode": "6E",
    "name": "OUTS",
    "operands": [
      {
        "type": "DX"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
  },
  {
    "opcode": "6F",
    "name": "OUTS",
    "operands": [
      {
        "type": "DX"
      },
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
  },
  {
    "opcode": "6F",
    "name": "OUTS",
    "operands": [
      {
        "type": "DX"
      },
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
  },
  {
    "opcode": "6E",
    "name": "OUTSB",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
  },
  {
    "opcode": "6F",
    "name": "OUTSW",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
  },
  {
    "opcode": "6F",
    "name": "OUTSD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
  },
  {
    "opcode": "NP 0F 38 1C /r1",
    "name": "PABSB",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1."
  },
  {
    "opcode": "66 0F 38 1C /r",
    "name": "PABSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."
  },
  {
    "opcode": "NP 0F 38 1D /r1",
    "name": "PABSW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1."
  },
  {
    "opcode": "66 0F 38 1D /r",
    "name": "PABSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
  },
  {
    "opcode": "NP 0F 38 1E /r1",
    "name": "PABSD",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1."
  },
  {
    "opcode": "66 0F 38 1E /r",
    "name": "PABSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 1C /r V",
    "name": "PABSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 1D /r V",
    "name": "PABSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 1E /r V",
    "name": "PABSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 1C /r V",
    "name": "PABSB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 1D /r V",
    "name": "PABSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 1E /r V",
    "name": "PABSD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 1C /r V",
    "name": "PABSB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 1C /r V",
    "name": "PABSB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 1C /r V",
    "name": "PABSB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Compute the absolute value of bytes in zmm2/m512 and store UNSIGNED result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 1D /r V",
    "name": "PABSW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
  },
  {
    "opcode": "NP 0F 63 /r1",
    "name": "PACKSSWB",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation."
  },
  {
    "opcode": "66 0F 63 /r",
    "name": "PACKSSWB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation."
  },
  {
    "opcode": "NP 0F 6B /r1",
    "name": "PACKSSDW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation."
  },
  {
    "opcode": "66 0F 6B /r",
    "name": "PACKSSDW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 63 /r V",
    "name": "PACKSSWB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 6B /r V",
    "name": "PACKSSDW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 63 /r V",
    "name": "PACKSSWB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 6B /r V",
    "name": "PACKSSDW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 63 /r V",
    "name": "PACKSSWB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts packed signed word integers from xmm2 and from xmm3/m128 into packed signed byte integers in xmm1 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG 63 /r V",
    "name": "PACKSSWB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts packed signed word integers from ymm2 and from ymm3/m256 into packed signed byte integers in ymm1 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG 63 /r V",
    "name": "PACKSSWB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Converts packed signed word integers from zmm2 and from zmm3/m512 into packed signed byte integers in zmm1 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 6B /r V",
    "name": "PACKSSDW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts packed signed doubleword integers from xmm2 and from xmm3/m128/m32bcst into packed signed word integers in xmm1 using signed saturation under writemask k1."
  },
  {
    "opcode": "66 0F 38 2B /r",
    "name": "PACKUSDW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
  },
  {
    "opcode": "VEX.128.66.0F38 2B /r V",
    "name": "PACKUSDW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
  },
  {
    "opcode": "VEX.256.66.0F38 2B /r V",
    "name": "PACKUSDW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m256 into 16 packed unsigned word integers in ymm1 using unsigned saturation."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 2B /r V",
    "name": "PACKUSDW",
    "operands": [
      {
        "type": "xmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Convert packed signed doubleword integers from xmm2 and packed signed doubleword integers from xmm3/m128/m32bcst into packed unsigned word integers in xmm1 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 2B /r V",
    "name": "PACKUSDW",
    "operands": [
      {
        "type": "ymm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Convert packed signed doubleword integers from ymm2 and packed signed doubleword integers from ymm3/m256/m32bcst into packed unsigned word integers in ymm1 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 2B /r V",
    "name": "PACKUSDW",
    "operands": [
      {
        "type": "zmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Convert packed signed doubleword integers from zmm2 and packed signed doubleword integers from zmm3/m512/m32bcst into packed unsigned word integers in zmm1 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "NP 0F 67 /r1",
    "name": "PACKUSWB",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation."
  },
  {
    "opcode": "66 0F 67 /r",
    "name": "PACKUSWB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 67 /r V",
    "name": "PACKUSWB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 67 /r V",
    "name": "PACKUSWB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Converts 16 signed word integers from ymm2 and 16signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 67 /r V",
    "name": "PACKUSWB",
    "operands": [
      {
        "type": "xmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts signed word integers from xmm2 and signed word integers from xmm3/m128 into unsigned byte integers in xmm1 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG 67 /r V",
    "name": "PACKUSWB",
    "operands": [
      {
        "type": "ymm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts signed word integers from ymm2 and signed word integers from ymm3/m256 into unsigned byte integers in ymm1 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG 67 /r V",
    "name": "PACKUSWB",
    "operands": [
      {
        "type": "zmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Converts signed word integers from zmm2 and signed word integers from zmm3/m512 into unsigned byte integers in zmm1 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "NP 0F EC /r1",
    "name": "PADDSB",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Add packed signed byte integers from mm/m64 and mm and saturate the results."
  },
  {
    "opcode": "66 0F EC /r",
    "name": "PADDSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results."
  },
  {
    "opcode": "NP 0F ED /r1",
    "name": "PADDSW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Add packed signed word integers from mm/m64 and mm and saturate the results."
  },
  {
    "opcode": "66 0F ED /r",
    "name": "PADDSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results."
  },
  {
    "opcode": "VEX.128.66.0F.WIG EC /r V",
    "name": "PADDSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results."
  },
  {
    "opcode": "VEX.128.66.0F.WIG ED /r V",
    "name": "PADDSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results."
  },
  {
    "opcode": "VEX.256.66.0F.WIG EC /r V",
    "name": "PADDSB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG ED /r V",
    "name": "PADDSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG EC /r V",
    "name": "PADDSB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Add packed signed byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG EC /r V",
    "name": "PADDSB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG EC /r V",
    "name": "PADDSB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Add packed signed byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG ED /r V",
    "name": "PADDSW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Add packed signed word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG ED /r V",
    "name": "PADDSW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG ED /r V",
    "name": "PADDSW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Add packed signed word integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
  },
  {
    "opcode": "NP 0F DC /r1",
    "name": "PADDUSB",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Add packed unsigned byte integers from mm/m64 and mm and saturate the results."
  },
  {
    "opcode": "66 0F DC /r",
    "name": "PADDUSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results."
  },
  {
    "opcode": "NP 0F DD /r1",
    "name": "PADDUSW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Add packed unsigned word integers from mm/m64 and mm and saturate the results."
  },
  {
    "opcode": "66 0F DD /r",
    "name": "PADDUSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results."
  },
  {
    "opcode": "VEX.128.660F.WIG DC /r V",
    "name": "PADDUSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results."
  },
  {
    "opcode": "VEX.128.66.0F.WIG DD /r V",
    "name": "PADDUSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results."
  },
  {
    "opcode": "VEX.256.66.0F.WIG DC /r V",
    "name": "PADDUSB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG DD /r V",
    "name": "PADDUSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG DC /r V",
    "name": "PADDUSB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Add packed unsigned byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG DC /r V",
    "name": "PADDUSB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG DC /r V",
    "name": "PADDUSB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Add packed unsigned byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG DD /r V",
    "name": "PADDUSW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Add packed unsigned word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG DD /r V",
    "name": "PADDUSW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
  },
  {
    "opcode": "NP 0F 3A 0F /r ib1",
    "name": "PALIGNR",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1."
  },
  {
    "opcode": "66 0F 3A 0F /r ib",
    "name": "PALIGNR",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 0F /r ib V",
    "name": "PALIGNR",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.WIG 0F /r ib V",
    "name": "PALIGNR",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.WIG 0F /r ib V",
    "name": "PALIGNR",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Concatenate xmm2 and xmm3/m128 into a 32-byte intermediate result, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.WIG 0F /r ib V",
    "name": "PALIGNR",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.WIG 0F /r ib V",
    "name": "PALIGNR",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Concatenate pairs of 16 bytes in zmm2 and zmm3/m512 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and four 16-byte results are stored in zmm1."
  },
  {
    "opcode": "NP 0F DB /r1",
    "name": "PAND",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Bitwise AND mm/m64 and mm."
  },
  {
    "opcode": "66 0F DB /r",
    "name": "PAND",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Bitwise AND of xmm2/m128 and xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG DB /r V",
    "name": "PAND",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Bitwise AND of xmm3/m128 and xmm."
  },
  {
    "opcode": "VEX.256.66.0F.WIG DB /r V",
    "name": "PAND",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/.m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 DB /r V",
    "name": "PANDD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 DB /r V",
    "name": "PANDD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 DB /r V",
    "name": "PANDD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 DB /r V",
    "name": "PANDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 DB /r V",
    "name": "PANDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 DB /r V",
    "name": "PANDQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1."
  },
  {
    "opcode": "NP 0F DF /r1",
    "name": "PANDN",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Bitwise AND NOT of mm/m64 and mm."
  },
  {
    "opcode": "66 0F DF /r",
    "name": "PANDN",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Bitwise AND NOT of xmm2/m128 and xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG DF /r V",
    "name": "PANDN",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Bitwise AND NOT of xmm3/m128 and xmm2."
  },
  {
    "opcode": "VEX.256.66.0F.WIG DF /r V",
    "name": "PANDN",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 DF /r V",
    "name": "PANDND",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND NOT of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 DF /r V",
    "name": "PANDND",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND NOT of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 DF /r V",
    "name": "PANDND",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise AND NOT of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 DF /r V",
    "name": "PANDNQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND NOT of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 DF /r V",
    "name": "PANDNQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND NOT of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 DF /r V",
    "name": "PANDNQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise AND NOT of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1."
  },
  {
    "opcode": "F3 90",
    "name": "PAUSE",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Gives hint to processor that improves performance of spin-wait loops."
  },
  {
    "opcode": "NP 0F E0 /r1",
    "name": "PAVGB",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Average packed unsigned byte integers from mm2/m64 and mm1 with rounding."
  },
  {
    "opcode": "66 0F E0, /r",
    "name": "PAVGB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding."
  },
  {
    "opcode": "NP 0F E3 /r1",
    "name": "PAVGW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Average packed unsigned word integers from mm2/m64 and mm1 with rounding."
  },
  {
    "opcode": "66 0F E3 /r",
    "name": "PAVGW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E0 /r V",
    "name": "PAVGB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E3 /r V",
    "name": "PAVGW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E0 /r V",
    "name": "PAVGB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E3 /r V",
    "name": "PAVGW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG E0 /r V",
    "name": "PAVGB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Average packed unsigned byte integers from xmm2, and xmm3/m128 with rounding and store to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG E0 /r V",
    "name": "PAVGB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG E0 /r V",
    "name": "PAVGB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Average packed unsigned byte integers from zmm2, and zmm3/m512 with rounding and store to zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG E3 /r V",
    "name": "PAVGW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Average packed unsigned word integers from xmm2, xmm3/m128 with rounding to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG E3 /r V",
    "name": "PAVGW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG E3 /r V",
    "name": "PAVGW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Average packed unsigned word integers from zmm2, zmm3/m512 with rounding to zmm1 under writemask k1."
  },
  {
    "opcode": "66 0F 38 10 /r",
    "name": "PBLENDVB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "<XMM0>",
        "encoding": "<XMM0>"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 4C /r /is4 V",
    "name": "PBLENDVB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "xmm4",
        "encoding": "imm8[7:4]"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 4C /r /is4 V",
    "name": "PBLENDVB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "ymm4",
        "encoding": "imm8[7:4]"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1."
  },
  {
    "opcode": "66 0F 3A 0E /r ib",
    "name": "PBLENDW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 0E /r ib V",
    "name": "PBLENDW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.WIG 0E /r ib V",
    "name": "PBLENDW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1."
  },
  {
    "opcode": "66 0F 3A 44 /r ib",
    "name": "PCLMULQDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "PCLMULQDQ",
    "desc": "Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 44 /r ib V",
    "name": "PCLMULQDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "Both PCLMULQDQ and AVX flags",
    "desc": "Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used."
  },
  {
    "opcode": "NP 0F 74 /r1",
    "name": "PCMPEQB",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Compare packed bytes in mm/m64 and mm for equality."
  },
  {
    "opcode": "66 0F 74 /r",
    "name": "PCMPEQB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare packed bytes in xmm2/m128 and xmm1 for equality."
  },
  {
    "opcode": "NP 0F 75 /r1",
    "name": "PCMPEQW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Compare packed words in mm/m64 and mm for equality."
  },
  {
    "opcode": "66 0F 75 /r",
    "name": "PCMPEQW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare packed words in xmm2/m128 and xmm1 for equality."
  },
  {
    "opcode": "NP 0F 76 /r1",
    "name": "PCMPEQD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Compare packed doublewords in mm/m64 and mm for equality."
  },
  {
    "opcode": "66 0F 76 /r",
    "name": "PCMPEQD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare packed doublewords in xmm2/m128 and xmm1 for equality."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 74 /r V",
    "name": "PCMPEQB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed bytes in xmm3/m128 and xmm2 for equality."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 75 /r V",
    "name": "PCMPEQW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed words in xmm3/m128 and xmm2 for equality."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 76 /r V",
    "name": "PCMPEQD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed doublewords in xmm3/m128 and xmm2 for equality."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 74 /r V",
    "name": "PCMPEQB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3 /m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed bytes in ymm3/m256 and ymm2 for equality."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 75 /r V",
    "name": "PCMPEQW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3 /m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed words in ymm3/m256 and ymm2 for equality."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 76 /r V",
    "name": "PCMPEQD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3 /m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed doublewords in ymm3/m256 and ymm2 for equality."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 76 /r V",
    "name": "PCMPEQD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare Equal between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 76 /r V",
    "name": "PCMPEQD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare Equal between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 76 /r V",
    "name": "PCMPEQD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare Equal between int32 vectors in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask k2."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 74 /r V",
    "name": "PCMPEQB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3 /m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed bytes in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "66 0F 38 29 /r",
    "name": "PCMPEQQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Compare packed qwords in xmm2/m128 and xmm1 for equality."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 29 /r V",
    "name": "PCMPEQQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed quadwords in xmm3/m128 and xmm2 for equality."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 29 /r V",
    "name": "PCMPEQQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3 /m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed quadwords in ymm3/m256 and ymm2 for equality."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 29 /r V",
    "name": "PCMPEQQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare Equal between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 29 /r V",
    "name": "PCMPEQQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare Equal between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 29 /r V",
    "name": "PCMPEQQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare Equal between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "66 0F 3A 61 /r imm8",
    "name": "PCMPESTRI",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_2",
    "desc": "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."
  },
  {
    "opcode": "VEX.128.66.0F3A 61 /r ib V",
    "name": "PCMPESTRI",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."
  },
  {
    "opcode": "66 0F 3A 60 /r imm8",
    "name": "PCMPESTRM",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_2",
    "desc": "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."
  },
  {
    "opcode": "VEX.128.66.0F3A 60 /r ib V",
    "name": "PCMPESTRM",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."
  },
  {
    "opcode": "NP 0F 64 /r1",
    "name": "PCMPGTB",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Compare packed signed byte integers in mm and mm/m64 for greater than."
  },
  {
    "opcode": "66 0F 64 /r",
    "name": "PCMPGTB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than."
  },
  {
    "opcode": "NP 0F 65 /r1",
    "name": "PCMPGTW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Compare packed signed word integers in mm and mm/m64 for greater than."
  },
  {
    "opcode": "66 0F 65 /r",
    "name": "PCMPGTW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare packed signed word integers in xmm1 and xmm2/m128 for greater than."
  },
  {
    "opcode": "NP 0F 66 /r1",
    "name": "PCMPGTD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Compare packed signed doubleword integers in mm and mm/m64 for greater than."
  },
  {
    "opcode": "66 0F 66 /r",
    "name": "PCMPGTD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 64 /r V",
    "name": "PCMPGTB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 65 /r V",
    "name": "PCMPGTW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed signed word integers in xmm2 and xmm3/m128 for greater than."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 66 /r V",
    "name": "PCMPGTD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 64 /r V",
    "name": "PCMPGTB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 65 /r V",
    "name": "PCMPGTW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed signed word integers in ymm2 and ymm3/m256 for greater than."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 66 /r V",
    "name": "PCMPGTD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 66 /r V",
    "name": "PCMPGTD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare Greater between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 66 /r V",
    "name": "PCMPGTD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare Greater between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 66 /r V",
    "name": "PCMPGTD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare Greater between int32 elements in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask. k2."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 64 /r V",
    "name": "PCMPGTB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG 64 /r V",
    "name": "PCMPGTB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "66 0F 38 37 /r",
    "name": "PCMPGTQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_2",
    "desc": "Compare packed signed qwords in xmm2/m128 and xmm1 for greater than."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 37 /r V",
    "name": "PCMPGTQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed signed qwords in xmm2 and xmm3/m128 for greater than."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 37 /r V",
    "name": "PCMPGTQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed signed qwords in ymm2 and ymm3/m256 for greater than."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 37 /r V",
    "name": "PCMPGTQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare Greater between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 37 /r V",
    "name": "PCMPGTQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare Greater between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 37 /r V",
    "name": "PCMPGTQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare Greater between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
  },
  {
    "opcode": "66 0F 3A 63 /r imm8",
    "name": "PCMPISTRI",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_2",
    "desc": "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 63 /r ib V",
    "name": "PCMPISTRI",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."
  },
  {
    "opcode": "66 0F 3A 62 /r imm8",
    "name": "PCMPISTRM",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_2",
    "desc": "Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 62 /r ib V",
    "name": "PCMPISTRM",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0."
  },
  {
    "opcode": "VEX.LZ.F2.0F38.W0 F5 /r",
    "name": "PDEP",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI2",
    "desc": "Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a."
  },
  {
    "opcode": "VEX.LZ.F2.0F38.W1 F5 /r",
    "name": "PDEP",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI2",
    "desc": "Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a."
  },
  {
    "opcode": "VEX.LZ.F3.0F38.W0 F5 /r",
    "name": "PEXT",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI2",
    "desc": "Parallel extract of bits from r32b using mask in r/m32, result is written to r32a."
  },
  {
    "opcode": "VEX.LZ.F3.0F38.W1 F5 /r",
    "name": "PEXT",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI2",
    "desc": "Parallel extract of bits from r64b using mask in r/m64, result is written to r64a."
  },
  {
    "opcode": "66 0F 3A 14 /r ib",
    "name": "PEXTRB",
    "operands": [
      {
        "type": "reg/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r32 or r64 are zeroed."
  },
  {
    "opcode": "66 0F 3A 16 /r ib",
    "name": "PEXTRD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32."
  },
  {
    "opcode": "66 REX.W 0F 3A 16 /r ib",
    "name": "PEXTRQ",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "SSE4_1",
    "desc": "Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 14 /r ib V",
    "name": "PEXTRB",
    "operands": [
      {
        "type": "reg/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v1",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 16 /r ib V",
    "name": "PEXTRD",
    "operands": [
      {
        "type": "r32/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32."
  },
  {
    "opcode": "VEX.128.66.0F3A.W1 16 /r ib V",
    "name": "PEXTRQ",
    "operands": [
      {
        "type": "r64/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "i2",
    "flag": "AVX",
    "desc": "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64."
  },
  {
    "opcode": "EVEX.128.66.0F3A.WIG 14 /r ib V",
    "name": "PEXTRB",
    "operands": [
      {
        "type": "reg/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 16 /r ib V",
    "name": "PEXTRD",
    "operands": [
      {
        "type": "r32/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 16 /r ib V",
    "name": "PEXTRQ",
    "operands": [
      {
        "type": "r64/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX512DQ",
    "desc": "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64."
  },
  {
    "opcode": "NP 0F C5 /r ib1",
    "name": "PEXTRW",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed."
  },
  {
    "opcode": "66 0F C5 /r ib",
    "name": "PEXTRW",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed."
  },
  {
    "opcode": "66 0F 3A 15 /r ib",
    "name": "PEXTRW",
    "operands": [
      {
        "type": "reg/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64."
  },
  {
    "opcode": "VEX.128.66.0F.W0 C5 /r ib V",
    "name": "PEXTRW",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v2",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 15 /r ib V",
    "name": "PEXTRW",
    "operands": [
      {
        "type": "reg/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG C5 /r ib V",
    "name": "PEXTRW",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512B W",
    "desc": "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros."
  },
  {
    "opcode": "EVEX.128.66.0F3A.WIG 15 /r ib V",
    "name": "PEXTRW",
    "operands": [
      {
        "type": "reg/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512B W",
    "desc": "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros."
  },
  {
    "opcode": "NP 0F 38 03 /r1",
    "name": "PHADDSW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Add 16-bit signed integers horizontally, pack saturated integers to mm1."
  },
  {
    "opcode": "66 0F 38 03 /r",
    "name": "PHADDSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Add 16-bit signed integers horizontally, pack saturated integers to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 03 /r V",
    "name": "PHADDSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add 16-bit signed integers horizontally, pack saturated integers to xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 03 /r V",
    "name": "PHADDSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Add 16-bit signed integers horizontally, pack saturated integers to ymm1."
  },
  {
    "opcode": "NP 0F 38 01 /r1",
    "name": "PHADDW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Add 16-bit integers horizontally, pack to mm1."
  },
  {
    "opcode": "66 0F 38 01 /r",
    "name": "PHADDW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Add 16-bit integers horizontally, pack to xmm1."
  },
  {
    "opcode": "NP 0F 38 02 /r",
    "name": "PHADDD",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Add 32-bit integers horizontally, pack to mm1."
  },
  {
    "opcode": "66 0F 38 02 /r",
    "name": "PHADDD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Add 32-bit integers horizontally, pack to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 01 /r V",
    "name": "PHADDW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add 16-bit integers horizontally, pack to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 02 /r V",
    "name": "PHADDD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Add 32-bit integers horizontally, pack to xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 01 /r V",
    "name": "PHADDW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Add 16-bit signed integers horizontally, pack to ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 02 /r V",
    "name": "PHADDD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Add 32-bit signed integers horizontally, pack to ymm1."
  },
  {
    "opcode": "66 0F 38 41 /r",
    "name": "PHMINPOSUW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 41 /r V",
    "name": "PHMINPOSUW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."
  },
  {
    "opcode": "NP 0F 38 07 /r1",
    "name": "PHSUBSW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Subtract 16-bit signed integer horizontally, pack saturated integers to mm1."
  },
  {
    "opcode": "66 0F 38 07 /r",
    "name": "PHSUBSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 07 /r V",
    "name": "PHSUBSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 07 /r V",
    "name": "PHSUBSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1."
  },
  {
    "opcode": "NP 0F 38 05 /r1",
    "name": "PHSUBW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Subtract 16-bit signed integers horizontally, pack to mm1."
  },
  {
    "opcode": "66 0F 38 05 /r",
    "name": "PHSUBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Subtract 16-bit signed integers horizontally, pack to xmm1."
  },
  {
    "opcode": "NP 0F 38 06 /r",
    "name": "PHSUBD",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Subtract 32-bit signed integers horizontally, pack to mm1."
  },
  {
    "opcode": "66 0F 38 06 /r",
    "name": "PHSUBD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Subtract 32-bit signed integers horizontally, pack to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 05 /r V",
    "name": "PHSUBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract 16-bit signed integers horizontally, pack to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 06 /r V",
    "name": "PHSUBD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract 32-bit signed integers horizontally, pack to xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 05 /r V",
    "name": "PHSUBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract 16-bit signed integers horizontally, pack to ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 06 /r V",
    "name": "PHSUBD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract 32-bit signed integers horizontally, pack to ymm1."
  },
  {
    "opcode": "66 0F 3A 20 /r ib",
    "name": "PINSRB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m8",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8."
  },
  {
    "opcode": "66 0F 3A 22 /r ib",
    "name": "PINSRD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8."
  },
  {
    "opcode": "66 REX.W 0F 3A 22 /r ib",
    "name": "PINSRQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "n. e.",
    "flag": "SSE4_1",
    "desc": "Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by imm8."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 20 /r ib V",
    "name": "PINSRB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r32/m8",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v1",
    "support32": "v",
    "flag": "AVX",
    "desc": "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 22 /r ib V",
    "name": "PINSRD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8."
  },
  {
    "opcode": "VEX.128.66.0F3A.W1 22 /r ib V",
    "name": "PINSRQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "i2",
    "flag": "AVX",
    "desc": "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8."
  },
  {
    "opcode": "EVEX.128.66.0F3A.WIG 20 /r ib V",
    "name": "PINSRB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "r32/m8",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 22 /r ib V",
    "name": "PINSRD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "r32/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 22 /r ib V",
    "name": "PINSRQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "r64/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "n.e.2",
    "flag": "AVX512DQ",
    "desc": "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8."
  },
  {
    "opcode": "NP 0F C4 /r ib1",
    "name": "PINSRW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Insert the low word from r32 or from m16 into mm at the word position specified by imm8."
  },
  {
    "opcode": "66 0F C4 /r ib",
    "name": "PINSRW",
    "operands": [
      {
        "type": "xmm",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r32/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move the low word of r32 or from m16 into xmm at the word position specified by imm8."
  },
  {
    "opcode": "VEX.128.66.0F.W0 C4 /r ib V",
    "name": "PINSRW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "r32/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v2",
    "support32": "v",
    "flag": "AVX",
    "desc": "Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG C4 /r ib V",
    "name": "PINSRW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "r32/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8."
  },
  {
    "opcode": "NP 0F 38 04 /r1",
    "name": "PMADDUBSW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to mm1."
  },
  {
    "opcode": "66 0F 38 04 /r",
    "name": "PMADDUBSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 04 /r V",
    "name": "PMADDUBSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 04 /r V",
    "name": "PMADDUBSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 04 /r V",
    "name": "PMADDUBSW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 04 /r V",
    "name": "PMADDUBSW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 04 /r V",
    "name": "PMADDUBSW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to zmm1 under writemask k1."
  },
  {
    "opcode": "NP 0F F5 /r1",
    "name": "PMADDWD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm."
  },
  {
    "opcode": "66 0F F5 /r",
    "name": "PMADDWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F5 /r V",
    "name": "PMADDWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG F5 /r V",
    "name": "PMADDWD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG F5 /r V",
    "name": "PMADDWD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG F5 /r V",
    "name": "PMADDWD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG F5 /r V",
    "name": "PMADDWD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Multiply the packed word integers in zmm2 by the packed word integers in zmm3/m512, add adjacent doubleword results, and store in zmm1 under writemask k1."
  },
  {
    "opcode": "NP 0F EE /r1",
    "name": "PMAXSW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Compare signed word integers in mm2/m64 and mm1 and return maximum values."
  },
  {
    "opcode": "66 0F 38 3C /r",
    "name": "PMAXSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
  },
  {
    "opcode": "66 0F EE /r",
    "name": "PMAXSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare packed signed word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
  },
  {
    "opcode": "66 0F 38 3D /r",
    "name": "PMAXSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 3C /r V",
    "name": "PMAXSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG EE /r V",
    "name": "PMAXSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 3D /r V",
    "name": "PMAXSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 3C /r V",
    "name": "PMAXSB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG EE /r V",
    "name": "PMAXSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed signed word integers in ymm3/m256 and ymm2 and store packed maximum values in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 3D /r V",
    "name": "PMAXSD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 3C /r V",
    "name": "PMAXSB",
    "operands": [
      {
        "type": "xmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 3C /r V",
    "name": "PMAXSB",
    "operands": [
      {
        "type": "ymm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 3C /r V",
    "name": "PMAXSB",
    "operands": [
      {
        "type": "zmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG EE /r V",
    "name": "PMAXSW",
    "operands": [
      {
        "type": "xmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG EE /r V",
    "name": "PMAXSW",
    "operands": [
      {
        "type": "ymm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG EE /r V",
    "name": "PMAXSW",
    "operands": [
      {
        "type": "zmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Compare packed signed word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 3D /r V",
    "name": "PMAXSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 3D /r V",
    "name": "PMAXSD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 3D /r V",
    "name": "PMAXSD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 3D /r V",
    "name": "PMAXSQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 3D /r V",
    "name": "PMAXSQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 3D /r V",
    "name": "PMAXSQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 using writemask k1."
  },
  {
    "opcode": "66 0F 38 3F /r",
    "name": "PMAXUD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 3F /r V",
    "name": "PMAXUD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 3F /r V",
    "name": "PMAXUD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 3F /r V",
    "name": "PMAXUD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 3F /r V",
    "name": "PMAXUD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 3F /r V",
    "name": "PMAXUD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 3F /r V",
    "name": "PMAXUQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 3F /r V",
    "name": "PMAXUQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 3F /r V",
    "name": "PMAXUQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 under writemask k1."
  },
  {
    "opcode": "66 0F 38 39 /r",
    "name": "PMINSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 39 /r V",
    "name": "PMINSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 39 /r V",
    "name": "PMINSD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 39 /r V",
    "name": "PMINSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 39 /r V",
    "name": "PMINSD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 39 /r V",
    "name": "PMINSD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 39 /r V",
    "name": "PMINSQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed qword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 39 /r V",
    "name": "PMINSQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed qword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 39 /r V",
    "name": "PMINSQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1."
  },
  {
    "opcode": "66 0F 38 3B /r",
    "name": "PMINUD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 3B /r V",
    "name": "PMINUD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 3B /r V",
    "name": "PMINUD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 3B /r V",
    "name": "PMINUD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed minimum values in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 3B /r V",
    "name": "PMINUD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed minimum values in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 3B /r V",
    "name": "PMINUD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 3B /r V",
    "name": "PMINUQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed minimum values in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 3B /r V",
    "name": "PMINUQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed minimum values in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 3B /r V",
    "name": "PMINUQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1."
  },
  {
    "opcode": "NP 0F D7 /r1",
    "name": "PMOVMSKB",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed"
  },
  {
    "opcode": "66 0F D7 /r",
    "name": "PMOVMSKB",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed"
  },
  {
    "opcode": "VEX.128.66.0F.WIG D7 /r V",
    "name": "PMOVMSKB",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Move a byte mask of xmm1 to reg. The upper bits of r32 or r64 are filled with zeros."
  },
  {
    "opcode": "VEX.256.66.0F.WIG D7 /r V",
    "name": "PMOVMSKB",
    "operands": [
      {
        "type": "reg",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Move a 32-bit mask of ymm1 to reg. The upper bits of r64 are filled with zeros."
  },
  {
    "opcode": "66 0f 38 20 /r",
    "name": "PMOVSXBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 21 /r",
    "name": "PMOVSXBD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 22 /r",
    "name": "PMOVSXBQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 23/r",
    "name": "PMOVSXWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 24 /r",
    "name": "PMOVSXWQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 25 /r",
    "name": "PMOVSXDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 20 /r V",
    "name": "PMOVSXBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 21 /r V",
    "name": "PMOVSXBD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 22 /r V",
    "name": "PMOVSXBQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 23 /r V",
    "name": "PMOVSXWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 24 /r V",
    "name": "PMOVSXWQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 25 /r V",
    "name": "PMOVSXDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 20 /r V",
    "name": "PMOVSXBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 21 /r V",
    "name": "PMOVSXBD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 22 /r V",
    "name": "PMOVSXBQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 23 /r V",
    "name": "PMOVSXWD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 24 /r V",
    "name": "PMOVSXWQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 25 /r V",
    "name": "PMOVSXDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 20 /r V",
    "name": "PMOVSXBW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sign extend 8 packed 8-bit integers in xmm2/m64 to 8 packed 16-bit integers in zmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 20 /r V",
    "name": "PMOVSXBW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 20 /r V",
    "name": "PMOVSXBW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Sign extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 21 /r V",
    "name": "PMOVSXBD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 21 /r V",
    "name": "PMOVSXBD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 21 /r V",
    "name": "PMOVSXBD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Sign extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 22 /r V",
    "name": "PMOVSXBQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 22 /r V",
    "name": "PMOVSXBQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 22 /r V",
    "name": "PMOVSXBQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 23 /r V",
    "name": "PMOVSXWD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 4 packed 16-bit integers in the low 8 bytes of ymm2/mem to 4 packed 32-bit integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 23 /r V",
    "name": "PMOVSXWD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 8 packed 16-bit integers in the low 16 bytes of ymm2/m128 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 23 /r V",
    "name": "PMOVSXWD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Sign extend 16 packed 16-bit integers in the low 32 bytes of ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 24 /r V",
    "name": "PMOVSXWQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 24 /r V",
    "name": "PMOVSXWQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 24 /r V",
    "name": "PMOVSXWQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 25 /r V",
    "name": "PMOVSXDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 25 /r V",
    "name": "PMOVSXDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 25 /r V",
    "name": "PMOVSXDQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Sign extend 8 packed 32-bit integers in the low 32 bytes of ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1."
  },
  {
    "opcode": "66 0f 38 30 /r",
    "name": "PMOVZXBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 31 /r",
    "name": "PMOVZXBD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 32 /r",
    "name": "PMOVZXBQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 33 /r",
    "name": "PMOVZXWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 34 /r",
    "name": "PMOVZXWQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "66 0f 38 35 /r",
    "name": "PMOVZXDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 30 /r V",
    "name": "PMOVZXBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 31 /r V",
    "name": "PMOVZXBD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 32 /r V",
    "name": "PMOVZXBQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 33 /r V",
    "name": "PMOVZXWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 34 /r V",
    "name": "PMOVZXWQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F 38.WIG 35 /r V",
    "name": "PMOVZXDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 30 /r V",
    "name": "PMOVZXBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 31 /r V",
    "name": "PMOVZXBD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 32 /r V",
    "name": "PMOVZXBQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 33 /r V",
    "name": "PMOVZXWD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Zero extend 8 packed 16-bit integers xmm2/m128 to 8 packed 32-bit integers in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 34 /r V",
    "name": "PMOVZXWQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 35 /r V",
    "name": "PMOVZXDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38 30.WIG /r V",
    "name": "PMOVZXBW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 30 /r V",
    "name": "PMOVZXBW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 30 /r V",
    "name": "PMOVZXBW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Zero extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 31 /r V",
    "name": "PMOVZXBD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 31 /r V",
    "name": "PMOVZXBD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 31 /r V",
    "name": "PMOVZXBD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 32 /r V",
    "name": "PMOVZXBQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 32 /r V",
    "name": "PMOVZXBQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 32 /r V",
    "name": "PMOVZXBQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 33 /r V",
    "name": "PMOVZXWD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 33 /r V",
    "name": "PMOVZXWD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 32-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 33 /r V",
    "name": "PMOVZXWD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Zero extend 16 packed 16-bit integers in ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 34 /r V",
    "name": "PMOVZXWQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 34 /r V",
    "name": "PMOVZXWQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 34 /r V",
    "name": "PMOVZXWQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 35 /r V",
    "name": "PMOVZXDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 35 /r V",
    "name": "PMOVZXDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 35 /r V",
    "name": "PMOVZXDQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Zero extend 8 packed 32-bit integers in ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1."
  },
  {
    "opcode": "66 0F 38 28 /r",
    "name": "PMULDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Multiply packed signed doubleword integers in xmm1 by packed signed doubleword integers in xmm2/m128, and store the quadword results in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 28 /r V",
    "name": "PMULDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 28 /r V",
    "name": "PMULDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 28 /r V",
    "name": "PMULDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 28 /r V",
    "name": "PMULDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 28 /r V",
    "name": "PMULDQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed signed doubleword integers in zmm2 by packed signed doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 using writemask k1."
  },
  {
    "opcode": "NP 0F 38 0B /r1",
    "name": "PMULHRSW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to mm1."
  },
  {
    "opcode": "66 0F 38 0B /r",
    "name": "PMULHRSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 0B /r V",
    "name": "PMULHRSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 0B /r V",
    "name": "PMULHRSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 0B /r V",
    "name": "PMULHRSW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 0B /r V",
    "name": "PMULHRSW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 0B /r V",
    "name": "PMULHRSW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to zmm1 under writemask k1."
  },
  {
    "opcode": "NP 0F E4 /r1",
    "name": "PMULHUW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
  },
  {
    "opcode": "66 0F E4 /r",
    "name": "PMULHUW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E4 /r V",
    "name": "PMULHUW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E4 /r V",
    "name": "PMULHUW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG E4 /r V",
    "name": "PMULHUW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG E4 /r V",
    "name": "PMULHUW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG E4 /r V",
    "name": "PMULHUW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Multiply the packed unsigned word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1."
  },
  {
    "opcode": "NP 0F E5 /r1",
    "name": "PMULHW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
  },
  {
    "opcode": "66 0F E5 /r",
    "name": "PMULHW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E5 /r V",
    "name": "PMULHW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E5 /r V",
    "name": "PMULHW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG E5 /r V",
    "name": "PMULHW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG E5 /r V",
    "name": "PMULHW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG E5 /r V",
    "name": "PMULHW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1."
  },
  {
    "opcode": "66 0F 38 40 /r",
    "name": "PMULLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 40 /r V",
    "name": "PMULLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 40 /r V",
    "name": "PMULLD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 40 /r V",
    "name": "PMULLD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply the packed dword signed integers in xmm2 and xmm3/m128/m32bcst and store the low 32 bits of each product in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 40 /r V",
    "name": "PMULLD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply the packed dword signed integers in ymm2 and ymm3/m256/m32bcst and store the low 32 bits of each product in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 40 /r V",
    "name": "PMULLD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply the packed dword signed integers in zmm2 and zmm3/m512/m32bcst and store the low 32 bits of each product in zmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 40 /r V",
    "name": "PMULLQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Multiply the packed qword signed integers in xmm2 and xmm3/m128/m64bcst and store the low 64 bits of each product in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 40 /r V",
    "name": "PMULLQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Multiply the packed qword signed integers in ymm2 and ymm3/m256/m64bcst and store the low 64 bits of each product in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 40 /r V",
    "name": "PMULLQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Multiply the packed qword signed integers in zmm2 and zmm3/m512/m64bcst and store the low 64 bits of each product in zmm1 under writemask k1."
  },
  {
    "opcode": "NP 0F D5 /r1",
    "name": "PMULLW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1."
  },
  {
    "opcode": "66 0F D5 /r",
    "name": "PMULLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG D5 /r V",
    "name": "PMULLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG D5 /r V",
    "name": "PMULLW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG D5 /r V",
    "name": "PMULLW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the low 16 bits of the results in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG D5 /r V",
    "name": "PMULLW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG D5 /r V",
    "name": "PMULLW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the low 16 bits of the results in zmm1 under writemask k1."
  },
  {
    "opcode": "NP 0F F4 /r1",
    "name": "PMULUDQ",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1."
  },
  {
    "opcode": "66 0F F4 /r",
    "name": "PMULUDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F4 /r V",
    "name": "PMULUDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG F4 /r V",
    "name": "PMULUDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 F4 /r V",
    "name": "PMULUDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 F4 /r V",
    "name": "PMULUDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 F4 /r V",
    "name": "PMULUDQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed unsigned doubleword integers in zmm2 by packed unsigned doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 under writemask k1."
  },
  {
    "opcode": "8F /0",
    "name": "POP",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Pop top of stack into m16; increment stack pointer."
  },
  {
    "opcode": "8F /0",
    "name": "POP",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Pop top of stack into m32; increment stack pointer."
  },
  {
    "opcode": "8F /0",
    "name": "POP",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size."
  },
  {
    "opcode": "58+ rw",
    "name": "POP",
    "operands": [
      {
        "type": "r16",
        "encoding": "opcode + rd (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Pop top of stack into r16; increment stack pointer."
  },
  {
    "opcode": "58+ rd",
    "name": "POP",
    "operands": [
      {
        "type": "r32",
        "encoding": "opcode + rd (w)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Pop top of stack into r32; increment stack pointer."
  },
  {
    "opcode": "58+ rd",
    "name": "POP",
    "operands": [
      {
        "type": "r64",
        "encoding": "opcode + rd (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size."
  },
  {
    "opcode": "1F",
    "name": "POP",
    "operands": [
      {
        "type": "DS"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Pop top of stack into DS; increment stack pointer."
  },
  {
    "opcode": "07",
    "name": "POP",
    "operands": [
      {
        "type": "ES"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Pop top of stack into ES; increment stack pointer."
  },
  {
    "opcode": "17",
    "name": "POP",
    "operands": [
      {
        "type": "SS"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Pop top of stack into SS; increment stack pointer."
  },
  {
    "opcode": "0F A1",
    "name": "POP",
    "operands": [
      {
        "type": "FS"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Pop top of stack into FS; increment stack pointer by 16 bits."
  },
  {
    "opcode": "0F A1",
    "name": "POP",
    "operands": [
      {
        "type": "FS"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Pop top of stack into FS; increment stack pointer by 32 bits."
  },
  {
    "opcode": "0F A1",
    "name": "POP",
    "operands": [
      {
        "type": "FS"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Pop top of stack into FS; increment stack pointer by 64 bits."
  },
  {
    "opcode": "0F A9",
    "name": "POP",
    "operands": [
      {
        "type": "GS"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Pop top of stack into GS; increment stack pointer by 16 bits."
  },
  {
    "opcode": "0F A9",
    "name": "POP",
    "operands": [
      {
        "type": "GS"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Pop top of stack into GS; increment stack pointer by 32 bits."
  },
  {
    "opcode": "0F A9",
    "name": "POP",
    "operands": [
      {
        "type": "GS"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Pop top of stack into GS; increment stack pointer by 64 bits."
  },
  {
    "opcode": "61",
    "name": "POPA",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Pop DI, SI, BP, BX, DX, CX, and AX."
  },
  {
    "opcode": "61",
    "name": "POPAD",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX."
  },
  {
    "opcode": "F3 0F B8 /r",
    "name": "POPCNT",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "POPCNT on r/m16"
  },
  {
    "opcode": "F3 0F B8 /r",
    "name": "POPCNT",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "POPCNT on r/m32"
  },
  {
    "opcode": "F3 REX.W 0F B8 /r",
    "name": "POPCNT",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "POPCNT on r/m64"
  },
  {
    "opcode": "9D",
    "name": "POPF",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Pop top of stack into lower 16 bits of EFLAGS."
  },
  {
    "opcode": "9D",
    "name": "POPFD",
    "operands": [],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Pop top of stack into EFLAGS."
  },
  {
    "opcode": "9D",
    "name": "POPFQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Pop top of stack and zero-extend into RFLAGS."
  },
  {
    "opcode": "NP 0F EB /r1",
    "name": "POR",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Bitwise OR of mm/m64 and mm."
  },
  {
    "opcode": "66 0F EB /r",
    "name": "POR",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Bitwise OR of xmm2/m128 and xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG EB /r V",
    "name": "POR",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Bitwise OR of xmm2/m128 and xmm3."
  },
  {
    "opcode": "VEX.256.66.0F.WIG EB /r V",
    "name": "POR",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Bitwise OR of ymm2/m256 and ymm3."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 EB /r V",
    "name": "PORD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise OR of packed doubleword integers in xmm2 and xmm3/m128/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 EB /r V",
    "name": "PORD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise OR of packed doubleword integers in ymm2 and ymm3/m256/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 EB /r V",
    "name": "PORD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise OR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 EB /r V",
    "name": "PORQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise OR of packed quadword integers in xmm2 and xmm3/m128/m64bcst using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 EB /r V",
    "name": "PORQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise OR of packed quadword integers in ymm2 and ymm3/m256/m64bcst using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 EB /r V",
    "name": "PORQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise OR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1."
  },
  {
    "opcode": "0F 0D /1",
    "name": "PREFETCHW",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "PREFETCHW",
    "desc": "Move data from m8 closer to the processor in anticipation of a write."
  },
  {
    "opcode": "0F 18 /1",
    "name": "PREFETCHT0",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move data from m8 closer to the processor using T0 hint."
  },
  {
    "opcode": "0F 18 /2",
    "name": "PREFETCHT1",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move data from m8 closer to the processor using T1 hint."
  },
  {
    "opcode": "0F 18 /3",
    "name": "PREFETCHT2",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move data from m8 closer to the processor using T2 hint."
  },
  {
    "opcode": "0F 18 /0",
    "name": "PREFETCHNTA",
    "operands": [
      {
        "type": "m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move data from m8 closer to the processor using NTA hint."
  },
  {
    "opcode": "NP 0F F6 /r1",
    "name": "PSADBW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result."
  },
  {
    "opcode": "66 0F F6 /r",
    "name": "PSADBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F6 /r V",
    "name": "PSADBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
  },
  {
    "opcode": "VEX.256.66.0F.WIG F6 /r V",
    "name": "PSADBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG F6 /r V",
    "name": "PSADBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG F6 /r V",
    "name": "PSADBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG F6 /r V",
    "name": "PSADBW",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Computes the absolute differences of the packed unsigned byte integers from zmm3 /m512 and zmm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
  },
  {
    "opcode": "NP 0F 38 00 /r1",
    "name": "PSHUFB",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Shuffle bytes in mm1 according to contents of mm2/m64."
  },
  {
    "opcode": "66 0F 38 00 /r",
    "name": "PSHUFB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSSE3",
    "desc": "Shuffle bytes in xmm1 according to contents of xmm2/m128."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 00 /r V",
    "name": "PSHUFB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shuffle bytes in xmm2 according to contents of xmm3/m128."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 00 /r V",
    "name": "PSHUFB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shuffle bytes in ymm2 according to contents of ymm3/m256."
  },
  {
    "opcode": "EVEX.128.66.0F38.WIG 00 /r V",
    "name": "PSHUFB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shuffle bytes in xmm2 according to contents of xmm3/m128 under write mask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.WIG 00 /r V",
    "name": "PSHUFB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shuffle bytes in ymm2 according to contents of ymm3/m256 under write mask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.WIG 00 /r V",
    "name": "PSHUFB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shuffle bytes in zmm2 according to contents of zmm3/m512 under write mask k1."
  },
  {
    "opcode": "66 0F 70 /r ib",
    "name": "PSHUFD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 70 /r ib V",
    "name": "PSHUFD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 70 /r ib V",
    "name": "PSHUFD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 70 /r ib V",
    "name": "PSHUFD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shuffle the doublewords in xmm2/m128/m32bcst based on the encoding in imm8 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 70 /r ib V",
    "name": "PSHUFD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shuffle the doublewords in ymm2/m256/m32bcst based on the encoding in imm8 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 70 /r ib V",
    "name": "PSHUFD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shuffle the doublewords in zmm2/m512/m32bcst based on the encoding in imm8 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "F3 0F 70 /r ib",
    "name": "PSHUFHW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
  },
  {
    "opcode": "VEX.128.F3.0F.WIG 70 /r ib V",
    "name": "PSHUFHW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
  },
  {
    "opcode": "VEX.256.F3.0F.WIG 70 /r ib V",
    "name": "PSHUFHW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.128.F3.0F.WIG 70 /r ib V",
    "name": "PSHUFHW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1 under write mask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.WIG 70 /r ib V",
    "name": "PSHUFHW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1 under write mask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.WIG 70 /r ib V",
    "name": "PSHUFHW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shuffle the high words in zmm2/m512 based on the encoding in imm8 and store the result in zmm1 under write mask k1."
  },
  {
    "opcode": "F2 0F 70 /r ib",
    "name": "PSHUFLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
  },
  {
    "opcode": "VEX.128.F2.0F.WIG 70 /r ib V",
    "name": "PSHUFLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
  },
  {
    "opcode": "VEX.256.F2.0F.WIG 70 /r ib V",
    "name": "PSHUFLW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.128.F2.0F.WIG 70 /r ib V",
    "name": "PSHUFLW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1 under write mask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.WIG 70 /r ib V",
    "name": "PSHUFLW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1 under write mask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.WIG 70 /r ib V",
    "name": "PSHUFLW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shuffle the low words in zmm2/m512 based on the encoding in imm8 and store the result in zmm1 under write mask k1."
  },
  {
    "opcode": "NP 0F 70 /r ib",
    "name": "PSHUFW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1."
  },
  {
    "opcode": "66 0F 73 /7 ib",
    "name": "PSLLDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift xmm1 left by imm8 bytes while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 73 /7 ib V",
    "name": "PSLLDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 73 /7 ib V",
    "name": "PSLLDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 73 /7 ib V",
    "name": "PSLLDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "EVEX.vvvv (w)"
      },
      {
        "type": "xmm2/ m128",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift xmm2/m128 left by imm8 bytes while shifting in 0s and store result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG 73 /7 ib V",
    "name": "PSLLDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "EVEX.vvvv (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift ymm2/m256 left by imm8 bytes while shifting in 0s and store result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG 73 /7 ib V",
    "name": "PSLLDQ",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "EVEX.vvvv (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift zmm2/m512 left by imm8 bytes while shifting in 0s and store result in zmm1."
  },
  {
    "opcode": "NP 0F F1 /r1",
    "name": "PSLLW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift words in mm left mm/m64 while shifting in 0s."
  },
  {
    "opcode": "66 0F F1 /r",
    "name": "PSLLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift words in xmm1 left by xmm2/m128 while shifting in 0s."
  },
  {
    "opcode": "NP 0F 71 /6 ib",
    "name": "PSLLW",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift words in mm left by imm8 while shifting in 0s."
  },
  {
    "opcode": "66 0F 71 /6 ib",
    "name": "PSLLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift words in xmm1 left by imm8 while shifting in 0s."
  },
  {
    "opcode": "NP 0F F2 /r1",
    "name": "PSLLD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift doublewords in mm left by mm/m64 while shifting in 0s."
  },
  {
    "opcode": "66 0F F2 /r",
    "name": "PSLLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s."
  },
  {
    "opcode": "NP 0F 72 /6 ib1",
    "name": "PSLLD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift doublewords in mm left by imm8 while shifting in 0s."
  },
  {
    "opcode": "66 0F 72 /6 ib",
    "name": "PSLLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift doublewords in xmm1 left by imm8 while shifting in 0s."
  },
  {
    "opcode": "NP 0F F3 /r1",
    "name": "PSLLQ",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift quadword in mm left by mm/m64 while shifting in 0s."
  },
  {
    "opcode": "66 0F F3 /r",
    "name": "PSLLQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s."
  },
  {
    "opcode": "NP 0F 73 /6 ib1",
    "name": "PSLLQ",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift quadword in mm left by imm8 while shifting in 0s."
  },
  {
    "opcode": "66 0F 73 /6 ib",
    "name": "PSLLQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift quadwords in xmm1 left by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F1 /r V",
    "name": "PSLLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 71 /6 ib V",
    "name": "PSLLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift words in xmm2 left by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F2 /r V",
    "name": "PSLLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 72 /6 ib V",
    "name": "PSLLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift doublewords in xmm2 left by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F3 /r V",
    "name": "PSLLQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 73 /6 ib V",
    "name": "PSLLQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift quadwords in xmm2 left by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F.WIG F1 /r V",
    "name": "PSLLW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 71 /6 ib V",
    "name": "PSLLW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift words in ymm2 left by imm8 while shifting in 0s."
  },
  {
    "opcode": "NP 0F E1 /r1",
    "name": "PSRAW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift words in mm right by mm/m64 while shifting in sign bits."
  },
  {
    "opcode": "66 0F E1 /r",
    "name": "PSRAW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift words in xmm1 right by xmm2/m128 while shifting in sign bits."
  },
  {
    "opcode": "NP 0F 71 /4 ib1",
    "name": "PSRAW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift words in mm right by imm8 while shifting in sign bits"
  },
  {
    "opcode": "66 0F 71 /4 ib",
    "name": "PSRAW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift words in xmm1 right by imm8 while shifting in sign bits"
  },
  {
    "opcode": "NP 0F E2 /r1",
    "name": "PSRAD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift doublewords in mm right by mm/m64 while shifting in sign bits."
  },
  {
    "opcode": "66 0F E2 /r",
    "name": "PSRAD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits."
  },
  {
    "opcode": "NP 0F 72 /4 ib1",
    "name": "PSRAD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift doublewords in mm right by imm8 while shifting in sign bits."
  },
  {
    "opcode": "66 0F 72 /4 ib",
    "name": "PSRAD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift doublewords in xmm1 right by imm8 while shifting in sign bits."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E1 /r V",
    "name": "PSRAW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 71 /4 ib V",
    "name": "PSRAW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift words in xmm2 right by imm8 while shifting in sign bits."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E2 /r V",
    "name": "PSRAD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 72 /4 ib V",
    "name": "PSRAD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift doublewords in xmm2 right by imm8 while shifting in sign bits."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E1 /r V",
    "name": "PSRAW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 71 /4 ib V",
    "name": "PSRAW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift words in ymm2 right by imm8 while shifting in sign bits."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E2 /r V",
    "name": "PSRAD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 72 /4 ib V",
    "name": "PSRAD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift doublewords in ymm2 right by imm8 while shifting in sign bits."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG E1 /r V",
    "name": "PSRAW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG E1 /r V",
    "name": "PSRAW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG E1 /r V",
    "name": "PSRAW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "66 0F 73 /3 ib",
    "name": "PSRLDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift xmm1 right by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 73 /3 ib V",
    "name": "PSRLDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift xmm2 right by imm8 bytes while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 73 /3 ib V",
    "name": "PSRLDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift ymm1 right by imm8 bytes while shifting in 0s."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 73 /3 ib V",
    "name": "PSRLDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "EVEX.vvvv (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift xmm2/m128 right by imm8 bytes while shifting in 0s and store result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG 73 /3 ib V",
    "name": "PSRLDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "EVEX.vvvv (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift ymm2/m256 right by imm8 bytes while shifting in 0s and store result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG 73 /3 ib V",
    "name": "PSRLDQ",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "EVEX.vvvv (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift zmm2/m512 right by imm8 bytes while shifting in 0s and store result in zmm1."
  },
  {
    "opcode": "NP 0F D1 /r1",
    "name": "PSRLW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift words in mm right by amount specified in mm/m64 while shifting in 0s."
  },
  {
    "opcode": "66 0F D1 /r",
    "name": "PSRLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
  },
  {
    "opcode": "NP 0F 71 /2 ib1",
    "name": "PSRLW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift words in mm right by imm8 while shifting in 0s."
  },
  {
    "opcode": "66 0F 71 /2 ib",
    "name": "PSRLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift words in xmm1 right by imm8 while shifting in 0s."
  },
  {
    "opcode": "NP 0F D2 /r1",
    "name": "PSRLD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s."
  },
  {
    "opcode": "66 0F D2 /r",
    "name": "PSRLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s."
  },
  {
    "opcode": "NP 0F 72 /2 ib1",
    "name": "PSRLD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift doublewords in mm right by imm8 while shifting in 0s."
  },
  {
    "opcode": "66 0F 72 /2 ib",
    "name": "PSRLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift doublewords in xmm1 right by imm8 while shifting in 0s."
  },
  {
    "opcode": "NP 0F D3 /r1",
    "name": "PSRLQ",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift mm right by amount specified in mm/m64 while shifting in 0s."
  },
  {
    "opcode": "66 0F D3 /r",
    "name": "PSRLQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
  },
  {
    "opcode": "NP 0F 73 /2 ib1",
    "name": "PSRLQ",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Shift mm right by imm8 while shifting in 0s."
  },
  {
    "opcode": "66 0F 73 /2 ib",
    "name": "PSRLQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shift quadwords in xmm1 right by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG D1 /r V",
    "name": "PSRLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 71 /2 ib V",
    "name": "PSRLW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift words in xmm2 right by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG D2 /r V",
    "name": "PSRLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 72 /2 ib V",
    "name": "PSRLD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift doublewords in xmm2 right by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG D3 /r V",
    "name": "PSRLQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 73 /2 ib V",
    "name": "PSRLQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shift quadwords in xmm2 right by imm8 while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F.WIG D1 /r V",
    "name": "PSRLW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 71 /2 ib V",
    "name": "PSRLW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift words in ymm2 right by imm8 while shifting in 0s."
  },
  {
    "opcode": "NP 0F F8 /r1",
    "name": "PSUBB",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Subtract packed byte integers in mm/m64 from packed byte integers in mm."
  },
  {
    "opcode": "66 0F F8 /r",
    "name": "PSUBB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1."
  },
  {
    "opcode": "NP 0F F9 /r1",
    "name": "PSUBW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Subtract packed word integers in mm/m64 from packed word integers in mm."
  },
  {
    "opcode": "66 0F F9 /r",
    "name": "PSUBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed word integers in xmm2/m128 from packed word integers in xmm1."
  },
  {
    "opcode": "NP 0F FA /r1",
    "name": "PSUBD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm."
  },
  {
    "opcode": "66 0F FA /r",
    "name": "PSUBD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F8 /r V",
    "name": "PSUBB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed byte integers in xmm3/m128 from xmm2."
  },
  {
    "opcode": "VEX.128.66.0F.WIG F9 /r V",
    "name": "PSUBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed word integers in xmm3/m128 from xmm2."
  },
  {
    "opcode": "VEX.128.66.0F.WIG FA /r V",
    "name": "PSUBD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed doubleword integers in xmm3/m128 from xmm2."
  },
  {
    "opcode": "VEX.256.66.0F.WIG F8 /r V",
    "name": "PSUBB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract packed byte integers in ymm3/m256 from ymm2."
  },
  {
    "opcode": "VEX.256.66.0F.WIG F9 /r V",
    "name": "PSUBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract packed word integers in ymm3/m256 from ymm2."
  },
  {
    "opcode": "VEX.256.66.0F.WIG FA /r V",
    "name": "PSUBD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract packed doubleword integers in ymm3/m256 from ymm2."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG F8 /r V",
    "name": "PSUBB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed byte integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG F8 /r V",
    "name": "PSUBB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed byte integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG F8 /r V",
    "name": "PSUBB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Subtract packed byte integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG F9 /r V",
    "name": "PSUBW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed word integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG F9 /r V",
    "name": "PSUBW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed word integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG F9 /r V",
    "name": "PSUBW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Subtract packed word integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1."
  },
  {
    "opcode": "NP 0F FB /r1",
    "name": "PSUBQ",
    "operands": [
      {
        "type": "mm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract quadword integer in mm1 from mm2 /m64."
  },
  {
    "opcode": "66 0F FB /r",
    "name": "PSUBQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed quadword integers in xmm1 from xmm2 /m128."
  },
  {
    "opcode": "VEX.128.66.0F.WIG FB/r V",
    "name": "PSUBQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed quadword integers in xmm3/m128 from xmm2."
  },
  {
    "opcode": "VEX.256.66.0F.WIG FB /r V",
    "name": "PSUBQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract packed quadword integers in ymm3/m256 from ymm2."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 FB /r V",
    "name": "PSUBQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Subtract packed quadword integers in xmm3/m128/m64bcst from xmm2 and store in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 FB /r V",
    "name": "PSUBQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Subtract packed quadword integers in ymm3/m256/m64bcst from ymm2 and store in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 FB/r V",
    "name": "PSUBQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Subtract packed quadword integers in zmm3/m512/m64bcst from zmm2 and store in zmm1 using writemask k1."
  },
  {
    "opcode": "NP 0F E8 /r1",
    "name": "PSUBSB",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results."
  },
  {
    "opcode": "66 0F E8 /r",
    "name": "PSUBSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results."
  },
  {
    "opcode": "NP 0F E9 /r1",
    "name": "PSUBSW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results."
  },
  {
    "opcode": "66 0F E9 /r",
    "name": "PSUBSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E8 /r V",
    "name": "PSUBSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results."
  },
  {
    "opcode": "VEX.128.66.0F.WIG E9 /r V",
    "name": "PSUBSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E8 /r V",
    "name": "PSUBSB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results."
  },
  {
    "opcode": "VEX.256.66.0F.WIG E9 /r V",
    "name": "PSUBSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG E8 /r V",
    "name": "PSUBSB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results and store in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG E8 /r V",
    "name": "PSUBSB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results and store in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG E8 /r V",
    "name": "PSUBSB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Subtract packed signed byte integers in zmm3/m512 from packed signed byte integers in zmm2 and saturate results and store in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG E9 /r V",
    "name": "PSUBSW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results and store in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG E9 /r V",
    "name": "PSUBSW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results and store in ymm1 using writemask k1."
  },
  {
    "opcode": "NP 0F D8 /r1",
    "name": "PSUBUSB",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result."
  },
  {
    "opcode": "66 0F D8 /r",
    "name": "PSUBUSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result."
  },
  {
    "opcode": "NP 0F D9 /r1",
    "name": "PSUBUSW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result."
  },
  {
    "opcode": "66 0F D9 /r",
    "name": "PSUBUSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result."
  },
  {
    "opcode": "VEX.128.66.0F.WIG D8 /r V",
    "name": "PSUBUSB",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result."
  },
  {
    "opcode": "VEX.128.66.0F.WIG D9 /r V",
    "name": "PSUBUSW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result."
  },
  {
    "opcode": "VEX.256.66.0F.WIG D8 /r V",
    "name": "PSUBUSB",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result."
  },
  {
    "opcode": "VEX.256.66.0F.WIG D9 /r V",
    "name": "PSUBUSW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG D8 /r V",
    "name": "PSUBUSB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2, saturate results and store in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG D8 /r V",
    "name": "PSUBUSB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2, saturate results and store in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.WIG D8 /r V",
    "name": "PSUBUSB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Subtract packed unsigned byte integers in zmm3/m512 from packed unsigned byte integers in zmm2, saturate results and store in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG D9 /r V",
    "name": "PSUBUSW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate results and store in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.WIG D9 /r V",
    "name": "PSUBUSW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2, saturate results and store in ymm1 using writemask k1."
  },
  {
    "opcode": "66 0F 38 17 /r",
    "name": "PTEST",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s."
  },
  {
    "opcode": "VEX.128.66.0F38.WIG 17 /r V",
    "name": "PTEST",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Set ZF and CF depending on bitwise AND and ANDN of sources."
  },
  {
    "opcode": "VEX.256.66.0F38.WIG 17 /r V",
    "name": "PTEST",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Set ZF and CF depending on bitwise AND and ANDN of sources."
  },
  {
    "opcode": "F3 REX.W 0F AE /4",
    "name": "PTWRITE",
    "operands": [
      {
        "type": "r64/m64",
        "encoding": "ModRM:rm (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e",
    "flag": "Reads the data from r64/m64 to encode into a PTW packet if dependencies are met (see details below)."
  },
  {
    "opcode": "F3 0F AE /4",
    "name": "PTWRITE",
    "operands": [
      {
        "type": "r32/m32",
        "encoding": "ModRM:rm (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "Reads the data from r32/m32 to encode into a PTW packet if dependencies are met (see details below)."
  },
  {
    "opcode": "NP 0F 68 /r1",
    "name": "PUNPCKHBW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Unpack and interleave high-order bytes from mm and mm/m64 into mm."
  },
  {
    "opcode": "66 0F 68 /r",
    "name": "PUNPCKHBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1."
  },
  {
    "opcode": "NP 0F 69 /r1",
    "name": "PUNPCKHWD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Unpack and interleave high-order words from mm and mm/m64 into mm."
  },
  {
    "opcode": "66 0F 69 /r",
    "name": "PUNPCKHWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1."
  },
  {
    "opcode": "NP 0F 6A /r1",
    "name": "PUNPCKHDQ",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Unpack and interleave high-order doublewords from mm and mm/m64 into mm."
  },
  {
    "opcode": "66 0F 6A /r",
    "name": "PUNPCKHDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1."
  },
  {
    "opcode": "66 0F 6D /r",
    "name": "PUNPCKHQDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 68/r V",
    "name": "PUNPCKHBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 69/r V",
    "name": "PUNPCKHWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Interleave high-order words from xmm2 and xmm3/m128 into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 6A/r V",
    "name": "PUNPCKHDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 6D/r V",
    "name": "PUNPCKHQDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 68 /r V",
    "name": "PUNPCKHBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 69 /r V",
    "name": "PUNPCKHWD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 6A /r V",
    "name": "PUNPCKHDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 6D /r V",
    "name": "PUNPCKHQDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 68 /r V",
    "name": "PUNPCKHBW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1 register using k1 write mask."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 69 /r V",
    "name": "PUNPCKHWD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Interleave high-order words from xmm2 and xmm3/m128 into xmm1 register using k1 write mask."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 6A /r V",
    "name": "PUNPCKHDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Interleave high-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register using k1 write mask."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 6D /r V",
    "name": "PUNPCKHQDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Interleave high-order quadword from xmm2 and xmm3/m128/m64bcst into xmm1 register using k1 write mask."
  },
  {
    "opcode": "NP 0F 60 /r1",
    "name": "PUNPCKLBW",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Interleave low-order bytes from mm and mm/m32 into mm."
  },
  {
    "opcode": "66 0F 60 /r",
    "name": "PUNPCKLBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1."
  },
  {
    "opcode": "NP 0F 61 /r1",
    "name": "PUNPCKLWD",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Interleave low-order words from mm and mm/m32 into mm."
  },
  {
    "opcode": "66 0F 61 /r",
    "name": "PUNPCKLWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Interleave low-order words from xmm1 and xmm2/m128 into xmm1."
  },
  {
    "opcode": "NP 0F 62 /r1",
    "name": "PUNPCKLDQ",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Interleave low-order doublewords from mm and mm/m32 into mm."
  },
  {
    "opcode": "66 0F 62 /r",
    "name": "PUNPCKLDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1."
  },
  {
    "opcode": "66 0F 6C /r",
    "name": "PUNPCKLQDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 60/r V",
    "name": "PUNPCKLBW",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 61/r V",
    "name": "PUNPCKLWD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Interleave low-order words from xmm2 and xmm3/m128 into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 62/r V",
    "name": "PUNPCKLDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 6C/r V",
    "name": "PUNPCKLQDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 60 /r V",
    "name": "PUNPCKLBW",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 61 /r V",
    "name": "PUNPCKLWD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 62 /r V",
    "name": "PUNPCKLDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 6C /r V",
    "name": "PUNPCKLQDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 60 /r V",
    "name": "PUNPCKLBW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.WIG 61 /r V",
    "name": "PUNPCKLWD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Interleave low-order words from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 62 /r V",
    "name": "PUNPCKLDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Interleave low-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register subject to write mask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 6C /r V",
    "name": "PUNPCKLQDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Interleave low-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register subject to write mask k1."
  },
  {
    "opcode": "FF /6",
    "name": "PUSH",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push r/m16."
  },
  {
    "opcode": "FF /6",
    "name": "PUSH",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Push r/m32."
  },
  {
    "opcode": "FF /6",
    "name": "PUSH",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Push r/m64."
  },
  {
    "opcode": "50+rw",
    "name": "PUSH",
    "operands": [
      {
        "type": "r16",
        "encoding": "opcode + rd (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push r16."
  },
  {
    "opcode": "50+rd",
    "name": "PUSH",
    "operands": [
      {
        "type": "r32",
        "encoding": "opcode + rd (r)"
      }
    ],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Push r32."
  },
  {
    "opcode": "50+rd",
    "name": "PUSH",
    "operands": [
      {
        "type": "r64",
        "encoding": "opcode + rd (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Push r64."
  },
  {
    "opcode": "6A ib",
    "name": "PUSH",
    "operands": [
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push imm8."
  },
  {
    "opcode": "68 iw",
    "name": "PUSH",
    "operands": [
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push imm16."
  },
  {
    "opcode": "68 id",
    "name": "PUSH",
    "operands": [
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push imm32."
  },
  {
    "opcode": "0E",
    "name": "PUSH",
    "operands": [
      {
        "type": "CS"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Push CS."
  },
  {
    "opcode": "16",
    "name": "PUSH",
    "operands": [
      {
        "type": "SS"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Push SS."
  },
  {
    "opcode": "1E",
    "name": "PUSH",
    "operands": [
      {
        "type": "DS"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Push DS."
  },
  {
    "opcode": "06",
    "name": "PUSH",
    "operands": [
      {
        "type": "ES"
      }
    ],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Push ES."
  },
  {
    "opcode": "0F A0",
    "name": "PUSH",
    "operands": [
      {
        "type": "FS"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push FS."
  },
  {
    "opcode": "0F A8",
    "name": "PUSH",
    "operands": [
      {
        "type": "GS"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push GS."
  },
  {
    "opcode": "60",
    "name": "PUSHA",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Push AX, CX, DX, BX, original SP, BP, SI, and DI."
  },
  {
    "opcode": "60",
    "name": "PUSHAD",
    "operands": [],
    "support64": "invalid",
    "compatibility": "valid",
    "desc": "Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI."
  },
  {
    "opcode": "9C",
    "name": "PUSHF",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Push lower 16 bits of EFLAGS."
  },
  {
    "opcode": "9C",
    "name": "PUSHFD",
    "operands": [],
    "support64": "n.e.",
    "compatibility": "valid",
    "desc": "Push EFLAGS."
  },
  {
    "opcode": "9C",
    "name": "PUSHFQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Push RFLAGS."
  },
  {
    "opcode": "NP 0F EF /r1",
    "name": "PXOR",
    "operands": [
      {
        "type": "mm",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "mm/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "MMX",
    "desc": "Bitwise XOR of mm/m64 and mm."
  },
  {
    "opcode": "66 0F EF /r",
    "name": "PXOR",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Bitwise XOR of xmm2/m128 and xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG EF /r V",
    "name": "PXOR",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Bitwise XOR of xmm3/m128 and xmm2."
  },
  {
    "opcode": "VEX.256.66.0F.WIG EF /r V",
    "name": "PXOR",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Bitwise XOR of ymm3/m256 and ymm2."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 EF /r V",
    "name": "PXORD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise XOR of packed doubleword integers in xmm2 and xmm3/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 EF /r V",
    "name": "PXORD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise XOR of packed doubleword integers in ymm2 and ymm3/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 EF /r V",
    "name": "PXORD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise XOR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 EF /r V",
    "name": "PXORQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise XOR of packed quadword integers in xmm2 and xmm3/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 EF /r V",
    "name": "PXORQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise XOR of packed quadword integers in ymm2 and ymm3/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 EF /r V",
    "name": "PXORQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise XOR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1."
  },
  {
    "opcode": "D0 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 9 bits (CF, r/m8) left once."
  },
  {
    "opcode": "REX + D0 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 9 bits (CF, r/m8) left once."
  },
  {
    "opcode": "D2 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 9 bits (CF, r/m8) left CL times."
  },
  {
    "opcode": "REX + D2 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 9 bits (CF, r/m8) left CL times."
  },
  {
    "opcode": "C0 /2 ib",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 9 bits (CF, r/m8) left imm8 times."
  },
  {
    "opcode": "REX + C0 /2 ib",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 9 bits (CF, r/m8) left imm8 times."
  },
  {
    "opcode": "D1 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 17 bits (CF, r/m16) left once."
  },
  {
    "opcode": "D3 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 17 bits (CF, r/m16) left CL times."
  },
  {
    "opcode": "C1 /2 ib",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 17 bits (CF, r/m16) left imm8 times."
  },
  {
    "opcode": "D1 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 33 bits (CF, r/m32) left once."
  },
  {
    "opcode": "REX.W + D1 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count."
  },
  {
    "opcode": "D3 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 33 bits (CF, r/m32) left CL times."
  },
  {
    "opcode": "REX.W + D3 /2",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count."
  },
  {
    "opcode": "C1 /2 ib",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 33 bits (CF, r/m32) left imm8 times."
  },
  {
    "opcode": "REX.W + C1 /2 ib",
    "name": "RCL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count."
  },
  {
    "opcode": "D0 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 9 bits (CF, r/m8) right once."
  },
  {
    "opcode": "REX + D0 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 9 bits (CF, r/m8) right once."
  },
  {
    "opcode": "D2 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 9 bits (CF, r/m8) right CL times."
  },
  {
    "opcode": "REX + D2 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 9 bits (CF, r/m8) right CL times."
  },
  {
    "opcode": "C0 /3 ib",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 9 bits (CF, r/m8) right imm8 times."
  },
  {
    "opcode": "REX + C0 /3 ib",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 9 bits (CF, r/m8) right imm8 times."
  },
  {
    "opcode": "D1 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 17 bits (CF, r/m16) right once."
  },
  {
    "opcode": "D3 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 17 bits (CF, r/m16) right CL times."
  },
  {
    "opcode": "C1 /3 ib",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 17 bits (CF, r/m16) right imm8 times."
  },
  {
    "opcode": "D1 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count."
  },
  {
    "opcode": "REX.W + D1 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count."
  },
  {
    "opcode": "D3 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 33 bits (CF, r/m32) right CL times."
  },
  {
    "opcode": "REX.W + D3 /3",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count."
  },
  {
    "opcode": "C1 /3 ib",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 33 bits (CF, r/m32) right imm8 times."
  },
  {
    "opcode": "REX.W + C1 /3 ib",
    "name": "RCR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count."
  },
  {
    "opcode": "D0 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 8 bits r/m8 left once."
  },
  {
    "opcode": "REX + D0 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 8 bits r/m8 left once"
  },
  {
    "opcode": "D2 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 8 bits r/m8 left CL times."
  },
  {
    "opcode": "REX + D2 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 8 bits r/m8 left CL times."
  },
  {
    "opcode": "C0 /0 ib",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 8 bits r/m8 left imm8 times."
  },
  {
    "opcode": "REX + C0 /0 ib",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 8 bits r/m8 left imm8 times."
  },
  {
    "opcode": "D1 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 16 bits r/m16 left once."
  },
  {
    "opcode": "D3 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 16 bits r/m16 left CL times."
  },
  {
    "opcode": "C1 /0 ib",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 16 bits r/m16 left imm8 times."
  },
  {
    "opcode": "D1 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 32 bits r/m32 left once."
  },
  {
    "opcode": "REX.W + D1 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 64 bits r/m64 left once. Uses a 6 bit count."
  },
  {
    "opcode": "D3 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 32 bits r/m32 left CL times."
  },
  {
    "opcode": "REX.W + D3 /0",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 64 bits r/m64 left CL times. Uses a 6 bit count."
  },
  {
    "opcode": "C1 /0 ib",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 32 bits r/m32 left imm8 times."
  },
  {
    "opcode": "REX.W + C1 /0 ib",
    "name": "ROL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count."
  },
  {
    "opcode": "D0 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 8 bits r/m8 right once."
  },
  {
    "opcode": "REX + D0 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 8 bits r/m8 right once."
  },
  {
    "opcode": "D2 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 8 bits r/m8 right CL times."
  },
  {
    "opcode": "REX + D2 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 8 bits r/m8 right CL times."
  },
  {
    "opcode": "C0 /1 ib",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 8 bits r/m16 right imm8 times."
  },
  {
    "opcode": "REX + C0 /1 ib",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 8 bits r/m16 right imm8 times."
  },
  {
    "opcode": "D1 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 16 bits r/m16 right once."
  },
  {
    "opcode": "D3 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 16 bits r/m16 right CL times."
  },
  {
    "opcode": "C1 /1 ib",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 16 bits r/m16 right imm8 times."
  },
  {
    "opcode": "D1 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 32 bits r/m32 right once."
  },
  {
    "opcode": "REX.W + D1 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 64 bits r/m64 right once. Uses a 6 bit count."
  },
  {
    "opcode": "D3 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 32 bits r/m32 right CL times."
  },
  {
    "opcode": "REX.W + D3 /1",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 64 bits r/m64 right CL times. Uses a 6 bit count."
  },
  {
    "opcode": "C1 /1 ib",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Rotate 32 bits r/m32 right imm8 times."
  },
  {
    "opcode": "REX.W + C1 /1 ib",
    "name": "ROR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count."
  },
  {
    "opcode": "NP 0F 53 /r",
    "name": "RCPPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 53 /r V",
    "name": "RCPPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 53 /r V",
    "name": "RCPPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1."
  },
  {
    "opcode": "F3 0F 53 /r",
    "name": "RCPSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 53 /r V",
    "name": "RCPSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the result in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
  },
  {
    "opcode": "F3 0F AE /0",
    "name": "RDFSBASE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "FSGSBASE",
    "desc": "Load the 32-bit destination register with the FS base address."
  },
  {
    "opcode": "F3 REX.W 0F AE /0",
    "name": "RDFSBASE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "FSGSBASE",
    "desc": "Load the 64-bit destination register with the FS base address."
  },
  {
    "opcode": "F3 0F AE /1",
    "name": "RDGSBASE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "FSGSBASE",
    "desc": "Load the 32-bit destination register with the GS base address."
  },
  {
    "opcode": "F3 REX.W 0F AE /1",
    "name": "RDGSBASE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "FSGSBASE",
    "desc": "Load the 64-bit destination register with the GS base address."
  },
  {
    "opcode": "F3 0F C7 /7",
    "name": "RDPID",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "n.e.",
    "support32": "v",
    "flag": "RDPID",
    "desc": "Read IA32_TSC_AUX into r32."
  },
  {
    "opcode": "F3 0F C7 /7",
    "name": "RDPID",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "RDPID",
    "desc": "Read IA32_TSC_AUX into r64."
  },
  {
    "opcode": "NP 0F 01 EE",
    "name": "RDPKRU",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "OSPKE",
    "desc": "Reads PKRU into EAX."
  },
  {
    "opcode": "0F 33",
    "name": "RDPMC",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Read performance-monitoring counter specified by ECX into EDX:EAX."
  },
  {
    "opcode": "NFx 0F C7 /6",
    "name": "RDRAND",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "RDRAND",
    "desc": "Read a 16-bit random number and store in the destination register."
  },
  {
    "opcode": "NFx 0F C7 /6",
    "name": "RDRAND",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "RDRAND",
    "desc": "Read a 32-bit random number and store in the destination register."
  },
  {
    "opcode": "NFx REX.W + 0F C7 /6",
    "name": "RDRAND",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "RDRAND",
    "desc": "Read a 64-bit random number and store in the destination register."
  },
  {
    "opcode": "NFx 0F C7 /7",
    "name": "RDSEED",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "RDSEED",
    "desc": "Read a 16-bit NIST SP800-90B & C compliant random value and store in the destination register."
  },
  {
    "opcode": "NFx 0F C7 /7",
    "name": "RDSEED",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "RDSEED",
    "desc": "Read a 32-bit NIST SP800-90B & C compliant random value and store in the destination register."
  },
  {
    "opcode": "NFx REX.W + 0F C7 /7",
    "name": "RDSEED",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "RDSEED",
    "desc": "Read a 64-bit NIST SP800-90B & C compliant random value and store in the destination register."
  },
  {
    "opcode": "0F 31",
    "name": "RDTSC",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Read time-stamp counter into EDX:EAX."
  },
  {
    "opcode": "0F 01 F9",
    "name": "RDTSCP",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Read 64-bit time-stamp counter and IA32_TSC_AUX value into EDX:EAX and ECX."
  },
  {
    "opcode": "F3 6C",
    "name": "REP",
    "operands": [
      {
        "type": "INS m8"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input (E)CX bytes from port DX into ES:[(E)DI]."
  },
  {
    "opcode": "F3 6C",
    "name": "REP",
    "operands": [
      {
        "type": "INS m8"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Input RCX bytes from port DX into [RDI]."
  },
  {
    "opcode": "F3 6D",
    "name": "REP",
    "operands": [
      {
        "type": "INS m16"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input (E)CX words from port DX into ES:[(E)DI.]"
  },
  {
    "opcode": "F3 6D",
    "name": "REP",
    "operands": [
      {
        "type": "INS m32"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Input (E)CX doublewords from port DX into ES:[(E)DI]."
  },
  {
    "opcode": "F3 6D",
    "name": "REP",
    "operands": [
      {
        "type": "INS r/m32"
      },
      {
        "type": "DX"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Input RCX default size from port DX into [RDI]."
  },
  {
    "opcode": "F3 A4",
    "name": "REP",
    "operands": [
      {
        "type": "MOVS m8"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]."
  },
  {
    "opcode": "F3 REX.W A4",
    "name": "REP",
    "operands": [
      {
        "type": "MOVS m8"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move RCX bytes from [RSI] to [RDI]."
  },
  {
    "opcode": "F3 A5",
    "name": "REP",
    "operands": [
      {
        "type": "MOVS m16"
      },
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]."
  },
  {
    "opcode": "F3 A5",
    "name": "REP",
    "operands": [
      {
        "type": "MOVS m32"
      },
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]."
  },
  {
    "opcode": "F3 REX.W A5",
    "name": "REP",
    "operands": [
      {
        "type": "MOVS m64"
      },
      {
        "type": "m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Move RCX quadwords from [RSI] to [RDI]."
  },
  {
    "opcode": "F3 6E",
    "name": "REP",
    "operands": [
      {
        "type": "OUTS DX"
      },
      {
        "type": "r/m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output (E)CX bytes from DS:[(E)SI] to port DX."
  },
  {
    "opcode": "F3 REX.W 6E",
    "name": "REP",
    "operands": [
      {
        "type": "OUTS DX"
      },
      {
        "type": "r/m8*"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Output RCX bytes from [RSI] to port DX."
  },
  {
    "opcode": "F3 6F",
    "name": "REP",
    "operands": [
      {
        "type": "OUTS DX"
      },
      {
        "type": "r/m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output (E)CX words from DS:[(E)SI] to port DX."
  },
  {
    "opcode": "F3 6F",
    "name": "REP",
    "operands": [
      {
        "type": "OUTS DX"
      },
      {
        "type": "r/m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Output (E)CX doublewords from DS:[(E)SI] to port DX."
  },
  {
    "opcode": "F3 REX.W 6F",
    "name": "REP",
    "operands": [
      {
        "type": "OUTS DX"
      },
      {
        "type": "r/m32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Output RCX default size from [RSI] to port DX."
  },
  {
    "opcode": "F3 AC",
    "name": "REP",
    "operands": [
      {
        "type": "LODS AL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load (E)CX bytes from DS:[(E)SI] to AL."
  },
  {
    "opcode": "F3 REX.W AC",
    "name": "REP",
    "operands": [
      {
        "type": "LODS AL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load RCX bytes from [RSI] to AL."
  },
  {
    "opcode": "F3 AD",
    "name": "REP",
    "operands": [
      {
        "type": "LODS AX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load (E)CX words from DS:[(E)SI] to AX."
  },
  {
    "opcode": "F3 AD",
    "name": "REP",
    "operands": [
      {
        "type": "LODS EAX"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Load (E)CX doublewords from DS:[(E)SI] to EAX."
  },
  {
    "opcode": "F3 REX.W AD",
    "name": "REP",
    "operands": [
      {
        "type": "LODS RAX"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Load RCX quadwords from [RSI] to RAX."
  },
  {
    "opcode": "F3 AA",
    "name": "REP",
    "operands": [
      {
        "type": "STOS m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Fill (E)CX bytes at ES:[(E)DI] with AL."
  },
  {
    "opcode": "F3 REX.W AA",
    "name": "REP",
    "operands": [
      {
        "type": "STOS m8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Fill RCX bytes at [RDI] with AL."
  },
  {
    "opcode": "F3 AB",
    "name": "REP",
    "operands": [
      {
        "type": "STOS m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Fill (E)CX words at ES:[(E)DI] with AX."
  },
  {
    "opcode": "F3 AB",
    "name": "REP",
    "operands": [
      {
        "type": "STOS m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Fill (E)CX doublewords at ES:[(E)DI] with EAX."
  },
  {
    "opcode": "F3 REX.W AB",
    "name": "REP",
    "operands": [
      {
        "type": "STOS m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Fill RCX quadwords at [RDI] with RAX."
  },
  {
    "opcode": "F3 A6",
    "name": "REPE",
    "operands": [
      {
        "type": "CMPS m8"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]."
  },
  {
    "opcode": "F3 REX.W A6",
    "name": "REPE",
    "operands": [
      {
        "type": "CMPS m8"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Find non-matching bytes in [RDI] and [RSI]."
  },
  {
    "opcode": "F3 A7",
    "name": "REPE",
    "operands": [
      {
        "type": "CMPS m16"
      },
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]."
  },
  {
    "opcode": "F3 A7",
    "name": "REPE",
    "operands": [
      {
        "type": "CMPS m32"
      },
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]."
  },
  {
    "opcode": "F3 REX.W A7",
    "name": "REPE",
    "operands": [
      {
        "type": "CMPS m64"
      },
      {
        "type": "m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Find non-matching quadwords in [RDI] and [RSI]."
  },
  {
    "opcode": "F3 AE",
    "name": "REPE",
    "operands": [
      {
        "type": "SCAS m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find non-AL byte starting at ES:[(E)DI]."
  },
  {
    "opcode": "F3 REX.W AE",
    "name": "REPE",
    "operands": [
      {
        "type": "SCAS m8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Find non-AL byte starting at [RDI]."
  },
  {
    "opcode": "F3 AF",
    "name": "REPE",
    "operands": [
      {
        "type": "SCAS m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find non-AX word starting at ES:[(E)DI]."
  },
  {
    "opcode": "F3 AF",
    "name": "REPE",
    "operands": [
      {
        "type": "SCAS m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find non-EAX doubleword starting at ES:[(E)DI]."
  },
  {
    "opcode": "F3 REX.W AF",
    "name": "REPE",
    "operands": [
      {
        "type": "SCAS m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Find non-RAX quadword starting at [RDI]."
  },
  {
    "opcode": "F2 A6",
    "name": "REPNE",
    "operands": [
      {
        "type": "CMPS m8"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find matching bytes in ES:[(E)DI] and DS:[(E)SI]."
  },
  {
    "opcode": "F2 REX.W A6",
    "name": "REPNE",
    "operands": [
      {
        "type": "CMPS m8"
      },
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Find matching bytes in [RDI] and [RSI]."
  },
  {
    "opcode": "F2 A7",
    "name": "REPNE",
    "operands": [
      {
        "type": "CMPS m16"
      },
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find matching words in ES:[(E)DI] and DS:[(E)SI]."
  },
  {
    "opcode": "F2 A7",
    "name": "REPNE",
    "operands": [
      {
        "type": "CMPS m32"
      },
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]."
  },
  {
    "opcode": "F2 REX.W A7",
    "name": "REPNE",
    "operands": [
      {
        "type": "CMPS m64"
      },
      {
        "type": "m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Find matching doublewords in [RDI] and [RSI]."
  },
  {
    "opcode": "F2 AE",
    "name": "REPNE",
    "operands": [
      {
        "type": "SCAS m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find AL, starting at ES:[(E)DI]."
  },
  {
    "opcode": "F2 REX.W AE",
    "name": "REPNE",
    "operands": [
      {
        "type": "SCAS m8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Find AL, starting at [RDI]."
  },
  {
    "opcode": "F2 AF",
    "name": "REPNE",
    "operands": [
      {
        "type": "SCAS m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find AX, starting at ES:[(E)DI]."
  },
  {
    "opcode": "F2 AF",
    "name": "REPNE",
    "operands": [
      {
        "type": "SCAS m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Find EAX, starting at ES:[(E)DI]."
  },
  {
    "opcode": "F2 REX.W AF",
    "name": "REPNE",
    "operands": [
      {
        "type": "SCAS m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Find RAX, starting at [RDI]."
  },
  {
    "opcode": "C3",
    "name": "RET",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Near return to calling procedure."
  },
  {
    "opcode": "CB",
    "name": "RET",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Far return to calling procedure."
  },
  {
    "opcode": "C2 iw",
    "name": "RET",
    "operands": [
      {
        "type": "imm16",
        "encoding": "imm16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Near return to calling procedure and pop imm16 bytes from stack."
  },
  {
    "opcode": "CA iw",
    "name": "RET",
    "operands": [
      {
        "type": "imm16",
        "encoding": "imm16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Far return to calling procedure and pop imm16 bytes from stack."
  },
  {
    "opcode": "VEX.LZ.F2.0F3A.W0 F0 /r ib",
    "name": "RORX",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI2",
    "desc": "Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags."
  },
  {
    "opcode": "VEX.LZ.F2.0F3A.W1 F0 /r ib",
    "name": "RORX",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI2",
    "desc": "Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags."
  },
  {
    "opcode": "66 0F 3A 09 /r ib",
    "name": "ROUNDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 09 /r ib V",
    "name": "ROUNDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."
  },
  {
    "opcode": "VEX.256.66.0F3A.WIG 09 /r ib V",
    "name": "ROUNDPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8."
  },
  {
    "opcode": "66 0F 3A 08 /r ib",
    "name": "ROUNDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."
  },
  {
    "opcode": "VEX.128.66.0F3A.WIG 08 /r ib V",
    "name": "ROUNDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."
  },
  {
    "opcode": "VEX.256.66.0F3A.WIG 08 /r ib V",
    "name": "ROUNDPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8."
  },
  {
    "opcode": "66 0F 3A 0B /r ib",
    "name": "ROUNDSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8."
  },
  {
    "opcode": "VEX.LIG.66.0F3A.WIG 0B /r ib V",
    "name": "ROUNDSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1. The rounding mode is determined by imm8. Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
  },
  {
    "opcode": "66 0F 3A 0A /r ib",
    "name": "ROUNDSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE4_1",
    "desc": "Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8."
  },
  {
    "opcode": "VEX.LIG.66.0F3A.WIG 0A /r ib V",
    "name": "ROUNDSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1. The rounding mode is determined by imm8. Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
  },
  {
    "opcode": "0F AA",
    "name": "RSM",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Resume operation of interrupted program."
  },
  {
    "opcode": "NP 0F 52 /r",
    "name": "RSQRTPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 52 /r V",
    "name": "RSQRTPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 52 /r V",
    "name": "RSQRTPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1."
  },
  {
    "opcode": "F3 0F 52 /r",
    "name": "RSQRTSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 52 /r V",
    "name": "RSQRTSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
  },
  {
    "opcode": "9E",
    "name": "SAHF",
    "operands": [],
    "support64": "invalid*",
    "compatibility": "valid",
    "desc": "Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register."
  },
  {
    "opcode": "D0 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m8 by 2, once."
  },
  {
    "opcode": "REX + D0 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m8 by 2, once."
  },
  {
    "opcode": "D2 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m8 by 2, CL times."
  },
  {
    "opcode": "REX + D2 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m8 by 2, CL times."
  },
  {
    "opcode": "C0 /4 ib",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m8 by 2, imm8 times."
  },
  {
    "opcode": "REX + C0 /4 ib",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m8 by 2, imm8 times."
  },
  {
    "opcode": "D1 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m16 by 2, once."
  },
  {
    "opcode": "D3 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m16 by 2, CL times."
  },
  {
    "opcode": "C1 /4 ib",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m16 by 2, imm8 times."
  },
  {
    "opcode": "D1 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m32 by 2, once."
  },
  {
    "opcode": "REX.W + D1 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m64 by 2, once."
  },
  {
    "opcode": "D3 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m32 by 2, CL times."
  },
  {
    "opcode": "REX.W + D3 /4",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m64 by 2, CL times."
  },
  {
    "opcode": "C1 /4 ib",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m32 by 2, imm8 times."
  },
  {
    "opcode": "REX.W + C1 /4 ib",
    "name": "SAL",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m64 by 2, imm8 times."
  },
  {
    "opcode": "D0 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m8 by 2, once."
  },
  {
    "opcode": "REX + D0 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Signed divide* r/m8 by 2, once."
  },
  {
    "opcode": "D2 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m8 by 2, CL times."
  },
  {
    "opcode": "REX + D2 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Signed divide* r/m8 by 2, CL times."
  },
  {
    "opcode": "C0 /7 ib",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m8 by 2, imm8 time."
  },
  {
    "opcode": "REX + C0 /7 ib",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Signed divide* r/m8 by 2, imm8 times."
  },
  {
    "opcode": "D1 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m16 by 2, once."
  },
  {
    "opcode": "D3 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m16 by 2, CL times."
  },
  {
    "opcode": "C1 /7 ib",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m16 by 2, imm8 times."
  },
  {
    "opcode": "D1 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m32 by 2, once."
  },
  {
    "opcode": "REX.W + D1 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Signed divide* r/m64 by 2, once."
  },
  {
    "opcode": "D3 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m32 by 2, CL times."
  },
  {
    "opcode": "REX.W + D3 /7",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Signed divide* r/m64 by 2, CL times."
  },
  {
    "opcode": "C1 /7 ib",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Signed divide* r/m32 by 2, imm8 times."
  },
  {
    "opcode": "REX.W + C1 /7 ib",
    "name": "SAR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Signed divide* r/m64 by 2, imm8 times"
  },
  {
    "opcode": "D0 /4",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m8 by 2, once."
  },
  {
    "opcode": "REX + D0 /4",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m8 by 2, once."
  },
  {
    "opcode": "D2 /4",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m8 by 2, CL times."
  },
  {
    "opcode": "REX + D2 /4",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m8 by 2, CL times."
  },
  {
    "opcode": "C0 /4 ib",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m8 by 2, imm8 times."
  },
  {
    "opcode": "REX + C0 /4 ib",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m8**",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Multiply r/m8 by 2, imm8 times."
  },
  {
    "opcode": "D1 /4",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m16 by 2, once."
  },
  {
    "opcode": "D3 /4",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m16 by 2, CL times."
  },
  {
    "opcode": "C1 /4 ib",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m16 by 2, imm8 times."
  },
  {
    "opcode": "D1 /4",
    "name": "SHL",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "1",
        "encoding": "1"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Multiply r/m32 by 2, once."
  },
  {
    "opcode": "VEX.LZ.F3.0F38.W0 F7 /r",
    "name": "SARX",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI2",
    "desc": "Shift r/m32 arithmetically right with count specified in r32b."
  },
  {
    "opcode": "VEX.LZ.66.0F38.W0 F7 /r",
    "name": "SHLX",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI2",
    "desc": "Shift r/m32 logically left with count specified in r32b."
  },
  {
    "opcode": "VEX.LZ.F2.0F38.W0 F7 /r",
    "name": "SHRX",
    "operands": [
      {
        "type": "r32a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r32b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI2",
    "desc": "Shift r/m32 logically right with count specified in r32b."
  },
  {
    "opcode": "VEX.LZ.F3.0F38.W1 F7 /r",
    "name": "SARX",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI2",
    "desc": "Shift r/m64 arithmetically right with count specified in r64b."
  },
  {
    "opcode": "VEX.LZ.66.0F38.W1 F7 /r",
    "name": "SHLX",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI2",
    "desc": "Shift r/m64 logically left with count specified in r64b."
  },
  {
    "opcode": "VEX.LZ.F2.0F38.W1 F7 /r",
    "name": "SHRX",
    "operands": [
      {
        "type": "r64a",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r64b",
        "encoding": "VEX.vvvv (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI2",
    "desc": "Shift r/m64 logically right with count specified in r64b."
  },
  {
    "opcode": "1C ib",
    "name": "SBB",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow imm8 from AL."
  },
  {
    "opcode": "1D iw",
    "name": "SBB",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow imm16 from AX."
  },
  {
    "opcode": "1D id",
    "name": "SBB",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow imm32 from EAX."
  },
  {
    "opcode": "REX.W + 1D id",
    "name": "SBB",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract with borrow sign-extended imm.32 to 64-bits from RAX."
  },
  {
    "opcode": "80 /3 ib",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow imm8 from r/m8."
  },
  {
    "opcode": "REX + 80 /3 ib",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract with borrow imm8 from r/m8."
  },
  {
    "opcode": "81 /3 iw",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow imm16 from r/m16."
  },
  {
    "opcode": "81 /3 id",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow imm32 from r/m32."
  },
  {
    "opcode": "REX.W + 81 /3 id",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract with borrow sign-extended imm32 to 64-bits from r/m64."
  },
  {
    "opcode": "83 /3 ib",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow sign-extended imm8 from r/m16."
  },
  {
    "opcode": "83 /3 ib",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow sign-extended imm8 from r/m32."
  },
  {
    "opcode": "REX.W + 83 /3 ib",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract with borrow sign-extended imm8 from r/m64."
  },
  {
    "opcode": "18 /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow r8 from r/m8."
  },
  {
    "opcode": "REX + 18 /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract with borrow r8 from r/m8."
  },
  {
    "opcode": "19 /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow r16 from r/m16."
  },
  {
    "opcode": "19 /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow r32 from r/m32."
  },
  {
    "opcode": "REX.W + 19 /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract with borrow r64 from r/m64."
  },
  {
    "opcode": "1A /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow r/m8 from r8."
  },
  {
    "opcode": "REX + 1A /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract with borrow r/m8 from r8."
  },
  {
    "opcode": "1B /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow r/m16 from r16."
  },
  {
    "opcode": "1B /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract with borrow r/m32 from r32."
  },
  {
    "opcode": "REX.W + 1B /r",
    "name": "SBB",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract with borrow r/m64 from r64."
  },
  {
    "opcode": "AE",
    "name": "SCAS",
    "operands": [
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare AL with byte at ES:(E)DI or RDI, then set status flags.*"
  },
  {
    "opcode": "AF",
    "name": "SCAS",
    "operands": [
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare AX with word at ES:(E)DI or RDI, then set status flags.*"
  },
  {
    "opcode": "AF",
    "name": "SCAS",
    "operands": [
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare EAX with doubleword at ES(E)DI or RDI then set status flags.*"
  },
  {
    "opcode": "REX.W + AF",
    "name": "SCAS",
    "operands": [
      {
        "type": "m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare RAX with quadword at RDI or EDI then set status flags."
  },
  {
    "opcode": "AE",
    "name": "SCASB",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare AL with byte at ES:(E)DI or RDI then set status flags.*"
  },
  {
    "opcode": "AF",
    "name": "SCASW",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare AX with word at ES:(E)DI or RDI then set status flags.*"
  },
  {
    "opcode": "AF",
    "name": "SCASD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.*"
  },
  {
    "opcode": "REX.W + AF",
    "name": "SCASQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Compare RAX with quadword at RDI or EDI then set status flags."
  },
  {
    "opcode": "0F 97 /r",
    "name": "SETA",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if above (CF=0 and ZF=0)."
  },
  {
    "opcode": "REX + 0F 97 /r",
    "name": "SETA",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if above (CF=0 and ZF=0)."
  },
  {
    "opcode": "0F 93 /r",
    "name": "SETAE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if above or equal (CF=0)."
  },
  {
    "opcode": "REX + 0F 93 /r",
    "name": "SETAE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if above or equal (CF=0)."
  },
  {
    "opcode": "0F 92 /r",
    "name": "SETB",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if below (CF=1)."
  },
  {
    "opcode": "REX + 0F 92 /r",
    "name": "SETB",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if below (CF=1)."
  },
  {
    "opcode": "0F 96 /r",
    "name": "SETBE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if below or equal (CF=1 or ZF=1)."
  },
  {
    "opcode": "REX + 0F 96 /r",
    "name": "SETBE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if below or equal (CF=1 or ZF=1)."
  },
  {
    "opcode": "0F 92 /r",
    "name": "SETC",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if carry (CF=1)."
  },
  {
    "opcode": "REX + 0F 92 /r",
    "name": "SETC",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if carry (CF=1)."
  },
  {
    "opcode": "0F 94 /r",
    "name": "SETE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if equal (ZF=1)."
  },
  {
    "opcode": "REX + 0F 94 /r",
    "name": "SETE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if equal (ZF=1)."
  },
  {
    "opcode": "0F 9F /r",
    "name": "SETG",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if greater (ZF=0 and SF=OF)."
  },
  {
    "opcode": "REX + 0F 9F /r",
    "name": "SETG",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if greater (ZF=0 and SF=OF)."
  },
  {
    "opcode": "0F 9D /r",
    "name": "SETGE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if greater or equal (SF=OF)."
  },
  {
    "opcode": "REX + 0F 9D /r",
    "name": "SETGE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if greater or equal (SF=OF)."
  },
  {
    "opcode": "0F 9C /r",
    "name": "SETL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if less (SF= OF)."
  },
  {
    "opcode": "REX + 0F 9C /r",
    "name": "SETL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if less (SF= OF)."
  },
  {
    "opcode": "0F 9E /r",
    "name": "SETLE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if less or equal (ZF=1 or SF= OF)."
  },
  {
    "opcode": "REX + 0F 9E /r",
    "name": "SETLE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if less or equal (ZF=1 or SF= OF)."
  },
  {
    "opcode": "0F 96 /r",
    "name": "SETNA",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not above (CF=1 or ZF=1)."
  },
  {
    "opcode": "REX + 0F 96 /r",
    "name": "SETNA",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not above (CF=1 or ZF=1)."
  },
  {
    "opcode": "0F 92 /r",
    "name": "SETNAE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not above or equal (CF=1)."
  },
  {
    "opcode": "REX + 0F 92 /r",
    "name": "SETNAE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not above or equal (CF=1)."
  },
  {
    "opcode": "0F 93 /r",
    "name": "SETNB",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not below (CF=0)."
  },
  {
    "opcode": "REX + 0F 93 /r",
    "name": "SETNB",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not below (CF=0)."
  },
  {
    "opcode": "0F 97 /r",
    "name": "SETNBE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not below or equal (CF=0 and ZF=0)."
  },
  {
    "opcode": "REX + 0F 97 /r",
    "name": "SETNBE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not below or equal (CF=0 and ZF=0)."
  },
  {
    "opcode": "0F 93 /r",
    "name": "SETNC",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not carry (CF=0)."
  },
  {
    "opcode": "REX + 0F 93 /r",
    "name": "SETNC",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not carry (CF=0)."
  },
  {
    "opcode": "0F 95 /r",
    "name": "SETNE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not equal (ZF=0)."
  },
  {
    "opcode": "REX + 0F 95 /r",
    "name": "SETNE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not equal (ZF=0)."
  },
  {
    "opcode": "0F 9E /r",
    "name": "SETNG",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not greater (ZF=1 or SF= OF)"
  },
  {
    "opcode": "REX + 0F 9E /r",
    "name": "SETNG",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not greater (ZF=1 or SF= OF)."
  },
  {
    "opcode": "0F 9C /r",
    "name": "SETNGE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not greater or equal (SF= OF)."
  },
  {
    "opcode": "REX + 0F 9C /r",
    "name": "SETNGE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not greater or equal (SF= OF)."
  },
  {
    "opcode": "0F 9D /r",
    "name": "SETNL",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not less (SF=OF)."
  },
  {
    "opcode": "REX + 0F 9D /r",
    "name": "SETNL",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not less (SF=OF)."
  },
  {
    "opcode": "0F 9F /r",
    "name": "SETNLE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not less or equal (ZF=0 and SF=OF)."
  },
  {
    "opcode": "REX + 0F 9F /r",
    "name": "SETNLE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not less or equal (ZF=0 and SF=OF)."
  },
  {
    "opcode": "0F 91 /r",
    "name": "SETNO",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not overflow (OF=0)."
  },
  {
    "opcode": "REX + 0F 91 /r",
    "name": "SETNO",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not overflow (OF=0)."
  },
  {
    "opcode": "0F 9B /r",
    "name": "SETNP",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not parity (PF=0)."
  },
  {
    "opcode": "REX + 0F 9B /r",
    "name": "SETNP",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not parity (PF=0)."
  },
  {
    "opcode": "0F 99 /r",
    "name": "SETNS",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not sign (SF=0)."
  },
  {
    "opcode": "REX + 0F 99 /r",
    "name": "SETNS",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not sign (SF=0)."
  },
  {
    "opcode": "0F 95 /r",
    "name": "SETNZ",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if not zero (ZF=0)."
  },
  {
    "opcode": "REX + 0F 95 /r",
    "name": "SETNZ",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if not zero (ZF=0)."
  },
  {
    "opcode": "0F 90 /r",
    "name": "SETO",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if overflow (OF=1)"
  },
  {
    "opcode": "REX + 0F 90 /r",
    "name": "SETO",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if overflow (OF=1)."
  },
  {
    "opcode": "0F 9A /r",
    "name": "SETP",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if parity (PF=1)."
  },
  {
    "opcode": "REX + 0F 9A /r",
    "name": "SETP",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if parity (PF=1)."
  },
  {
    "opcode": "0F 9A /r",
    "name": "SETPE",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if parity even (PF=1)."
  },
  {
    "opcode": "REX + 0F 9A /r",
    "name": "SETPE",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if parity even (PF=1)."
  },
  {
    "opcode": "0F 9B /r",
    "name": "SETPO",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if parity odd (PF=0)."
  },
  {
    "opcode": "REX + 0F 9B /r",
    "name": "SETPO",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if parity odd (PF=0)."
  },
  {
    "opcode": "0F 98 /r",
    "name": "SETS",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if sign (SF=1)."
  },
  {
    "opcode": "REX + 0F 98 /r",
    "name": "SETS",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if sign (SF=1)."
  },
  {
    "opcode": "0F 94 /r",
    "name": "SETZ",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set byte if zero (ZF=1)."
  },
  {
    "opcode": "REX + 0F 94 /r",
    "name": "SETZ",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set byte if zero (ZF=1)."
  },
  {
    "opcode": "NP 0F AE F8",
    "name": "SFENCE",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Serializes store operations."
  },
  {
    "opcode": "NP 0F 38 C9 /r",
    "name": "SHA1MSG1",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SHA",
    "desc": "Performs an intermediate calculation for the next four SHA1 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
  },
  {
    "opcode": "NP 0F 38 CA /r",
    "name": "SHA1MSG2",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SHA",
    "desc": "Performs the final calculation for the next four SHA1 message dwords using intermediate results from xmm1 and the previous message dwords from xmm2/m128, storing the result in xmm1."
  },
  {
    "opcode": "NP 0F 38 C8 /r",
    "name": "SHA1NEXTE",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SHA",
    "desc": "Calculates SHA1 state variable E after four rounds of operation from the current SHA1 state variable A in xmm1. The calculated value of the SHA1 state variable E is added to the scheduled dwords in xmm2/m128, and stored with some of the scheduled dwords in xmm1."
  },
  {
    "opcode": "NP 0F 3A CC /r ib",
    "name": "SHA1RNDS4",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SHA",
    "desc": "Performs four rounds of SHA1 operation operating on SHA1 state (A,B,C,D) from xmm1, with a pre-computed sum of the next 4 round message dwords and state variable E from xmm2/m128. The immediate byte controls logic functions and round constants."
  },
  {
    "opcode": "NP 0F 38 CC /r",
    "name": "SHA256MSG1",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SHA",
    "desc": "Performs an intermediate calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
  },
  {
    "opcode": "NP 0F 38 CD /r",
    "name": "SHA256MSG2",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SHA",
    "desc": "Performs the final calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
  },
  {
    "opcode": "NP 0F 38 CB /r",
    "name": "SHA256RNDS2",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "<XMM0>",
        "encoding": "Implicit XMM0 (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SHA",
    "desc": "Perform 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from xmm1, an initial SHA256 state (A,B,E,F) from xmm2/m128, and a pre-computed sum of the next 2 round message dwords and the corresponding round constants from the implicit operand XMM0, storing the updated SHA256 state (A,B,E,F) result in xmm1."
  },
  {
    "opcode": "0F A4 /r ib",
    "name": "SHLD",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shift r/m16 to left imm8 places while shifting bits from r16 in from the right."
  },
  {
    "opcode": "0F A5 /r",
    "name": "SHLD",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shift r/m16 to left CL places while shifting bits from r16 in from the right."
  },
  {
    "opcode": "0F A4 /r ib",
    "name": "SHLD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shift r/m32 to left imm8 places while shifting bits from r32 in from the right."
  },
  {
    "opcode": "REX.W + 0F A4 /r ib",
    "name": "SHLD",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Shift r/m64 to left imm8 places while shifting bits from r64 in from the right."
  },
  {
    "opcode": "0F A5 /r",
    "name": "SHLD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shift r/m32 to left CL places while shifting bits from r32 in from the right."
  },
  {
    "opcode": "REX.W + 0F A5 /r",
    "name": "SHLD",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Shift r/m64 to left CL places while shifting bits from r64 in from the right."
  },
  {
    "opcode": "0F AC /r ib",
    "name": "SHRD",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shift r/m16 to right imm8 places while shifting bits from r16 in from the left."
  },
  {
    "opcode": "0F AD /r",
    "name": "SHRD",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shift r/m16 to right CL places while shifting bits from r16 in from the left."
  },
  {
    "opcode": "0F AC /r ib",
    "name": "SHRD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shift r/m32 to right imm8 places while shifting bits from r32 in from the left."
  },
  {
    "opcode": "REX.W + 0F AC /r ib",
    "name": "SHRD",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Shift r/m64 to right imm8 places while shifting bits from r64 in from the left."
  },
  {
    "opcode": "0F AD /r",
    "name": "SHRD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Shift r/m32 to right CL places while shifting bits from r32 in from the left."
  },
  {
    "opcode": "REX.W + 0F AD /r",
    "name": "SHRD",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "CL",
        "encoding": "CL"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Shift r/m64 to right CL places while shifting bits from r64 in from the left."
  },
  {
    "opcode": "66 0F C6 /r ib",
    "name": "SHUFPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Shuffle two pairs of double-precision floating-point values from xmm1 and xmm2/m128 using imm8 to select from each pair, interleaved result is stored in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG C6 /r ib V",
    "name": "SHUFPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shuffle two pairs of double-precision floating-point values from xmm2 and xmm3/m128 using imm8 to select from each pair, interleaved result is stored in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG C6 /r ib V",
    "name": "SHUFPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Shuffle four pairs of double-precision floating-point values from ymm2 and ymm3/m256 using imm8 to select from each pair, interleaved result is stored in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 C6 /r ib V",
    "name": "SHUFPD",
    "operands": [
      {
        "type": "xmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shuffle two paris of double-precision floating-point values from xmm2 and xmm3/m128/m64bcst using imm8 to select from each pair. store interleaved results in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 C6 /r ib V",
    "name": "SHUFPD",
    "operands": [
      {
        "type": "ymm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shuffle four paris of double-precision floating-point values from ymm2 and ymm3/m256/m64bcst using imm8 to select from each pair. store interleaved results in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 C6 /r ib V",
    "name": "SHUFPD",
    "operands": [
      {
        "type": "zmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shuffle eight paris of double-precision floating-point values from zmm2 and zmm3/m512/m64bcst using imm8 to select from each pair. store interleaved results in zmm1 subject to writemask k1."
  },
  {
    "opcode": "NP 0F C6 /r ib",
    "name": "SHUFPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG C6 /r ib V",
    "name": "SHUFPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG C6 /r ib V",
    "name": "SHUFPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Select from quadruplet of single-precision floating-point values in ymm2 and ymm3/m256 using imm8, interleaved result pairs are stored in ymm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 C6 /r ib V",
    "name": "SHUFPS",
    "operands": [
      {
        "type": "xmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1, subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 C6 /r ib V",
    "name": "SHUFPS",
    "operands": [
      {
        "type": "ymm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Select from quadruplet of single-precision floating-point values in ymm2 and ymm3/m256 using imm8, interleaved result pairs are stored in ymm1, subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 C6 /r ib V",
    "name": "SHUFPS",
    "operands": [
      {
        "type": "zmm1{k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Select from quadruplet of single-precision floating-point values in zmm2 and zmm3/m512 using imm8, interleaved result pairs are stored in zmm1, subject to writemask k1."
  },
  {
    "opcode": "0F 01 /1",
    "name": "SIDT",
    "operands": [
      {
        "type": "m",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store IDTR to m."
  },
  {
    "opcode": "0F 00 /0",
    "name": "SLDT",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Stores segment selector from LDTR in r/m16."
  },
  {
    "opcode": "REX.W + 0F 00 /0",
    "name": "SLDT",
    "operands": [
      {
        "type": "r64/m16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Stores segment selector from LDTR in r64/m16."
  },
  {
    "opcode": "0F 01 /4",
    "name": "SMSW",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store machine status word to r/m16."
  },
  {
    "opcode": "0F 01 /4",
    "name": "SMSW",
    "operands": [
      {
        "type": "r32/m16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined."
  },
  {
    "opcode": "REX.W + 0F 01 /4",
    "name": "SMSW",
    "operands": [
      {
        "type": "r64/m16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined."
  },
  {
    "opcode": "66 0F 51 /r",
    "name": "SQRTPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 51 /r V",
    "name": "SQRTPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 51 /r V",
    "name": "SQRTPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes Square Roots of the packed double-precision floating-point values in ymm2/m256 and stores the result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 51 /r V",
    "name": "SQRTPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 51 /r V",
    "name": "SQRTPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes Square Roots of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 51 /r V",
    "name": "SQRTPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes Square Roots of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "NP 0F 51 /r",
    "name": "SQRTPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 51 /r V",
    "name": "SQRTPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 51/r V",
    "name": "SQRTPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes Square Roots of the packed single-precision floating-point values in ymm2/m256 and stores the result in ymm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 51 /r V",
    "name": "SQRTPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 51 /r V",
    "name": "SQRTPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes Square Roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 51/r V",
    "name": "SQRTPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes Square Roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "F2 0F 51/r",
    "name": "SQRTSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Computes square root of the low double-precision floating-point value in xmm2/m64 and stores the results in xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 51/r V",
    "name": "SQRTSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes square root of the low double-precision floating-point value in xmm3/m64 and stores the results in xmm1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 51/r V",
    "name": "SQRTSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes square root of the low double-precision floating-point value in xmm3/m64 and stores the results in xmm1 under writemask k1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
  },
  {
    "opcode": "F3 0F 51 /r",
    "name": "SQRTSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Computes square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 51 /r V",
    "name": "SQRTSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 51 /r V",
    "name": "SQRTSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1 under writemask k1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
  },
  {
    "opcode": "NP 0F 01 CB",
    "name": "STAC",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "SMAP",
    "desc": "Set the AC flag in the EFLAGS register."
  },
  {
    "opcode": "F9",
    "name": "STC",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set CF flag."
  },
  {
    "opcode": "FD",
    "name": "STD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set DF flag."
  },
  {
    "opcode": "FB",
    "name": "STI",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction."
  },
  {
    "opcode": "NP 0F AE /3",
    "name": "STMXCSR",
    "operands": [
      {
        "type": "m32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Store contents of MXCSR register to m32."
  },
  {
    "opcode": "VEX.LZ.0F.WIG AE /3 V",
    "name": "STMXCSR",
    "operands": [
      {
        "type": "m32",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Store contents of MXCSR register to m32."
  },
  {
    "opcode": "AA",
    "name": "STOS",
    "operands": [
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
  },
  {
    "opcode": "AB",
    "name": "STOS",
    "operands": [
      {
        "type": "m16"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
  },
  {
    "opcode": "AB",
    "name": "STOS",
    "operands": [
      {
        "type": "m32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
  },
  {
    "opcode": "REX.W + AB",
    "name": "STOS",
    "operands": [
      {
        "type": "m64"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store RAX at address RDI or EDI."
  },
  {
    "opcode": "AA",
    "name": "STOSB",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
  },
  {
    "opcode": "AB",
    "name": "STOSW",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
  },
  {
    "opcode": "AB",
    "name": "STOSD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
  },
  {
    "opcode": "REX.W + AB",
    "name": "STOSQ",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Store RAX at address RDI or EDI."
  },
  {
    "opcode": "0F 00 /1",
    "name": "STR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Stores segment selector from TR in r/m16."
  },
  {
    "opcode": "2C ib",
    "name": "SUB",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract imm8 from AL."
  },
  {
    "opcode": "2D iw",
    "name": "SUB",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract imm16 from AX."
  },
  {
    "opcode": "2D id",
    "name": "SUB",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract imm32 from EAX."
  },
  {
    "opcode": "REX.W + 2D id",
    "name": "SUB",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract imm32 sign-extended to 64-bits from RAX."
  },
  {
    "opcode": "80 /5 ib",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract imm8 from r/m8."
  },
  {
    "opcode": "REX + 80 /5 ib",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract imm8 from r/m8."
  },
  {
    "opcode": "81 /5 iw",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract imm16 from r/m16."
  },
  {
    "opcode": "81 /5 id",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract imm32 from r/m32."
  },
  {
    "opcode": "REX.W + 81 /5 id",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract imm32 sign-extended to 64-bits from r/m64."
  },
  {
    "opcode": "83 /5 ib",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract sign-extended imm8 from r/m16."
  },
  {
    "opcode": "83 /5 ib",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract sign-extended imm8 from r/m32."
  },
  {
    "opcode": "REX.W + 83 /5 ib",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract sign-extended imm8 from r/m64."
  },
  {
    "opcode": "28 /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract r8 from r/m8."
  },
  {
    "opcode": "REX + 28 /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract r8 from r/m8."
  },
  {
    "opcode": "29 /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract r16 from r/m16."
  },
  {
    "opcode": "29 /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract r32 from r/m32."
  },
  {
    "opcode": "REX.W + 29 /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract r64 from r/m64."
  },
  {
    "opcode": "2A /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract r/m8 from r8."
  },
  {
    "opcode": "REX + 2A /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract r/m8 from r8."
  },
  {
    "opcode": "2B /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract r/m16 from r16."
  },
  {
    "opcode": "2B /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Subtract r/m32 from r32."
  },
  {
    "opcode": "REX.W + 2B /r",
    "name": "SUB",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Subtract r/m64 from r64."
  },
  {
    "opcode": "66 0F 5C /r",
    "name": "SUBPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract packed double-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 5C /r V",
    "name": "SUBPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed double-precision floating-point values in xmm3/mem from xmm2 and store result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 5C /r V",
    "name": "SUBPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed double-precision floating-point values in ymm3/mem from ymm2 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 5C /r V",
    "name": "SUBPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Subtract packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 5C /r V",
    "name": "SUBPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Subtract packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 5C /r V",
    "name": "SUBPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Subtract packed double-precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1."
  },
  {
    "opcode": "NP 0F 5C /r",
    "name": "SUBPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Subtract packed single-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
  },
  {
    "opcode": "VEX.128.0F.WIG 5C /r V",
    "name": "SUBPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1."
  },
  {
    "opcode": "VEX.256.0F.WIG 5C /r V",
    "name": "SUBPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1."
  },
  {
    "opcode": "EVEX.128.0F.W0 5C /r V",
    "name": "SUBPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Subtract packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and stores result in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 5C /r V",
    "name": "SUBPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Subtract packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and stores result in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 5C /r V",
    "name": "SUBPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Subtract packed single-precision floating-point values in zmm3/m512/m32bcst from zmm2 and stores result in zmm1 with writemask k1."
  },
  {
    "opcode": "F2 0F 5C /r",
    "name": "SUBSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Subtract the low double-precision floating-point value in xmm2/m64 from xmm1 and store the result in xmm1."
  },
  {
    "opcode": "VEX.LIG.F2.0F.WIG 5C /r V",
    "name": "SUBSD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract the low double-precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 5C /r V",
    "name": "SUBSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Subtract the low double-precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1 under writemask k1."
  },
  {
    "opcode": "F3 0F 5C /r",
    "name": "SUBSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Subtract the low single-precision floating-point value in xmm2/m32 from xmm1 and store the result in xmm1."
  },
  {
    "opcode": "VEX.LIG.F3.0F.WIG 5C /r V",
    "name": "SUBSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Subtract the low single-precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 5C /r V",
    "name": "SUBSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Subtract the low single-precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1 under writemask k1."
  },
  {
    "opcode": "0F 01 F8",
    "name": "SWAPGS",
    "operands": [],
    "support64": "valid",
    "compatibility": "invalid",
    "desc": "Exchanges the current GS base register value with the value contained in MSR address C0000102H."
  },
  {
    "opcode": "0F 05",
    "name": "SYSCALL",
    "operands": [],
    "support64": "valid",
    "compatibility": "invalid",
    "desc": "Fast call to privilege level 0 system procedures."
  },
  {
    "opcode": "0F 34",
    "name": "SYSENTER",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Fast call to privilege level 0 system procedures."
  },
  {
    "opcode": "0F 35",
    "name": "SYSEXIT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Fast return to privilege level 3 user code."
  },
  {
    "opcode": "REX.W + 0F 35",
    "name": "SYSEXIT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Fast return to 64-bit mode privilege level 3 user code."
  },
  {
    "opcode": "0F 07",
    "name": "SYSRET",
    "operands": [],
    "support64": "valid",
    "compatibility": "invalid",
    "desc": "Return to compatibility mode from fast system call"
  },
  {
    "opcode": "REX.W + 0F 07",
    "name": "SYSRET",
    "operands": [],
    "support64": "valid",
    "compatibility": "invalid",
    "desc": "Return to 64-bit mode from fast system call"
  },
  {
    "opcode": "A8 ib",
    "name": "TEST",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND imm8 with AL; set SF, ZF, PF according to result."
  },
  {
    "opcode": "A9 iw",
    "name": "TEST",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND imm16 with AX; set SF, ZF, PF according to result."
  },
  {
    "opcode": "A9 id",
    "name": "TEST",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND imm32 with EAX; set SF, ZF, PF according to result."
  },
  {
    "opcode": "REX.W + A9 id",
    "name": "TEST",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result."
  },
  {
    "opcode": "F6 /0 ib",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND imm8 with r/m8; set SF, ZF, PF according to result."
  },
  {
    "opcode": "REX + F6 /0 ib",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "AND imm8 with r/m8; set SF, ZF, PF according to result."
  },
  {
    "opcode": "F7 /0 iw",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND imm16 with r/m16; set SF, ZF, PF according to result."
  },
  {
    "opcode": "F7 /0 id",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND imm32 with r/m32; set SF, ZF, PF according to result."
  },
  {
    "opcode": "REX.W + F7 /0 id",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result."
  },
  {
    "opcode": "84 /r",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND r8 with r/m8; set SF, ZF, PF according to result."
  },
  {
    "opcode": "REX + 84 /r",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "AND r8 with r/m8; set SF, ZF, PF according to result."
  },
  {
    "opcode": "85 /r",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND r16 with r/m16; set SF, ZF, PF according to result."
  },
  {
    "opcode": "85 /r",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AND r32 with r/m32; set SF, ZF, PF according to result."
  },
  {
    "opcode": "REX.W + 85 /r",
    "name": "TEST",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "AND r64 with r/m64; set SF, ZF, PF according to result."
  },
  {
    "opcode": "66 0F AE /6",
    "name": "TPAUSE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "<edx>"
      },
      {
        "type": "<eax>"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "WAITPKG",
    "desc": "Directs the processor to enter an implementation-dependent optimized state until the TSC reaches the value in EDX:EAX."
  },
  {
    "opcode": "F3 0F BC /r",
    "name": "TZCNT",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI1",
    "desc": "Count the number of trailing zero bits in r/m16, return result in r16."
  },
  {
    "opcode": "F3 0F BC /r",
    "name": "TZCNT",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "BMI1",
    "desc": "Count the number of trailing zero bits in r/m32, return result in r32."
  },
  {
    "opcode": "F3 REX.W 0F BC /r",
    "name": "TZCNT",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "BMI1",
    "desc": "Count the number of trailing zero bits in r/m64, return result in r64."
  },
  {
    "opcode": "66 0F 2E /r",
    "name": "UCOMISD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "VEX.LIG.66.0F.WIG 2E /r V",
    "name": "UCOMISD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "EVEX.LIG.66.0F.W1 2E /r V",
    "name": "UCOMISD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare low double-precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "NP 0F 2E /r",
    "name": "UCOMISS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "VEX.LIG.0F.WIG 2E /r V",
    "name": "UCOMISS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "EVEX.LIG.0F.W0 2E /r V",
    "name": "UCOMISS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
  },
  {
    "opcode": "0F FF /r",
    "name": "UD01",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Raise invalid opcode exception."
  },
  {
    "opcode": "0F B9 /r",
    "name": "UD1",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Raise invalid opcode exception."
  },
  {
    "opcode": "0F 0B",
    "name": "UD2",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Raise invalid opcode exception."
  },
  {
    "opcode": "F3 0F AE /6",
    "name": "UMONITOR",
    "operands": [
      {
        "type": "r16/r32/r64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "WAITPKG",
    "desc": "Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is contained in r16/r32/r64."
  },
  {
    "opcode": "F2 0F AE /6",
    "name": "UMWAIT",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "<edx>"
      },
      {
        "type": "<eax>"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "WAITPKG",
    "desc": "A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."
  },
  {
    "opcode": "66 0F 15 /r",
    "name": "UNPCKHPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 15 /r V",
    "name": "UNPCKHPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm2 and xmm3/m128."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 15 /r V",
    "name": "UNPCKHPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Unpacks and Interleaves double-precision floating-point values from high quadwords of ymm2 and ymm3/m256."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 15 /r V",
    "name": "UNPCKHPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 15 /r V",
    "name": "UNPCKHPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 15 /r V",
    "name": "UNPCKHPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Unpacks and Interleaves double-precision floating-point values from high quadwords of zmm2 and zmm3/m512/m64bcst subject to writemask k1."
  },
  {
    "opcode": "NP 0F 15 /r",
    "name": "UNPCKHPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
  },
  {
    "opcode": "VEX.128.0F.WIG 15 /r V",
    "name": "UNPCKHPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128."
  },
  {
    "opcode": "VEX.256.0F.WIG 15 /r V",
    "name": "UNPCKHPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256."
  },
  {
    "opcode": "EVEX.128.0F.W0 15 /r V",
    "name": "UNPCKHPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128/m32bcst and write result to xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 15 /r V",
    "name": "UNPCKHPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256/m32bcst and write result to ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 15 /r V",
    "name": "UNPCKHPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Unpacks and Interleaves single-precision floating-point values from high quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to writemask k1."
  },
  {
    "opcode": "66 0F 14 /r",
    "name": "UNPCKLPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 14 /r V",
    "name": "UNPCKLPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm2 and xmm3/m128."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 14 /r V",
    "name": "UNPCKLPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Unpacks and Interleaves double-precision floating-point values from low quadwords of ymm2 and ymm3/m256."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 14 /r V",
    "name": "UNPCKLPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Unpacks and Interleaves double precision floating-point values from low quadwords of xmm2 and xmm3/m128/m64bcst subject to write mask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 14 /r V",
    "name": "UNPCKLPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Unpacks and Interleaves double precision floating-point values from low quadwords of ymm2 and ymm3/m256/m64bcst subject to write mask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 14 /r V",
    "name": "UNPCKLPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Unpacks and Interleaves double-precision floating-point values from low quadwords of zmm2 and zmm3/m512/m64bcst subject to write mask k1."
  },
  {
    "opcode": "NP 0F 14 /r",
    "name": "UNPCKLPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
  },
  {
    "opcode": "VEX.128.0F.WIG 14 /r V",
    "name": "UNPCKLPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128."
  },
  {
    "opcode": "VEX.256.0F.WIG 14 /r V",
    "name": "UNPCKLPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256."
  },
  {
    "opcode": "EVEX.128.0F.W0 14 /r V",
    "name": "UNPCKLPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/mem and write result to xmm1 subject to write mask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 14 /r V",
    "name": "UNPCKLPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/mem and write result to ymm1 subject to write mask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 14 /r V",
    "name": "UNPCKLPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Unpacks and Interleaves single-precision floating-point values from low quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to write mask k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 03 /r ib",
    "name": "VALIGND",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift right and merge vectors xmm2 and xmm3/m128/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in xmm1, under writemask."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 03 /r ib",
    "name": "VALIGNQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift right and merge vectors xmm2 and xmm3/m128/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in xmm1, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 03 /r ib",
    "name": "VALIGND",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift right and merge vectors ymm2 and ymm3/m256/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in ymm1, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 03 /r ib",
    "name": "VALIGNQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift right and merge vectors ymm2 and ymm3/m256/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in ymm1, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 03 /r ib",
    "name": "VALIGND",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift right and merge vectors zmm2 and zmm3/m512/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in zmm1, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 03 /r ib",
    "name": "VALIGNQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift right and merge vectors zmm2 and zmm3/m512/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in zmm1, under writemask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 65 /r",
    "name": "VBLENDMPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Blend double-precision vector xmm2 and double-precision vector xmm3/m128/m64bcst and store the result in xmm1, under control mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 65 /r",
    "name": "VBLENDMPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Blend double-precision vector ymm2 and double-precision vector ymm3/m256/m64bcst and store the result in ymm1, under control mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 65 /r",
    "name": "VBLENDMPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Blend double-precision vector zmm2 and double-precision vector zmm3/m512/m64bcst and store the result in zmm1, under control mask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 65 /r",
    "name": "VBLENDMPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Blend single-precision vector xmm2 and single-precision vector xmm3/m128/m32bcst and store the result in xmm1, under control mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 65 /r",
    "name": "VBLENDMPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Blend single-precision vector ymm2 and single-precision vector ymm3/m256/m32bcst and store the result in ymm1, under control mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 65 /r",
    "name": "VBLENDMPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Blend single-precision vector zmm2 and single-precision vector zmm3/m512/m32bcst using k1 as select control and store the result in zmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 18 /r",
    "name": "VBROADCASTSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Broadcast single-precision floating-point element in mem to four locations in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 18 /r",
    "name": "VBROADCASTSS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Broadcast single-precision floating-point element in mem to eight locations in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 19 /r",
    "name": "VBROADCASTSD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Broadcast double-precision floating-point element in mem to four locations in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 1A /r",
    "name": "VBROADCASTF128",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 18/r",
    "name": "VBROADCASTSS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Broadcast the low single-precision floating-point element in the source operand to four locations in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 18 /r",
    "name": "VBROADCASTSS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Broadcast low single-precision floating-point element in the source operand to eight locations in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 19 /r",
    "name": "VBROADCASTSD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Broadcast low double-precision floating-point element in the source operand to four locations in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 19 /r",
    "name": "VBROADCASTSD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Broadcast low double-precision floating-point element in xmm2/m64 to four locations in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 19 /r",
    "name": "VBROADCASTSD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Broadcast low double-precision floating-point element in xmm2/m64 to eight locations in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 19 /r",
    "name": "VBROADCASTF32X2",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Broadcast two single-precision floating-point elements in xmm2/m64 to locations in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 19 /r",
    "name": "VBROADCASTF32X2",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Broadcast two single-precision floating-point elements in xmm2/m64 to locations in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 18 /r",
    "name": "VBROADCASTSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 18 /r",
    "name": "VBROADCASTSS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 18 /r",
    "name": "VBROADCASTSS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 1A /r",
    "name": "VBROADCASTF32X4",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Broadcast 128 bits of 4 single-precision floating-point data in mem to locations in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 1A /r",
    "name": "VBROADCASTF32X4",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Broadcast 128 bits of 4 single-precision floating-point data in mem to locations in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 1A /r",
    "name": "VBROADCASTF64X2",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Broadcast 128 bits of 2 double-precision floating-point data in mem to locations in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 1A /r",
    "name": "VBROADCASTF64X2",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Broadcast 128 bits of 2 double-precision floating-point data in mem to locations in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 1B /r",
    "name": "VBROADCASTF32X8",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Broadcast 256 bits of 8 single-precision floating-point data in mem to locations in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 1B /r",
    "name": "VBROADCASTF64X4",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Broadcast 256 bits of 4 double-precision floating-point data in mem to locations in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 8A /r",
    "name": "VCOMPRESSPD",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compress packed double-precision floating-point values from xmm2 to xmm1/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 8A /r",
    "name": "VCOMPRESSPD",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compress packed double-precision floating-point values from ymm2 to ymm1/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 8A /r",
    "name": "VCOMPRESSPD",
    "operands": [
      {
        "type": "zmm1/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compress packed double-precision floating-point values from zmm2 using control mask k1 to zmm1/m512."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 8A /r",
    "name": "VCOMPRESSPS",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compress packed single-precision floating-point values from xmm2 to xmm1/m128 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 8A /r",
    "name": "VCOMPRESSPS",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compress packed single-precision floating-point values from ymm2 to ymm1/m256 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 8A /r",
    "name": "VCOMPRESSPS",
    "operands": [
      {
        "type": "zmm1/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compress packed single-precision floating-point values from zmm2 using control mask k1 to zmm1/m512."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 7B /r",
    "name": "VCVTPD2QQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed double-precision floating-point values from xmm2/m128/m64bcst to two packed quadword integers in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 7B /r",
    "name": "VCVTPD2QQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 7B /r",
    "name": "VCVTPD2QQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed double-precision floating-point values from zmm2/m512/m64bcst to eight packed quadword integers in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.128.0F.W1 79 /r",
    "name": "VCVTPD2UDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two unsigned doubleword integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W1 79 /r",
    "name": "VCVTPD2UDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four unsigned doubleword integers in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W1 79 /r",
    "name": "VCVTPD2UDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight unsigned doubleword integers in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 79 /r",
    "name": "VCVTPD2UQQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed double-precision floating-point values from xmm2/mem to two packed unsigned quadword integers in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 79 /r",
    "name": "VCVTPD2UQQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert fourth packed double-precision floating-point values from ymm2/mem to four packed unsigned quadword integers in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 79 /r",
    "name": "VCVTPD2UQQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed double-precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 with writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 13 /r",
    "name": "VCVTPH2PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "F16C",
    "desc": "Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 13 /r",
    "name": "VCVTPH2PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "F16C",
    "desc": "Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 13 /r",
    "name": "VCVTPH2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point values in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 13 /r",
    "name": "VCVTPH2PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point values in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 13 /r",
    "name": "VCVTPH2PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256 {sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert sixteen packed half precision (16-bit) floating-point values in ymm2/m256 to packed single-precision floating-point values in zmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 1D /r ib",
    "name": "VCVTPS2PH",
    "operands": [
      {
        "type": "xmm1/m64",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "F16C",
    "desc": "Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. Imm8 provides rounding controls."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 1D /r ib",
    "name": "VCVTPS2PH",
    "operands": [
      {
        "type": "xmm1/m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "F16C",
    "desc": "Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. Imm8 provides rounding controls."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 1D /r ib",
    "name": "VCVTPS2PH",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. Imm8 provides rounding controls."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 1D /r ib",
    "name": "VCVTPS2PH",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. Imm8 provides rounding controls."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 1D /r ib",
    "name": "VCVTPS2PH",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2{sae}",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert sixteen packed single-precision floating-point values in zmm2 to packed half-precision (16-bit) floating-point values in ymm1/m256. Imm8 provides rounding controls."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 7B /r",
    "name": "VCVTPS2QQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 7B /r",
    "name": "VCVTPS2QQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 7B /r",
    "name": "VCVTPS2QQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.0F.W0 79 /r",
    "name": "VCVTPS2UDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 79 /r",
    "name": "VCVTPS2UDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 79 /r",
    "name": "VCVTPS2UDQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 79 /r",
    "name": "VCVTPS2UQQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed single precision floating-point values from zmm2/m64/m32bcst to two packed unsigned quadword values in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 79 /r",
    "name": "VCVTPS2UQQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 79 /r",
    "name": "VCVTPS2UQQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W1 E6 /r",
    "name": "VCVTQQ2PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed quadword integers from xmm2/m128/m64bcst to packed double-precision floating-point values in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W1 E6 /r",
    "name": "VCVTQQ2PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed quadword integers from ymm2/m256/m64bcst to packed double-precision floating-point values in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W1 E6 /r",
    "name": "VCVTQQ2PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed quadword integers from zmm2/m512/m64bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.128.0F.W1 5B /r",
    "name": "VCVTQQ2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed quadword integers from xmm2/mem to packed single-precision floating-point values in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W1 5B /r",
    "name": "VCVTQQ2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed quadword integers from ymm2/mem to packed single-precision floating-point values in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W1 5B /r",
    "name": "VCVTQQ2PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed quadword integers from zmm2/mem to eight packed single-precision floating-point values in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W0 79 /r",
    "name": "VCVTSD2USI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one unsigned doubleword integer r32."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 79 /r",
    "name": "VCVTSD2USI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one unsigned quadword integer zero-extended into r64."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 79 /r",
    "name": "VCVTSS2USI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W1 79 /r",
    "name": "VCVTSS2USI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 7A /r",
    "name": "VCVTTPD2QQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed double-precision floating-point values from zmm2/m128/m64bcst to two packed quadword integers in zmm1 using truncation with writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 7A /r",
    "name": "VCVTTPD2QQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 using truncation with writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 7A /r",
    "name": "VCVTTPD2QQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed double-precision floating-point values from zmm2/m512 to eight packed quadword integers in zmm1 using truncation with writemask k1."
  },
  {
    "opcode": "EVEX.128.0F.W1 78 /r",
    "name": "VCVTTPD2UDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two unsigned doubleword integers in xmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W1 78 02 /r",
    "name": "VCVTTPD2UDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four unsigned doubleword integers in xmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W1 78 /r",
    "name": "VCVTTPD2UDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight unsigned doubleword integers in ymm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 78 /r",
    "name": "VCVTTPD2UQQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed double-precision floating-point values from xmm2/m128/m64bcst to two packed unsigned quadword integers in xmm1 using truncation with writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 78 /r",
    "name": "VCVTTPD2UQQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed unsigned quadword integers in ymm1 using truncation with writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 78 /r",
    "name": "VCVTTPD2UQQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed double-precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 using truncation with writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 7A /r",
    "name": "VCVTTPS2QQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 7A /r",
    "name": "VCVTTPS2QQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 7A /r",
    "name": "VCVTTPS2QQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.0F.W0 78 /r",
    "name": "VCVTTPS2UDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 78 /r",
    "name": "VCVTTPS2UDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 78 /r",
    "name": "VCVTTPS2UDQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 78 /r",
    "name": "VCVTTPS2UQQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed unsigned quadword values in xmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 78 /r",
    "name": "VCVTTPS2UQQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 78 /r",
    "name": "VCVTTPS2UQQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 using truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W0 78 /r",
    "name": "VCVTTSD2USI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one unsigned doubleword integer r32 using truncation."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 78 /r",
    "name": "VCVTTSD2USI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Convert one double-precision floating-point value from xmm1/m64 to one unsigned quadword integer zero-extended into r64 using truncation."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 78 /r",
    "name": "VCVTTSS2USI",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32 using truncation."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W1 78 /r",
    "name": "VCVTTSS2USI",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Convert one single-precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64 using truncation."
  },
  {
    "opcode": "EVEX.128.F3.0F.W0 7A /r",
    "name": "VCVTUDQ2PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert two packed unsigned doubleword integers from ymm2/m64/m32bcst to packed double-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W0 7A /r",
    "name": "VCVTUDQ2PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed double-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W0 7A /r",
    "name": "VCVTUDQ2PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.128.F2.0F.W0 7A /r",
    "name": "VCVTUDQ2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed single-precision floating-point values in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.W0 7A /r",
    "name": "VCVTUDQ2PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to packed single-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.W0 7A /r",
    "name": "VCVTUDQ2PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert sixteen packed unsigned doubleword integers from zmm2/m512/m32bcst to sixteen packed single-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F.W1 7A /r",
    "name": "VCVTUQQ2PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to two packed double-precision floating-point values in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F.W1 7A /r",
    "name": "VCVTUQQ2PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed double-precision floating-point values in ymm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F.W1 7A /r",
    "name": "VCVTUQQ2PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.128.F2.0F.W1 7A /r",
    "name": "VCVTUQQ2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to packed single-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.256.F2.0F.W1 7A /r",
    "name": "VCVTUQQ2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed single-precision floating-point values in xmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.512.F2.0F.W1 7A /r",
    "name": "VCVTUQQ2PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed single-precision floating-point values in zmm1 with writemask k1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W0 7B /r",
    "name": "VCVTUSI2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one unsigned doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F2.0F.W1 7B /r",
    "name": "VCVTUSI2SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "r/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Convert one unsigned quadword integer from r/m64 to one double-precision floating-point value in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W0 7B /r",
    "name": "VCVTUSI2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "r/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "EVEX.LIG.F3.0F.W1 7B /r",
    "name": "VCVTUSI2SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "r/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.1",
    "flag": "AVX512F",
    "desc": "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 42 /r ib",
    "name": "VDBPSADBW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compute packed SAD word results of unsigned bytes in dword block from xmm2 with unsigned bytes of dword blocks transformed from xmm3/m128 using the shuffle controls in imm8. Results are written to xmm1 under the writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 42 /r ib",
    "name": "VDBPSADBW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compute packed SAD word results of unsigned bytes in dword block from ymm2 with unsigned bytes of dword blocks transformed from ymm3/m256 using the shuffle controls in imm8. Results are written to ymm1 under the writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 42 /r ib",
    "name": "VDBPSADBW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Compute packed SAD word results of unsigned bytes in dword block from zmm2 with unsigned bytes of dword blocks transformed from zmm3/m512 using the shuffle controls in imm8. Results are written to zmm1 under the writemask k1."
  },
  {
    "opcode": "0F 00 /4",
    "name": "VERR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set ZF=1 if segment specified with r/m16 can be read."
  },
  {
    "opcode": "0F 00 /5",
    "name": "VERW",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set ZF=1 if segment specified with r/m16 can be written."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 88 /r",
    "name": "VEXPANDPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Expand packed double-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 88 /r",
    "name": "VEXPANDPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Expand packed double-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 88 /r",
    "name": "VEXPANDPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Expand packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 88 /r",
    "name": "VEXPANDPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Expand packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 88 /r",
    "name": "VEXPANDPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Expand packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 88 /r",
    "name": "VEXPANDPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Expand packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 54 /r ib",
    "name": "VFIXUPIMMPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Fix up special numbers in float64 vector xmm1, float64 vector xmm2 and int64 vector xmm3/m128/m64bcst and store the result in xmm1, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 54 /r ib",
    "name": "VFIXUPIMMPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Fix up special numbers in float64 vector ymm1, float64 vector ymm2 and int64 vector ymm3/m256/m64bcst and store the result in ymm1, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 54 /r ib",
    "name": "VFIXUPIMMPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Fix up elements of float64 vector in zmm2 using int64 vector table in zmm3/m512/m64bcst, combine with preserved elements from zmm1, and store the result in zmm1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 54 /r",
    "name": "VFIXUPIMMPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Fix up special numbers in float32 vector xmm1, float32 vector xmm2 and int32 vector xmm3/m128/m32bcst and store the result in xmm1, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 54 /r",
    "name": "VFIXUPIMMPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Fix up special numbers in float32 vector ymm1, float32 vector ymm2 and int32 vector ymm3/m256/m32bcst and store the result in ymm1, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 54 /r ib",
    "name": "VFIXUPIMMPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Fix up elements of float32 vector in zmm2 using int32 vector table in zmm3/m512/m32bcst, combine with preserved elements from zmm1, and store the result in zmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W1 55 /r ib",
    "name": "VFIXUPIMMSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Fix up a float64 number in the low quadword element of xmm2 using scalar int32 table in xmm3/m64 and store the result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W0 55 /r ib",
    "name": "VFIXUPIMMSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Fix up a float32 number in the low doubleword element in xmm2 using scalar int32 table in xmm3/m32 and store the result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 98 /r",
    "name": "VFMADD132PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 A8 /r",
    "name": "VFMADD213PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 B8 /r",
    "name": "VFMADD231PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 98 /r",
    "name": "VFMADD132PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 A8 /r",
    "name": "VFMADD213PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 B8 /r",
    "name": "VFMADD231PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 98 /r",
    "name": "VFMADD132PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 A8 /r",
    "name": "VFMADD213PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m64bcst and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 B8 /r",
    "name": "VFMADD231PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 98 /r",
    "name": "VFMADD132PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, add to ymm2 and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 A8 /r",
    "name": "VFMADD213PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m64bcst and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 B8 /r",
    "name": "VFMADD231PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 98 /r",
    "name": "VFMADD132PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, add to zmm2 and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 A8 /r",
    "name": "VFMADD213PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m64bcst and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 B8 /r",
    "name": "VFMADD231PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, add to zmm1 and put result in zmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 98 /r",
    "name": "VFMADD132PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 A8 /r",
    "name": "VFMADD213PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 B8 /r",
    "name": "VFMADD231PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 98 /r",
    "name": "VFMADD132PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 A8 /r",
    "name": "VFMADD213PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.0 B8 /r",
    "name": "VFMADD231PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 98 /r",
    "name": "VFMADD132PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 A8 /r",
    "name": "VFMADD213PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m32bcst and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 B8 /r",
    "name": "VFMADD231PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 98 /r",
    "name": "VFMADD132PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, add to ymm2 and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 A8 /r",
    "name": "VFMADD213PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m32bcst and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 B8 /r",
    "name": "VFMADD231PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 98 /r",
    "name": "VFMADD132PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, add to zmm2 and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 A8 /r",
    "name": "VFMADD213PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m32bcst and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 B8 /r",
    "name": "VFMADD231PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, add to zmm1 and put result in zmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 99 /r",
    "name": "VFMADD132SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 A9 /r",
    "name": "VFMADD213SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 B9 /r",
    "name": "VFMADD231SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 99 /r",
    "name": "VFMADD132SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 A9 /r",
    "name": "VFMADD213SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 B9 /r",
    "name": "VFMADD231SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 99 /r",
    "name": "VFMADD132SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 A9 /r",
    "name": "VFMADD213SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 B9 /r",
    "name": "VFMADD231SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 99 /r",
    "name": "VFMADD132SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 A9 /r",
    "name": "VFMADD213SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 B9 /r",
    "name": "VFMADD231SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 96 /r",
    "name": "VFMADDSUB132PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 A6 /r",
    "name": "VFMADDSUB213PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 B6 /r",
    "name": "VFMADDSUB231PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 96 /r",
    "name": "VFMADDSUB132PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 A6 /r",
    "name": "VFMADDSUB213PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 B6 /r",
    "name": "VFMADDSUB231PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 A6 /r",
    "name": "VFMADDSUB213PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 B6 /r",
    "name": "VFMADDSUB231PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 96 /r",
    "name": "VFMADDSUB132PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, add/subtract elements in xmm2 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 A6 /r",
    "name": "VFMADDSUB213PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 B6 /r",
    "name": "VFMADDSUB231PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 96 /r",
    "name": "VFMADDSUB132PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 A6 /r",
    "name": "VFMADDSUB213PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1and zmm2, add/subtract elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 B6 /r",
    "name": "VFMADDSUB231PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 96 /r",
    "name": "VFMADDSUB132PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 96 /r",
    "name": "VFMADDSUB132PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 A6 /r",
    "name": "VFMADDSUB213PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 B6 /r",
    "name": "VFMADDSUB231PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 96 /r",
    "name": "VFMADDSUB132PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 A6 /r",
    "name": "VFMADDSUB213PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 B6 /r",
    "name": "VFMADDSUB231PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 A6 /r",
    "name": "VFMADDSUB213PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 B6 /r",
    "name": "VFMADDSUB231PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 96 /r",
    "name": "VFMADDSUB132PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, add/subtract elements in zmm2 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 A6 /r",
    "name": "VFMADDSUB213PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 B6 /r",
    "name": "VFMADDSUB231PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 96 /r",
    "name": "VFMADDSUB132PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 A6 /r",
    "name": "VFMADDSUB213PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm2, add/subtract elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 B6 /r",
    "name": "VFMADDSUB231PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 96 /r",
    "name": "VFMADDSUB132PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 9A /r",
    "name": "VFMSUB132PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 AA /r",
    "name": "VFMSUB213PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 BA /r",
    "name": "VFMSUB231PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 9A /r",
    "name": "VFMSUB132PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 AA /r",
    "name": "VFMSUB213PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 BA /r",
    "name": "VFMSUB231PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1.S"
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 9A /r",
    "name": "VFMSUB132PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract xmm2 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 AA /r",
    "name": "VFMSUB213PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 BA /r",
    "name": "VFMSUB231PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract xmm1 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 9A /r",
    "name": "VFMSUB132PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract ymm2 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 AA /r",
    "name": "VFMSUB213PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 BA /r",
    "name": "VFMSUB231PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract ymm1 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 9A /r",
    "name": "VFMSUB132PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract zmm2 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 AA /r",
    "name": "VFMSUB213PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 BA /r",
    "name": "VFMSUB231PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract zmm1 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 9A /r",
    "name": "VFMSUB132PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 AA /r",
    "name": "VFMSUB213PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 BA /r",
    "name": "VFMSUB231PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 9A /r",
    "name": "VFMSUB132PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 AA /r",
    "name": "VFMSUB213PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.0 BA /r",
    "name": "VFMSUB231PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 9A /r",
    "name": "VFMSUB132PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 AA /r",
    "name": "VFMSUB213PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m32bcst and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 BA /r",
    "name": "VFMSUB231PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 9A /r",
    "name": "VFMSUB132PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract ymm2 and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 AA /r",
    "name": "VFMSUB213PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m32bcst and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 BA /r",
    "name": "VFMSUB231PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 9A /r",
    "name": "VFMSUB132PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract zmm2 and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 AA /r",
    "name": "VFMSUB213PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m32bcst and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 BA /r",
    "name": "VFMSUB231PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract zmm1 and put result in zmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 9B /r",
    "name": "VFMSUB132SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 AB /r",
    "name": "VFMSUB213SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 BB /r",
    "name": "VFMSUB231SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 9B /r",
    "name": "VFMSUB132SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 AB /r",
    "name": "VFMSUB213SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 BB /r",
    "name": "VFMSUB231SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 9B /r",
    "name": "VFMSUB132SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 AB /r",
    "name": "VFMSUB213SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 BB /r",
    "name": "VFMSUB231SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 9B /r",
    "name": "VFMSUB132SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 AB /r",
    "name": "VFMSUB213SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 BB /r",
    "name": "VFMSUB231SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 97 /r",
    "name": "VFMSUBADD132PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 A7 /r",
    "name": "VFMSUBADD213PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 B7 /r",
    "name": "VFMSUBADD231PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 97 /r",
    "name": "VFMSUBADD132PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 A7 /r",
    "name": "VFMSUBADD213PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 B7 /r",
    "name": "VFMSUBADD231PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 97 /r",
    "name": "VFMSUBADD132PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 A7 /r",
    "name": "VFMSUBADD213PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 B7 /r",
    "name": "VFMSUBADD231PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 97 /r",
    "name": "VFMSUBADD132PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 A7 /r",
    "name": "VFMSUBADD213PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 B7 /r",
    "name": "VFMSUBADD231PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 97 /r",
    "name": "VFMSUBADD132PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 A7 /r",
    "name": "VFMSUBADD213PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 B7 /r",
    "name": "VFMSUBADD231PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 97 /r",
    "name": "VFMSUBADD132PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 A7 /r",
    "name": "VFMSUBADD213PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 B7 /r",
    "name": "VFMSUBADD231PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 97 /r",
    "name": "VFMSUBADD132PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 A7 /r",
    "name": "VFMSUBADD213PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 B7 /r",
    "name": "VFMSUBADD231PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 97 /r",
    "name": "VFMSUBADD132PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 A7 /r",
    "name": "VFMSUBADD213PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 B7 /r",
    "name": "VFMSUBADD231PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 97 /r",
    "name": "VFMSUBADD132PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 A7 /r",
    "name": "VFMSUBADD213PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 B7 /r",
    "name": "VFMSUBADD231PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 97 /r",
    "name": "VFMSUBADD132PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 A7 /r",
    "name": "VFMSUBADD213PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 B7 /r",
    "name": "VFMSUBADD231PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 9C /r",
    "name": "VFNMADD132PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 AC /r",
    "name": "VFNMADD213PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 BC /r",
    "name": "VFNMADD231PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 9C /r",
    "name": "VFNMADD132PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 AC /r",
    "name": "VFNMADD213PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 BC /r",
    "name": "VFNMADD231PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 9C /r",
    "name": "VFNMADD132PD",
    "operands": [
      {
        "type": "xmm0 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm1",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 AC /r",
    "name": "VFNMADD213PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m64bcst and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 BC /r",
    "name": "VFNMADD231PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 9C /r",
    "name": "VFNMADD132PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm2 and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 AC /r",
    "name": "VFNMADD213PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m64bcst and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 BC /r",
    "name": "VFNMADD231PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 9C /r",
    "name": "VFNMADD132PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm2 and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 AC /r",
    "name": "VFNMADD213PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m64bcst and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 BC /r",
    "name": "VFNMADD231PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm1 and put result in zmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 9C /r",
    "name": "VFNMADD132PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 AC /r",
    "name": "VFNMADD213PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 BC /r",
    "name": "VFNMADD231PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 9C /r",
    "name": "VFNMADD132PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 AC /r",
    "name": "VFNMADD213PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.0 BC /r",
    "name": "VFNMADD231PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 9C /r",
    "name": "VFNMADD132PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 AC /r",
    "name": "VFNMADD213PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m32bcst and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 BC /r",
    "name": "VFNMADD231PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 9C /r",
    "name": "VFNMADD132PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm2 and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 AC /r",
    "name": "VFNMADD213PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m32bcst and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 BC /r",
    "name": "VFNMADD231PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 9C /r",
    "name": "VFNMADD132PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm2 and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 AC /r",
    "name": "VFNMADD213PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m32bcst and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 BC /r",
    "name": "VFNMADD231PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm1 and put result in zmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 9D /r",
    "name": "VFNMADD132SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 AD /r",
    "name": "VFNMADD213SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 BD /r",
    "name": "VFNMADD231SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 9D /r",
    "name": "VFNMADD132SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 AD /r",
    "name": "VFNMADD213SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m64 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 BD /r",
    "name": "VFNMADD231SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 9D /r",
    "name": "VFNMADD132SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 AD /r",
    "name": "VFNMADD213SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 BD /r",
    "name": "VFNMADD231SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 9D /r",
    "name": "VFNMADD132SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and add to xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 AD /r",
    "name": "VFNMADD213SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 BD /r",
    "name": "VFNMADD231SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 9E /r",
    "name": "VFNMSUB132PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 AE /r",
    "name": "VFNMSUB213PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 BE /r",
    "name": "VFNMSUB231PD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 9E /r",
    "name": "VFNMSUB132PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 AE /r",
    "name": "VFNMSUB213PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 BE /r",
    "name": "VFNMSUB231PD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 9E /r",
    "name": "VFNMSUB132PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 AE /r",
    "name": "VFNMSUB213PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m64bcst and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 BE /r",
    "name": "VFNMSUB231PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 9E /r",
    "name": "VFNMSUB132PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm2 and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 AE /r",
    "name": "VFNMSUB213PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m64bcst and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 BE /r",
    "name": "VFNMSUB231PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 9E /r",
    "name": "VFNMSUB132PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm2 and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 AE /r",
    "name": "VFNMSUB213PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m64bcst and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 BE /r",
    "name": "VFNMSUB231PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm1 and put result in zmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 9E /r",
    "name": "VFNMSUB132PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 AE /r",
    "name": "VFNMSUB213PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 BE /r",
    "name": "VFNMSUB231PS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 9E /r",
    "name": "VFNMSUB132PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 AE /r",
    "name": "VFNMSUB213PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.0 BE /r",
    "name": "VFNMSUB231PS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 9E /r",
    "name": "VFNMSUB132PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 AE /r",
    "name": "VFNMSUB213PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m32bcst and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 BE /r",
    "name": "VFNMSUB231PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result subtract add to xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 9E /r",
    "name": "VFNMSUB132PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and subtract ymm2 and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 AE /r",
    "name": "VFNMSUB213PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m32bcst and put result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 BE /r",
    "name": "VFNMSUB231PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result subtract add to ymm1 and put result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 9E /r",
    "name": "VFNMSUB132PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and subtract zmm2 and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 AE /r",
    "name": "VFNMSUB213PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m32bcst and put result in zmm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 BE /r",
    "name": "VFNMSUB231PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result subtract add to zmm1 and put result in zmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 9F /r",
    "name": "VFNMSUB132SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 AF /r",
    "name": "VFNMSUB213SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W1 BF /r",
    "name": "VFNMSUB231SD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 9F /r",
    "name": "VFNMSUB132SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 AF /r",
    "name": "VFNMSUB213SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m64 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 BF /r",
    "name": "VFNMSUB231SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 9F /r",
    "name": "VFNMSUB132SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 AF /r",
    "name": "VFNMSUB213SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1."
  },
  {
    "opcode": "VEX.LIG.66.0F38.W0 BF /r",
    "name": "VFNMSUB231SS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "FMA",
    "desc": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 9F /r",
    "name": "VFNMSUB132SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 AF /r",
    "name": "VFNMSUB213SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 BF /r",
    "name": "VFNMSUB231SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 66 /r ib",
    "name": "VFPCLASSPD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 66 /r ib",
    "name": "VFPCLASSPD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 66 /r ib",
    "name": "VFPCLASSPD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 66 /r ib",
    "name": "VFPCLASSPS",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 66 /r ib",
    "name": "VFPCLASSPS",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 66 /r ib",
    "name": "VFPCLASSPS",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W1 67 /r ib",
    "name": "VFPCLASSSD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m64",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W0 67 /r",
    "name": "VFPCLASSSS",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m32",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 92 /r",
    "name": "VGATHERDPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 93 /r",
    "name": "VGATHERQPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm64x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using qword indices specified in vm64x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 92 /r",
    "name": "VGATHERDPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 93 /r",
    "name": "VGATHERQPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm64y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using qword indices specified in vm64y, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 92 /vsib",
    "name": "VGATHERDPS",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 92 /vsib",
    "name": "VGATHERDPS",
    "operands": [
      {
        "type": "ymm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 92 /vsib",
    "name": "VGATHERDPS",
    "operands": [
      {
        "type": "zmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32z",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 92 /vsib",
    "name": "VGATHERDPD",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 92 /vsib",
    "name": "VGATHERDPD",
    "operands": [
      {
        "type": "ymm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 92 /vsib",
    "name": "VGATHERDPD",
    "operands": [
      {
        "type": "zmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed dword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 92 /r",
    "name": "VGATHERDPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 93 /r",
    "name": "VGATHERQPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm64x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using qword indices specified in vm64x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 92 /r",
    "name": "VGATHERDPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm32y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using dword indices specified in vm32y, gather single-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 93 /r",
    "name": "VGATHERQPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm64y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using qword indices specified in vm64y, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 93 /vsib",
    "name": "VGATHERQPS",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 93 /vsib",
    "name": "VGATHERQPS",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 93 /vsib",
    "name": "VGATHERQPS",
    "operands": [
      {
        "type": "ymm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64z",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 93 /vsib",
    "name": "VGATHERQPD",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 93 /vsib",
    "name": "VGATHERQPD",
    "operands": [
      {
        "type": "ymm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 93 /vsib",
    "name": "VGATHERQPD",
    "operands": [
      {
        "type": "zmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64z",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed qword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 42 /r",
    "name": "VGETEXPPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination register."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 42 /r",
    "name": "VGETEXPPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination register."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 42 /r",
    "name": "VGETEXPPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 42 /r",
    "name": "VGETEXPPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 42 /r",
    "name": "VGETEXPPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 42 /r",
    "name": "VGETEXPPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 43 /r",
    "name": "VGETEXPSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert the biased exponent (bits 62:52) of the low double-precision floating-point value in xmm3/m64 to a DP FP value representing unbiased integer exponent. Stores the result to the low 64-bit of xmm1 under the writemask k1 and merge with the other elements of xmm2."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 43 /r",
    "name": "VGETEXPSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Convert the biased exponent (bits 30:23) of the low single-precision floating-point value in xmm3/m32 to a SP FP value representing unbiased integer exponent. Stores the result to xmm1 under the writemask k1 and merge with the other elements of xmm2."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 26 /r ib",
    "name": "VGETMANTPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Get Normalized Mantissa from float64 vector xmm2/m128/m64bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 26 /r ib",
    "name": "VGETMANTPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Get Normalized Mantissa from float64 vector ymm2/m256/m64bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 26 /r ib",
    "name": "VGETMANTPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Get Normalized Mantissa from float64 vector zmm2/m512/m64bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 26 /r ib",
    "name": "VGETMANTPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Get normalized mantissa from float32 vector xmm2/m128/m32bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 26 /r ib",
    "name": "VGETMANTPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Get normalized mantissa from float32 vector ymm2/m256/m32bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 26 /r ib",
    "name": "VGETMANTPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Get normalized mantissa from float32 vector zmm2/m512/m32bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W1 27 /r ib",
    "name": "VGETMANTSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Extract the normalized mantissa of the low float64 element in xmm3/m64 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W0 27 /r ib",
    "name": "VGETMANTSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Extract the normalized mantissa from the low float32 element of xmm3/m32 using imm8 for sign control and mantissa interval normalization, store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 2C /r",
    "name": "VMASKMOVPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 2C /r",
    "name": "VMASKMOVPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 2D /r",
    "name": "VMASKMOVPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 2D /r",
    "name": "VMASKMOVPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 2E /r",
    "name": "VMASKMOVPS",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally store packed single-precision values from xmm2 using mask in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 2E /r",
    "name": "VMASKMOVPS",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally store packed single-precision values from ymm2 using mask in ymm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 2F /r",
    "name": "VMASKMOVPD",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally store packed double-precision values from xmm2 using mask in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 2F /r",
    "name": "VMASKMOVPD",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Conditionally store packed double-precision values from ymm2 using mask in ymm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 02 /r ib",
    "name": "VPBLENDD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 02 /r ib",
    "name": "VPBLENDD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 66 /r",
    "name": "VPBLENDMB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Blend byte integer vector xmm2 and byte vector xmm3/m128 and store the result in xmm1, under control mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 66 /r",
    "name": "VPBLENDMB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Blend byte integer vector ymm2 and byte vector ymm3/m256 and store the result in ymm1, under control mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 66 /r",
    "name": "VPBLENDMB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Blend byte integer vector zmm2 and byte vector zmm3/m512 and store the result in zmm1, under control mask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 66 /r",
    "name": "VPBLENDMW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Blend word integer vector xmm2 and word vector xmm3/m128 and store the result in xmm1, under control mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 66 /r",
    "name": "VPBLENDMW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Blend word integer vector ymm2 and word vector ymm3/m256 and store the result in ymm1, under control mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 66 /r",
    "name": "VPBLENDMW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Blend word integer vector zmm2 and word vector zmm3/m512 and store the result in zmm1, under control mask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 64 /r",
    "name": "VPBLENDMD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Blend doubleword integer vector xmm2 and doubleword vector xmm3/m128/m32bcst and store the result in xmm1, under control mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 64 /r",
    "name": "VPBLENDMD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Blend doubleword integer vector ymm2 and doubleword vector ymm3/m256/m32bcst and store the result in ymm1, under control mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 64 /r",
    "name": "VPBLENDMD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Blend doubleword integer vector zmm2 and doubleword vector zmm3/m512/m32bcst and store the result in zmm1, under control mask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 64 /r",
    "name": "VPBLENDMQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Blend quadword integer vector xmm2 and quadword vector xmm3/m128/m64bcst and store the result in xmm1, under control mask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 64 /r",
    "name": "VPBLENDMQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Blend quadword integer vector ymm2 and quadword vector ymm3/m256/m64bcst and store the result in ymm1, under control mask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 64 /r",
    "name": "VPBLENDMQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Blend quadword integer vector zmm2 and quadword vector zmm3/m512/m64bcst and store the result in zmm1, under control mask."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W1 2A /r",
    "name": "VPBROADCASTMB2Q",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Broadcast low byte value in k1 to two locations in xmm1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W1 2A /r",
    "name": "VPBROADCASTMB2Q",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Broadcast low byte value in k1 to four locations in ymm1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W1 2A /r",
    "name": "VPBROADCASTMB2Q",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512CD",
    "desc": "Broadcast low byte value in k1 to eight locations in zmm1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 3A /r",
    "name": "VPBROADCASTMW2D",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Broadcast low word value in k1 to four locations in xmm1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 3A /r",
    "name": "VPBROADCASTMW2D",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Broadcast low word value in k1 to eight locations in ymm1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 3A /r",
    "name": "VPBROADCASTMW2D",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512CD",
    "desc": "Broadcast low word value in k1 to sixteen locations in zmm1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 3F /r ib",
    "name": "VPCMPB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed byte values in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 3F /r ib",
    "name": "VPCMPB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed byte values in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 3F /r ib",
    "name": "VPCMPB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Compare packed signed byte values in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 3E /r ib",
    "name": "VPCMPUB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed unsigned byte values in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 3E /r ib",
    "name": "VPCMPUB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed unsigned byte values in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 3E /r ib",
    "name": "VPCMPUB",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Compare packed unsigned byte values in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 1F /r ib",
    "name": "VPCMPD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 1F /r ib",
    "name": "VPCMPD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 1F /r ib",
    "name": "VPCMPD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed signed doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of imm8 as a comparison predicate. The comparison results are written to the destination k1 under writemask k2."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 1E /r ib",
    "name": "VPCMPUD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 1E /r ib",
    "name": "VPCMPUD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 1E /r ib",
    "name": "VPCMPUD",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed unsigned doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of imm8 as a comparison predicate. The comparison results are written to the destination k1 under writemask k2."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 1F /r ib",
    "name": "VPCMPQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 1F /r ib",
    "name": "VPCMPQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed signed quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 1F /r ib",
    "name": "VPCMPQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed signed quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 1E /r ib",
    "name": "VPCMPUQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 1E /r ib",
    "name": "VPCMPUQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compare packed unsigned quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 1E /r ib",
    "name": "VPCMPUQ",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compare packed unsigned quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 3F /r ib",
    "name": "VPCMPW",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed word integers in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 3F /r ib",
    "name": "VPCMPW",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed signed word integers in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 3F /r ib",
    "name": "VPCMPW",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Compare packed signed word integers in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 3E /r ib",
    "name": "VPCMPUW",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed unsigned word integers in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 3E /r ib",
    "name": "VPCMPUW",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Compare packed unsigned word integers in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "",
    "name": "VPCMPUW",
    "operands": [
      {
        "type": "k1 {k2}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Compare packed unsigned word integers in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 8B /r",
    "name": "VPCOMPRESSD",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compress packed doubleword integer values from xmm2 to xmm1/m128 using controlmask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 8B /r",
    "name": "VPCOMPRESSD",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compress packed doubleword integer values from ymm2 to ymm1/m256 using controlmask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 8B /r",
    "name": "VPCOMPRESSD",
    "operands": [
      {
        "type": "zmm1/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compress packed doubleword integer values from zmm2 to zmm1/m512 using controlmask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 8B /r",
    "name": "VPCOMPRESSQ",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compress packed quadword integer values from xmm2 to xmm1/m128 using controlmask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 8B /r",
    "name": "VPCOMPRESSQ",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Compress packed quadword integer values from ymm2 to ymm1/m256 using controlmask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 8B /r",
    "name": "VPCOMPRESSQ",
    "operands": [
      {
        "type": "zmm1/m512 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Compress packed quadword integer values from zmm2 to zmm1/m512 using controlmask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 C4 /r",
    "name": "VPCONFLICTD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Detect duplicate double-word values in xmm2/m128/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 C4 /r",
    "name": "VPCONFLICTD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Detect duplicate double-word values in ymm2/m256/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 C4 /r",
    "name": "VPCONFLICTD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512CD",
    "desc": "Detect duplicate double-word values in zmm2/m512/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 C4 /r",
    "name": "VPCONFLICTQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Detect duplicate quad-word values in xmm2/m128/m64bcst using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 C4 /r",
    "name": "VPCONFLICTQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Detect duplicate quad-word values in ymm2/m256/m64bcst using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 C4 /r",
    "name": "VPCONFLICTQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512CD",
    "desc": "Detect duplicate quad-word values in zmm2/m512/m64bcst using writemask k1."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 06 /r ib",
    "name": "VPERM2F128",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 46 /r ib",
    "name": "VPERM2I128",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 8D /r",
    "name": "VPERMB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512_VBMI",
    "desc": "Permute bytes in xmm3/m128 using byte indexes in xmm2 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 8D /r",
    "name": "VPERMB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512_VBMI",
    "desc": "Permute bytes in ymm3/m256 using byte indexes in ymm2 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 8D /r",
    "name": "VPERMB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_VBMI",
    "desc": "Permute bytes in zmm3/m512 using byte indexes in zmm2 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 36 /r",
    "name": "VPERMD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Permute doublewords in ymm3/m256 using indices in ymm2 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 36 /r",
    "name": "VPERMD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute doublewords in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 36 /r",
    "name": "VPERMD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute doublewords in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 8D /r",
    "name": "VPERMW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Permute word integers in xmm3/m128 using indexes in xmm2 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 8D /r",
    "name": "VPERMW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Permute word integers in ymm3/m256 using indexes in ymm2 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 8D /r",
    "name": "VPERMW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Permute word integers in zmm3/m512 using indexes in zmm2 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 75 /r",
    "name": "VPERMI2B",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512_VBMI",
    "desc": "Permute bytes in xmm3/m128 and xmm2 using byte indexes in xmm1 and store the byte results in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 75 /r",
    "name": "VPERMI2B",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512_VBMI",
    "desc": "Permute bytes in ymm3/m256 and ymm2 using byte indexes in ymm1 and store the byte results in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 75 /r",
    "name": "VPERMI2B",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_VBMI",
    "desc": "Permute bytes in zmm3/m512 and zmm2 using byte indexes in zmm1 and store the byte results in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 75 /r",
    "name": "VPERMI2W",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Permute word integers from two tables in xmm3/m128 and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 75 /r",
    "name": "VPERMI2W",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Permute word integers from two tables in ymm3/m256 and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 75 /r",
    "name": "VPERMI2W",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Permute word integers from two tables in zmm3/m512 and zmm2 using indexes in zmm1 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 76 /r",
    "name": "VPERMI2D",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-words from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 76 /r",
    "name": "VPERMI2D",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-words from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 76 /r",
    "name": "VPERMI2D",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute double-words from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 76 /r",
    "name": "VPERMI2Q",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute quad-words from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 76 /r",
    "name": "VPERMI2Q",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute quad-words from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 76 /r",
    "name": "VPERMI2Q",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute quad-words from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 77 /r",
    "name": "VPERMI2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision FP values from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 77 /r",
    "name": "VPERMI2PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision FP values from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 77 /r",
    "name": "VPERMI2PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute single-precision FP values from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 77 /r",
    "name": "VPERMI2PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision FP values from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 77 /r",
    "name": "VPERMI2PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision FP values from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 77 /r",
    "name": "VPERMI2PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute double-precision FP values from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 0D /r",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute double-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 0D /r",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute double-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 0D /r",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision floating-point values in xmm2 using control from xmm3/m128/m64bcst and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 0D /r",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision floating-point values in ymm2 using control from ymm3/m256/m64bcst and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 0D /r",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute double-precision floating-point values in zmm2 using control from zmm3/m512/m64bcst and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 05 /r ib",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute double-precision floating-point values in xmm2/m128 using controls from imm8."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 05 /r ib",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute double-precision floating-point values in ymm2/m256 using controls from imm8."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 05 /r ib",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision floating-point values in xmm2/m128/m64bcst using controls from imm8 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 05 /r ib",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision floating-point values in ymm2/m256/m64bcst using controls from imm8 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 05 /r ib",
    "name": "VPERMILPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute double-precision floating-point values in zmm2/m512/m64bcst using controls from imm8 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 0C /r",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute single-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1."
  },
  {
    "opcode": "VEX.128.66.0F3A.W0 04 /r ib",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute single-precision floating-point values in xmm2/m128 using controls from imm8 and store result in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 0C /r",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute single-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1."
  },
  {
    "opcode": "VEX.256.66.0F3A.W0 04 /r ib",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Permute single-precision floating-point values in ymm2/m256 using controls from imm8 and store result in ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 0C /r",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision floating-point values xmm2 using control from xmm3/m128/m32bcst and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 0C /r",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision floating-point values ymm2 using control from ymm3/m256/m32bcst and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 0C /r",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute single-precision floating-point values zmm2 using control from zmm3/m512/m32bcst and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 04 /r ib",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision floating-point values xmm2/m128/m32bcst using controls from imm8 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 04 /r ib",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision floating-point values ymm2/m256/m32bcst using controls from imm8 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 04 /r ib",
    "name": "VPERMILPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute single-precision floating-point values zmm2/m512/m32bcst using controls from imm8 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "VEX.256.66.0F3A.W1 01 /r ib",
    "name": "VPERMPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Permute double-precision floating-point elements in ymm2/m256 using indices in imm8 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 01 /r ib",
    "name": "VPERMPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision floating-point elements in ymm2/m256/m64bcst using indexes in imm8 and store the result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 01 /r ib",
    "name": "VPERMPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute double-precision floating-point elements in zmm2/m512/m64bcst using indices in imm8 and store the result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 16 /r",
    "name": "VPERMPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision floating-point elements in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1 subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 16 /r",
    "name": "VPERMPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute double-precision floating-point elements in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1 subject to writemask k1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 16 /r",
    "name": "VPERMPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Permute single-precision floating-point elements in ymm3/m256 using indices in ymm2 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 16 /r",
    "name": "VPERMPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision floating-point elements in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 subject to write mask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 16 /r",
    "name": "VPERMPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute single-precision floating-point values in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 subject to write mask k1."
  },
  {
    "opcode": "VEX.256.66.0F3A.W1 00 /r ib",
    "name": "VPERMQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Permute qwords in ymm2/m256 using indices in imm8 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 00 /r ib",
    "name": "VPERMQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute qwords in ymm2/m256/m64bcst using indexes in imm8 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 00 /r ib",
    "name": "VPERMQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute qwords in zmm2/m512/m64bcst using indices in imm8 and store the result in zmm1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 36 /r",
    "name": "VPERMQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute qwords in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 36 /r",
    "name": "VPERMQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute qwords in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 7D /r",
    "name": "VPERMT2B",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512_VBMI",
    "desc": "Permute bytes in xmm3/m128 and xmm1 using byte indexes in xmm2 and store the byte results in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 7D /r",
    "name": "VPERMT2B",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512_VBMI",
    "desc": "Permute bytes in ymm3/m256 and ymm1 using byte indexes in ymm2 and store the byte results in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 7D /r",
    "name": "VPERMT2B",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_VBMI",
    "desc": "Permute bytes in zmm3/m512 and zmm1 using byte indexes in zmm2 and store the byte results in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 7D /r",
    "name": "VPERMT2W",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Permute word integers from two tables in xmm3/m128 and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 7D /r",
    "name": "VPERMT2W",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Permute word integers from two tables in ymm3/m256 and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 7D /r",
    "name": "VPERMT2W",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Permute word integers from two tables in zmm3/m512 and zmm1 using indexes in zmm2 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 7E /r",
    "name": "VPERMT2D",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-words from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 7E /r",
    "name": "VPERMT2D",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-words from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 7E /r",
    "name": "VPERMT2D",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute double-words from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 7E /r",
    "name": "VPERMT2Q",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute quad-words from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 7E /r",
    "name": "VPERMT2Q",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute quad-words from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 7E /r",
    "name": "VPERMT2Q",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute quad-words from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 7F /r",
    "name": "VPERMT2PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision FP values from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 7F /r",
    "name": "VPERMT2PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute single-precision FP values from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 7F /r",
    "name": "VPERMT2PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute single-precision FP values from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 7F /r",
    "name": "VPERMT2PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision FP values from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 7F /r",
    "name": "VPERMT2PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Permute double-precision FP values from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 7F /r",
    "name": "VPERMT2PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Permute double-precision FP values from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 89 /r",
    "name": "VPEXPANDD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Expand packed double-word integer values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 89 /r",
    "name": "VPEXPANDD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Expand packed double-word integer values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 89 /r",
    "name": "VPEXPANDD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Expand packed double-word integer values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 89 /r",
    "name": "VPEXPANDQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Expand packed quad-word integer values from xmm2/m128 to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 89 /r",
    "name": "VPEXPANDQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Expand packed quad-word integer values from ymm2/m256 to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 89 /r",
    "name": "VPEXPANDQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Expand packed quad-word integer values from zmm2/m512 to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 90 /vsib",
    "name": "VPGATHERDD",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 90 /vsib",
    "name": "VPGATHERDD",
    "operands": [
      {
        "type": "ymm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 90 /vsib",
    "name": "VPGATHERDD",
    "operands": [
      {
        "type": "zmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32z",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 90 /vsib",
    "name": "VPGATHERDQ",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 90 /vsib",
    "name": "VPGATHERDQ",
    "operands": [
      {
        "type": "ymm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 90 /vsib",
    "name": "VPGATHERDQ",
    "operands": [
      {
        "type": "zmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm32y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 90 /r",
    "name": "VPGATHERDD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using dword indices specified in vm32x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 91 /r",
    "name": "VPGATHERQD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm64x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using qword indices specified in vm64x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 90 /r",
    "name": "VPGATHERDD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm32y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using dword indices specified in vm32y, gather dword from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 91 /r",
    "name": "VPGATHERQD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm64y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using qword indices specified in vm64y, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 90 /r",
    "name": "VPGATHERDQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 91 /r",
    "name": "VPGATHERQQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm64x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using qword indices specified in vm64x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 90 /r",
    "name": "VPGATHERDQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm32x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 91 /r",
    "name": "VPGATHERQQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r,w)"
      },
      {
        "type": "vm64y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r, w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Using qword indices specified in vm64y, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 91 /vsib",
    "name": "VPGATHERQD",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 91 /vsib",
    "name": "VPGATHERQD",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 91 /vsib",
    "name": "VPGATHERQD",
    "operands": [
      {
        "type": "ymm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64z",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 91 /vsib",
    "name": "VPGATHERQQ",
    "operands": [
      {
        "type": "xmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64x",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 91 /vsib",
    "name": "VPGATHERQQ",
    "operands": [
      {
        "type": "ymm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64y",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 91 /vsib",
    "name": "VPGATHERQQ",
    "operands": [
      {
        "type": "zmm1 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "vm64z",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 44 /r",
    "name": "VPLZCNTD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Count the number of leading zero bits in each dword element of xmm2/m128/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 44 /r",
    "name": "VPLZCNTD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Count the number of leading zero bits in each dword element of ymm2/m256/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 44 /r",
    "name": "VPLZCNTD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512CD",
    "desc": "Count the number of leading zero bits in each dword element of zmm2/m512/m32bcst using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 44 /r",
    "name": "VPLZCNTQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Count the number of leading zero bits in each qword element of xmm2/m128/m64bcst using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 44 /r",
    "name": "VPLZCNTQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512CD",
    "desc": "Count the number of leading zero bits in each qword element of ymm2/m256/m64bcst using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 44 /r",
    "name": "VPLZCNTQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512CD",
    "desc": "Count the number of leading zero bits in each qword element of zmm2/m512/m64bcst using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 B5 /r",
    "name": "VPMADD52HUQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m(r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_IFMA AVX512VL",
    "desc": "Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the high 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 B5 /r",
    "name": "VPMADD52HUQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m(r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_IFMA AVX512VL",
    "desc": "Multiply unsigned 52-bit integers in ymm2 and ymm3/m128 and add the high 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 B5 /r",
    "name": "VPMADD52HUQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m(r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_IFMA",
    "desc": "Multiply unsigned 52-bit integers in zmm2 and zmm3/m128 and add the high 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 B4 /r",
    "name": "VPMADD52LUQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m(r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_IFMA AVX512VL",
    "desc": "Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 B4 /r",
    "name": "VPMADD52LUQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m(r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_IFMA AVX512VL",
    "desc": "Multiply unsigned 52-bit integers in ymm2 and ymm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 B4 /r",
    "name": "VPMADD52LUQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m(r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_IFMA",
    "desc": "Multiply unsigned 52-bit integers in zmm2 and zmm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 8C /r",
    "name": "VPMASKMOVD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Conditionally load dword values from m128 using mask in xmm2 and store in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 8C /r",
    "name": "VPMASKMOVD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Conditionally load dword values from m256 using mask in ymm2 and store in ymm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 8C /r",
    "name": "VPMASKMOVQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Conditionally load qword values from m128 using mask in xmm2 and store in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 8C /r",
    "name": "VPMASKMOVQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Conditionally load qword values from m256 using mask in ymm2 and store in ymm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 8E /r",
    "name": "VPMASKMOVD",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Conditionally store dword values from xmm2 using mask in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 8E /r",
    "name": "VPMASKMOVD",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Conditionally store dword values from ymm2 using mask in ymm1."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 8E /r",
    "name": "VPMASKMOVQ",
    "operands": [
      {
        "type": "m128",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm1",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Conditionally store qword values from xmm2 using mask in xmm1."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 8E /r",
    "name": "VPMASKMOVQ",
    "operands": [
      {
        "type": "m256",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm1",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Conditionally store qword values from ymm2 using mask in ymm1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 29 /r",
    "name": "VPMOVB2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in XMM1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 29 /r",
    "name": "VPMOVB2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in YMM1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 29 /r",
    "name": "VPMOVB2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in ZMM1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W1 29 /r",
    "name": "VPMOVW2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in XMM1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W1 29 /r",
    "name": "VPMOVW2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in YMM1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W1 29 /r",
    "name": "VPMOVW2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in ZMM1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 39 /r",
    "name": "VPMOVD2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in XMM1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 39 /r",
    "name": "VPMOVD2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in YMM1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 39 /r",
    "name": "VPMOVD2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in ZMM1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W1 39 /r",
    "name": "VPMOVQ2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in XMM1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W1 39 /r",
    "name": "VPMOVQ2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in YMM1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W1 39 /r",
    "name": "VPMOVQ2M",
    "operands": [
      {
        "type": "k1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in ZMM1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 31 /r",
    "name": "VPMOVDB",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed double-word integers from xmm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 21 /r",
    "name": "VPMOVSDB",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed signed double-word integers from xmm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 11 /r",
    "name": "VPMOVUSDB",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 31 /r",
    "name": "VPMOVDB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 8 packed double-word integers from ymm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 21 /r",
    "name": "VPMOVSDB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 8 packed signed double-word integers from ymm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 11 /r",
    "name": "VPMOVUSDB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 31 /r",
    "name": "VPMOVDB",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 16 packed double-word integers from zmm2 into 16 packed byte integers in xmm1/m128 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 21 /r",
    "name": "VPMOVSDB",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 16 packed signed double-word integers from zmm2 into 16 packed signed byte integers in xmm1/m128 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 11 /r",
    "name": "VPMOVUSDB",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned byte integers in xmm1/m128 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 33 /r",
    "name": "VPMOVDW",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed double-word integers from xmm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 23 /r",
    "name": "VPMOVSDW",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed signed double-word integers from xmm2 into 4 packed signed word integers in ymm1/m64 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 13 /r",
    "name": "VPMOVUSDW",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 33 /r",
    "name": "VPMOVDW",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 8 packed double-word integers from ymm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 23 /r",
    "name": "VPMOVSDW",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 8 packed signed double-word integers from ymm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 13 /r",
    "name": "VPMOVUSDW",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 33 /r",
    "name": "VPMOVDW",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 16 packed double-word integers from zmm2 into 16 packed word integers in ymm1/m256 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 23 /r",
    "name": "VPMOVSDW",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 16 packed signed double-word integers from zmm2 into 16 packed signed word integers in ymm1/m256 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 13 /r",
    "name": "VPMOVUSDW",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned word integers in ymm1/m256 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 28 /r",
    "name": "VPMOVM2B",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sets each byte in XMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 28 /r",
    "name": "VPMOVM2B",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sets each byte in YMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 28 /r",
    "name": "VPMOVM2B",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Sets each byte in ZMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W1 28 /r",
    "name": "VPMOVM2W",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sets each word in XMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W1 28 /r",
    "name": "VPMOVM2W",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Sets each word in YMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W1 28 /r",
    "name": "VPMOVM2W",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Sets each word in ZMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 38 /r",
    "name": "VPMOVM2D",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Sets each doubleword in XMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 38 /r",
    "name": "VPMOVM2D",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Sets each doubleword in YMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 38 /r",
    "name": "VPMOVM2D",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Sets each doubleword in ZMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W1 38 /r",
    "name": "VPMOVM2Q",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Sets each quadword in XMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W1 38 /r",
    "name": "VPMOVM2Q",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Sets each quadword in YMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W1 38 /r",
    "name": "VPMOVM2Q",
    "operands": [
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "k1",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Sets each quadword in ZMM1 to all 1s or all 0s based on the value of the corresponding bit in k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 32 /r",
    "name": "VPMOVQB",
    "operands": [
      {
        "type": "xmm1/m16 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 2 packed quad-word integers from xmm2 into 2 packed byte integers in xmm1/m16 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 22 /r",
    "name": "VPMOVSQB",
    "operands": [
      {
        "type": "xmm1/m16 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed byte integers in xmm1/m16 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 12 /r",
    "name": "VPMOVUSQB",
    "operands": [
      {
        "type": "xmm1/m16 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned byte integers in xmm1/m16 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 32 /r",
    "name": "VPMOVQB",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed quad-word integers from ymm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 22 /r",
    "name": "VPMOVSQB",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 12 /r",
    "name": "VPMOVUSQB",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 32 /r",
    "name": "VPMOVQB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed quad-word integers from zmm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 22 /r",
    "name": "VPMOVSQB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 12 /r",
    "name": "VPMOVUSQB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 35 /r",
    "name": "VPMOVQD",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 2 packed quad-word integers from xmm2 into 2 packed double-word integers in xmm1/m128 with truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 25 /r",
    "name": "VPMOVSQD",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed double-word integers in xmm1/m64 using signed saturation subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 15 /r",
    "name": "VPMOVUSQD",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned double-word integers in xmm1/m64 using unsigned saturation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 35 /r",
    "name": "VPMOVQD",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed quad-word integers from ymm2 into 4 packed double-word integers in xmm1/m128 with truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 25 /r",
    "name": "VPMOVSQD",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed double-word integers in xmm1/m128 using signed saturation subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 15 /r",
    "name": "VPMOVUSQD",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned double-word integers in xmm1/m128 using unsigned saturation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 35 /r",
    "name": "VPMOVQD",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed quad-word integers from zmm2 into 8 packed double-word integers in ymm1/m256 with truncation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 25 /r",
    "name": "VPMOVSQD",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed double-word integers in ymm1/m256 using signed saturation subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 15 /r",
    "name": "VPMOVUSQD",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned double-word integers in ymm1/m256 using unsigned saturation subject to writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 34 /r",
    "name": "VPMOVQW",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 2 packed quad-word integers from xmm2 into 2 packed word integers in xmm1/m32 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 24 /r",
    "name": "VPMOVSQW",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m32 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 14 /r",
    "name": "VPMOVUSQW",
    "operands": [
      {
        "type": "xmm1/m32 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned word integers in xmm1/m32 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 34 /r",
    "name": "VPMOVQW",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed quad-word integers from ymm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 24 /r",
    "name": "VPMOVSQW",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed word integers in xmm1/m64 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 14 /r",
    "name": "VPMOVUSQW",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 34 /r",
    "name": "VPMOVQW",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed quad-word integers from zmm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 24 /r",
    "name": "VPMOVSQW",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 14 /r",
    "name": "VPMOVUSQW",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 30 /r",
    "name": "VPMOVWB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts 8 packed word integers from xmm2 into 8 packed bytes in xmm1/m64 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 20 /r",
    "name": "VPMOVSWB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts 8 packed signed word integers from xmm2 into 8 packed signed bytes in xmm1/m64 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 10 /r",
    "name": "VPMOVUSWB",
    "operands": [
      {
        "type": "xmm1/m64 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "xmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts 8 packed unsigned word integers from xmm2 into 8 packed unsigned bytes in 8mm1/m64 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 30 /r",
    "name": "VPMOVWB",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts 16 packed word integers from ymm2 into 16 packed bytes in xmm1/m128 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 20 /r",
    "name": "VPMOVSWB",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts 16 packed signed word integers from ymm2 into 16 packed signed bytes in xmm1/m128 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 10 /r",
    "name": "VPMOVUSWB",
    "operands": [
      {
        "type": "xmm1/m128 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "ymm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Converts 16 packed unsigned word integers from ymm2 into 16 packed unsigned bytes in xmm1/m128 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 30 /r",
    "name": "VPMOVWB",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Converts 32 packed word integers from zmm2 into 32 packed bytes in ymm1/m256 with truncation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 20 /r",
    "name": "VPMOVSWB",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Converts 32 packed signed word integers from zmm2 into 32 packed signed bytes in ymm1/m256 using signed saturation under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 10 /r",
    "name": "VPMOVUSWB",
    "operands": [
      {
        "type": "ymm1/m256 {k1}{z}",
        "encoding": "ModRM:r/m (w)"
      },
      {
        "type": "zmm2",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Converts 32 packed unsigned word integers from zmm2 into 32 packed unsigned bytes in ymm1/m256 using unsigned saturation under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 83 /r",
    "name": "VPMULTISHIFTQB",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_VBMI AVX512VL",
    "desc": "Select unaligned bytes from qwords in xmm3/m128/m64bcst using control bytes in xmm2, write byte results to xmm1 under k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 83 /r",
    "name": "VPMULTISHIFTQB",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_VBMI AVX512VL",
    "desc": "Select unaligned bytes from qwords in ymm3/m256/m64bcst using control bytes in ymm2, write byte results to ymm1 under k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 83 /r",
    "name": "VPMULTISHIFTQB",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512_VBMI",
    "desc": "Select unaligned bytes from qwords in zmm3/m512/m64bcst using control bytes in zmm2, write byte results to zmm1 under k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 15 /r",
    "name": "VPROLVD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate doublewords in xmm2 left by count in the corresponding element of xmm3/m128/m32bcst. Result written to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 72 /1 ib",
    "name": "VPROLD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate doublewords in xmm2/m128/m32bcst left by imm8. Result written to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 15 /r",
    "name": "VPROLVQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate quadwords in xmm2 left by count in the corresponding element of xmm3/m128/m64bcst. Result written to xmm1 under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 72 /1 ib",
    "name": "VPROLQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate quadwords in xmm2/m128/m64bcst left by imm8. Result written to xmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 15 /r",
    "name": "VPROLVD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate doublewords in ymm2 left by count in the corresponding element of ymm3/m256/m32bcst. Result written to ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 72 /1 ib",
    "name": "VPROLD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate doublewords in ymm2/m256/m32bcst left by imm8. Result written to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 15 /r",
    "name": "VPROLVQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate quadwords in ymm2 left by count in the corresponding element of ymm3/m256/m64bcst. Result written to ymm1 under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 72 /1 ib",
    "name": "VPROLQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate quadwords in ymm2/m256/m64bcst left by imm8. Result written to ymm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 15 /r",
    "name": "VPROLVD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rotate left of doublewords in zmm2 by count in the corresponding element of zmm3/m512/m32bcst. Result written to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 72 /1 ib",
    "name": "VPROLD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rotate left of doublewords in zmm3/m512/m32bcst by imm8. Result written to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 15 /r",
    "name": "VPROLVQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rotate quadwords in zmm2 left by count in the corresponding element of zmm3/m512/m64bcst. Result written to zmm1under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 72 /1 ib",
    "name": "VPROLQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rotate quadwords in zmm2/m512/m64bcst left by imm8. Result written to zmm1 using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 14 /r",
    "name": "VPRORVD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate doublewords in xmm2 right by count in the corresponding element of xmm3/m128/m32bcst, store result using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W0 72 /0 ib",
    "name": "VPRORD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate doublewords in xmm2/m128/m32bcst right by imm8, store result using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 14 /r",
    "name": "VPRORVQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate quadwords in xmm2 right by count in the corresponding element of xmm3/m128/m64bcst, store result using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 72 /0 ib",
    "name": "VPRORQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate quadwords in xmm2/m128/m64bcst right by imm8, store result using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 14 /r",
    "name": "VPRORVD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate doublewords in ymm2 right by count in the corresponding element of ymm3/m256/m32bcst, store using result writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W0 72 /0 ib",
    "name": "VPRORD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate doublewords in ymm2/m256/m32bcst right by imm8, store result using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 14 /r",
    "name": "VPRORVQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate quadwords in ymm2 right by count in the corresponding element of ymm3/m256/m64bcst, store result using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 72 /0 ib",
    "name": "VPRORQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rotate quadwords in ymm2/m256/m64bcst right by imm8, store result using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 14 /r",
    "name": "VPRORVD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rotate doublewords in zmm2 right by count in the corresponding element of zmm3/m512/m32bcst, store result using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W0 72 /0 ib",
    "name": "VPRORD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rotate doublewords in zmm2/m512/m32bcst right by imm8, store result using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 14 /r",
    "name": "VPRORVQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rotate quadwords in zmm2 right by count in the corresponding element of zmm3/m512/m64bcst, store result using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 72 /0 ib",
    "name": "VPRORQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "VEX.vvvv (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (R)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rotate quadwords in zmm2/m512/m64bcst right by imm8, store result using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 A0 /vsib",
    "name": "VPSCATTERDD",
    "operands": [
      {
        "type": "vm32x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, scatter dword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 A0 /vsib",
    "name": "VPSCATTERDD",
    "operands": [
      {
        "type": "vm32y {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, scatter dword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 A0 /vsib",
    "name": "VPSCATTERDD",
    "operands": [
      {
        "type": "vm32z {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed dword indices, scatter dword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 A0 /vsib",
    "name": "VPSCATTERDQ",
    "operands": [
      {
        "type": "vm32x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, scatter qword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 A0 /vsib",
    "name": "VPSCATTERDQ",
    "operands": [
      {
        "type": "vm32x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, scatter qword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 A0 /vsib",
    "name": "VPSCATTERDQ",
    "operands": [
      {
        "type": "vm32y {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed dword indices, scatter qword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 A1 /vsib",
    "name": "VPSCATTERQD",
    "operands": [
      {
        "type": "vm64x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, scatter dword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 A1 /vsib",
    "name": "VPSCATTERQD",
    "operands": [
      {
        "type": "vm64y {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, scatter dword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 A1 /vsib",
    "name": "VPSCATTERQD",
    "operands": [
      {
        "type": "vm64z {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed qword indices, scatter dword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 A1 /vsib",
    "name": "VPSCATTERQQ",
    "operands": [
      {
        "type": "vm64x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, scatter qword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 A1 /vsib",
    "name": "VPSCATTERQQ",
    "operands": [
      {
        "type": "vm64y {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, scatter qword values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 A1 /vsib",
    "name": "VPSCATTERQQ",
    "operands": [
      {
        "type": "vm64z {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed qword indices, scatter qword values to memory using writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 47 /r",
    "name": "VPSLLVD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 47 /r",
    "name": "VPSLLVQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 47 /r",
    "name": "VPSLLVD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 47 /r",
    "name": "VPSLLVQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 12 /r",
    "name": "VPSLLVW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift words in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 12 /r",
    "name": "VPSLLVW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift words in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 12 /r",
    "name": "VPSLLVW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift words in zmm2 left by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 47 /r",
    "name": "VPSLLVD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 47 /r",
    "name": "VPSLLVD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 47 /r",
    "name": "VPSLLVD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift doublewords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 47 /r",
    "name": "VPSLLVQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 47 /r",
    "name": "VPSLLVQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 47 /r",
    "name": "VPSLLVQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift quadwords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 46 /r",
    "name": "VPSRAVD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 46 /r",
    "name": "VPSRAVD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 11 /r",
    "name": "VPSRAVW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 11 /r",
    "name": "VPSRAVW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 11 /r",
    "name": "VPSRAVW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 46 /r",
    "name": "VPSRAVD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 46 /r",
    "name": "VPSRAVD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 46 /r",
    "name": "VPSRAVD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 46 /r",
    "name": "VPSRAVQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 46 /r",
    "name": "VPSRAVQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 46 /r",
    "name": "VPSRAVQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in sign bits using writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 45 /r",
    "name": "VPSRLVD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.128.66.0F38.W1 45 /r",
    "name": "VPSRLVQ",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 45 /r",
    "name": "VPSRLVD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
  },
  {
    "opcode": "VEX.256.66.0F38.W1 45 /r",
    "name": "VPSRLVQ",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX2",
    "desc": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 10 /r",
    "name": "VPSRLVW",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 10 /r",
    "name": "VPSRLVW",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 10 /r",
    "name": "VPSRLVW",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 45 /r",
    "name": "VPSRLVD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 45 /r",
    "name": "VPSRLVD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 45 /r",
    "name": "VPSRLVD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 45 /r",
    "name": "VPSRLVQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 45 /r",
    "name": "VPSRLVQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 45 /r",
    "name": "VPSRLVQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 25 /r ib",
    "name": "VPTERNLOGD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise ternary logic taking xmm1, xmm2 and xmm3/m128/m32bcst as source operands and writing the result to xmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 25 /r ib",
    "name": "VPTERNLOGD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise ternary logic taking ymm1, ymm2 and ymm3/m256/m32bcst as source operands and writing the result to ymm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 25 /r ib",
    "name": "VPTERNLOGD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise ternary logic taking zmm1, zmm2 and zmm3/m512/m32bcst as source operands and writing the result to zmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 25 /r ib",
    "name": "VPTERNLOGQ",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise ternary logic taking xmm1, xmm2 and xmm3/m128/m64bcst as source operands and writing the result to xmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 25 /r ib",
    "name": "VPTERNLOGQ",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise ternary logic taking ymm1, ymm2 and ymm3/m256/m64bcst as source operands and writing the result to ymm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 25 /r ib",
    "name": "VPTERNLOGQ",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise ternary logic taking zmm1, zmm2 and zmm3/m512/m64bcst as source operands and writing the result to zmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 26 /r",
    "name": "VPTESTMB",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Bitwise AND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 26 /r",
    "name": "VPTESTMB",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Bitwise AND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 26 /r",
    "name": "VPTESTMB",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise AND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 26 /r",
    "name": "VPTESTMW",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Bitwise AND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 26 /r",
    "name": "VPTESTMW",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Bitwise AND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 26 /r",
    "name": "VPTESTMW",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512BW",
    "desc": "Bitwise AND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 27 /r",
    "name": "VPTESTMD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 27 /r",
    "name": "VPTESTMD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 27 /r",
    "name": "VPTESTMD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 27 /r",
    "name": "VPTESTMQ",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 27 /r",
    "name": "VPTESTMQ",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 27 /r",
    "name": "VPTESTMQ",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 26 /r",
    "name": "VPTESTNMB",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Bitwise NAND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 26 /r",
    "name": "VPTESTNMB",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Bitwise NAND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 26 /r",
    "name": "VPTESTNMB",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F AVX512BW",
    "desc": "Bitwise NAND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W1 26 /r",
    "name": "VPTESTNMW",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Bitwise NAND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W1 26 /r",
    "name": "VPTESTNMW",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512BW",
    "desc": "Bitwise NAND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W1 26 /r",
    "name": "VPTESTNMW",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F AVX512BW",
    "desc": "Bitwise NAND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W0 27 /r",
    "name": "VPTESTNMD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise NAND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W0 27 /r",
    "name": "VPTESTNMD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise NAND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W0 27 /r",
    "name": "VPTESTNMD",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise NAND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.128.F3.0F38.W1 27 /r",
    "name": "VPTESTNMQ",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise NAND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.256.F3.0F38.W1 27 /r",
    "name": "VPTESTNMQ",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Bitwise NAND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.512.F3.0F38.W1 27 /r",
    "name": "VPTESTNMQ",
    "operands": [
      {
        "type": "k2 {k1}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Bitwise NAND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 50 /r ib",
    "name": "VRANGEPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Calculate two RANGE operation output value from 2 pairs of double-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 50 /r ib",
    "name": "VRANGEPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Calculate four RANGE operation output value from 4pairs of double-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 50 /r ib",
    "name": "VRANGEPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Calculate eight RANGE operation output value from 8 pairs of double-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 50 /r ib",
    "name": "VRANGEPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Calculate four RANGE operation output value from 4 pairs of single-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 50 /r ib",
    "name": "VRANGEPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Calculate eight RANGE operation output value from 8 pairs of single-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 50 /r ib",
    "name": "VRANGEPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Calculate 16 RANGE operation output value from 16 pairs of single-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W1 51 /r",
    "name": "VRANGESD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Calculate a RANGE operation output value from 2 double-precision floating-point values in xmm2 and xmm3/m64, store the output to xmm1 under writemask. Imm8 specifies the comparison and sign of the range operation."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W0 51 /r",
    "name": "VRANGESS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Calculate a RANGE operation output value from 2 single-precision floating-point values in xmm2 and xmm3/m32, store the output to xmm1 under writemask. Imm8 specifies the comparison and sign of the range operation."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 4C /r",
    "name": "VRCP14PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes the approximate reciprocals of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 4C /r",
    "name": "VRCP14PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes the approximate reciprocals of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 4C /r",
    "name": "VRCP14PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes the approximate reciprocals of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1. Under writemask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 4C /r",
    "name": "VRCP14PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 4C /r",
    "name": "VRCP14PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes the approximate reciprocals of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 4C /r",
    "name": "VRCP14PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes the approximate reciprocals of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 4D /r",
    "name": "VRCP14SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes the approximate reciprocal of the scalar double-precision floating-point value in xmm3/m64 and stores the result in xmm1 using writemask k1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 4D /r",
    "name": "VRCP14SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the results in xmm1 using writemask k1. Also, upper double-precision floating-point value (bits[127:32]) from xmm2 is copied to xmm1[127:32]."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 56 /r ib",
    "name": "VREDUCEPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Perform reduction transformation on packed double-precision floating point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 56 /r ib",
    "name": "VREDUCEPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Perform reduction transformation on packed double-precision floating point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 56 /r ib",
    "name": "VREDUCEPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Perform reduction transformation on double-precision floating point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 56 /r ib",
    "name": "VREDUCEPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Perform reduction transformation on packed single-precision floating point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 56 /r ib",
    "name": "VREDUCEPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Perform reduction transformation on packed single-precision floating point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 56 /r ib",
    "name": "VREDUCEPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Perform reduction transformation on packed single-precision floating point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W1 57",
    "name": "VREDUCESD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8/r"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512D Q",
    "desc": "Perform a reduction transformation on a scalar double-precision floating point value in xmm3/m64 by subtracting a number of fraction bits specified by the imm8 field. Also, upper double precision floating-point value (bits[127:64]) from xmm2 are copied to xmm1[127:64]. Stores the result in xmm1 register."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W0 57 /r /ib",
    "name": "VREDUCESS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Perform a reduction transformation on a scalar single-precision floating point value in xmm3/m32 by subtracting a number of fraction bits specified by the imm8 field. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]. Stores the result in xmm1 register."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W1 09 /r ib",
    "name": "VRNDSCALEPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rounds packed double-precision floating point values in xmm2/m128/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register. Under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W1 09 /r ib",
    "name": "VRNDSCALEPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rounds packed double-precision floating point values in ymm2/m256/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register. Under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W1 09 /r ib",
    "name": "VRNDSCALEPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rounds packed double-precision floating-point values in zmm2/m512/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F3A.W0 08 /r ib",
    "name": "VRNDSCALEPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rounds packed single-precision floating point values in xmm2/m128/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register. Under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F3A.W0 08 /r ib",
    "name": "VRNDSCALEPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Rounds packed single-precision floating point values in ymm2/m256/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register. Under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F3A.W0 08 /r ib",
    "name": "VRNDSCALEPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rounds packed single-precision floating-point values in zmm2/m512/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register using writemask."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W1 0B /r ib",
    "name": "VRNDSCALESD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8",
        "encoding": "Imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rounds scalar double-precision floating-point value in xmm3/m64 to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register."
  },
  {
    "opcode": "EVEX.LIG.66.0F3A.W0 0A /r ib",
    "name": "VRNDSCALESS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{sae}",
        "encoding": "ModRM:r/m (r)"
      },
      {
        "type": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Rounds scalar single-precision floating-point value in xmm3/m32 to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 4E /r",
    "name": "VRSQRT14PD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 4E /r",
    "name": "VRSQRT14PD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 4E /r",
    "name": "VRSQRT14PD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1 under writemask."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 4E /r",
    "name": "VRSQRT14PS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 4E /r",
    "name": "VRSQRT14PS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 4E /r",
    "name": "VRSQRT14PS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 4F /r",
    "name": "VRSQRT14SD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes the approximate reciprocal square root of the scalar double-precision floating-point value in xmm3/m64 and stores the result in the low quadword element of xmm1 using writemask k1. Bits[127:64] of xmm2 is copied to xmm1[127:64]."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 4F /r",
    "name": "VRSQRT14SS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Computes the approximate reciprocal square root of the scalar single-precision floating-point value in xmm3/m32 and stores the result in the low doubleword element of xmm1 using writemask k1. Bits[127:32] of xmm2 is copied to xmm1[127:32]."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 2C /r",
    "name": "VSCALEFPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Scale the packed double-precision floating-point values in xmm2 using values from xmm3/m128/m64bcst. Under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 2C /r",
    "name": "VSCALEFPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Scale the packed double-precision floating-point values in ymm2 using values from ymm3/m256/m64bcst. Under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 2C /r",
    "name": "VSCALEFPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Scale the packed double-precision floating-point values in zmm2 using values from zmm3/m512/m64bcst. Under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 2C /r",
    "name": "VSCALEFPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Scale the packed single-precision floating-point values in xmm2 using values from xmm3/m128/m32bcst. Under writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 2C /r",
    "name": "VSCALEFPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Scale the packed single-precision values in ymm2 using floating point values from ymm3/m256/m32bcst. Under writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 2C /r",
    "name": "VSCALEFPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m32bcst{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Scale the packed single-precision floating-point values in zmm2 using floating-point values from zmm3/m512/m32bcst. Under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W1 2D /r",
    "name": "VSCALEFSD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m64{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Scale the scalar double-precision floating-point values in xmm2 using the value from xmm3/m64. Under writemask k1."
  },
  {
    "opcode": "EVEX.LIG.66.0F38.W0 2D /r",
    "name": "VSCALEFSS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m32{er}",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Scale the scalar single-precision floating-point value in xmm2 using floating-point value from xmm3/m32. Under writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 A2 /vsib",
    "name": "VSCATTERDPS",
    "operands": [
      {
        "type": "vm32x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 A2 /vsib",
    "name": "VSCATTERDPS",
    "operands": [
      {
        "type": "vm32y {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 A2 /vsib",
    "name": "VSCATTERDPS",
    "operands": [
      {
        "type": "vm32z {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 A2 /vsib",
    "name": "VSCATTERDPD",
    "operands": [
      {
        "type": "vm32x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 A2 /vsib",
    "name": "VSCATTERDPD",
    "operands": [
      {
        "type": "vm32x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 A2 /vsib",
    "name": "VSCATTERDPD",
    "operands": [
      {
        "type": "vm32y {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W0 A3 /vsib",
    "name": "VSCATTERQPS",
    "operands": [
      {
        "type": "vm64x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W0 A3 /vsib",
    "name": "VSCATTERQPS",
    "operands": [
      {
        "type": "vm64y {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W0 A3 /vsib",
    "name": "VSCATTERQPS",
    "operands": [
      {
        "type": "vm64z {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.128.66.0F38.W1 A3 /vsib",
    "name": "VSCATTERQPD",
    "operands": [
      {
        "type": "vm64x {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F38.W1 A3 /vsib",
    "name": "VSCATTERQPD",
    "operands": [
      {
        "type": "vm64y {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512F",
    "desc": "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F38.W1 A3 /vsib",
    "name": "VSCATTERQPD",
    "operands": [
      {
        "type": "vm64z {k1}",
        "encoding": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index"
      },
      {
        "type": "zmm1",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512F",
    "desc": "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 0E /r",
    "name": "VTESTPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 0E /r",
    "name": "VTESTPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources."
  },
  {
    "opcode": "VEX.128.66.0F38.W0 0F /r",
    "name": "VTESTPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources."
  },
  {
    "opcode": "VEX.256.66.0F38.W0 0F /r",
    "name": "VTESTPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (r)"
      },
      {
        "type": "ymm2/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources."
  },
  {
    "opcode": "VEX.256.0F.WIG 77",
    "name": "VZEROALL",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Zero all YMM registers."
  },
  {
    "opcode": "VEX.128.0F.WIG 77",
    "name": "VZEROUPPER",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Zero upper 128 bits of all YMM registers."
  },
  {
    "opcode": "9B",
    "name": "WAIT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Check pending unmasked floating-point exceptions."
  },
  {
    "opcode": "9B",
    "name": "FWAIT",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Check pending unmasked floating-point exceptions."
  },
  {
    "opcode": "0F 09",
    "name": "WBINVD",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Write back and flush Internal caches; initiate writing-back and flushing of external caches."
  },
  {
    "opcode": "F3 0F AE /2",
    "name": "WRFSBASE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "FSGSBASE",
    "desc": "Load the FS base address with the 32-bit value in the source register."
  },
  {
    "opcode": "F3 REX.W 0F AE /2",
    "name": "WRFSBASE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "FSGSBASE",
    "desc": "Load the FS base address with the 64-bit value in the source register."
  },
  {
    "opcode": "F3 0F AE /3",
    "name": "WRGSBASE",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "FSGSBASE",
    "desc": "Load the GS base address with the 32-bit value in the source register."
  },
  {
    "opcode": "F3 REX.W 0F AE /3",
    "name": "WRGSBASE",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "i",
    "flag": "FSGSBASE",
    "desc": "Load the GS base address with the 64-bit value in the source register."
  },
  {
    "opcode": "0F 30",
    "name": "WRMSR",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Write the value in EDX:EAX to MSR specified by ECX."
  },
  {
    "opcode": "NP 0F 01 EF",
    "name": "WRPKRU",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "OSPKE",
    "desc": "Writes EAX into PKRU."
  },
  {
    "opcode": "C6 F8 ib",
    "name": "XABORT",
    "operands": [
      {
        "type": "imm8",
        "encoding": "imm8"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "RTM",
    "desc": "Causes an RTM abort if in RTM execution"
  },
  {
    "opcode": "F2",
    "name": "XACQUIRE",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "HLE1",
    "desc": "A hint used with an XACQUIRE-enabled instruction to start lock elision on the instruction memory operand address."
  },
  {
    "opcode": "F3",
    "name": "XRELEASE",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "HLE",
    "desc": "A hint used with an XRELEASE-enabled instruction to end lock elision on the instruction memory operand address."
  },
  {
    "opcode": "0F C0 /r",
    "name": "XADD",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange r8 and r/m8; load sum into r/m8."
  },
  {
    "opcode": "REX + 0F C0 /r",
    "name": "XADD",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Exchange r8 and r/m8; load sum into r/m8."
  },
  {
    "opcode": "0F C1 /r",
    "name": "XADD",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange r16 and r/m16; load sum into r/m16."
  },
  {
    "opcode": "0F C1 /r",
    "name": "XADD",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange r32 and r/m32; load sum into r/m32."
  },
  {
    "opcode": "REX.W + 0F C1 /r",
    "name": "XADD",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Exchange r64 and r/m64; load sum into r/m64."
  },
  {
    "opcode": "C7 F8",
    "name": "XBEGIN",
    "operands": [
      {
        "type": "rel16",
        "encoding": "Offset"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "RTM",
    "desc": "Specifies the start of an RTM region. Provides a 16-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."
  },
  {
    "opcode": "C7 F8",
    "name": "XBEGIN",
    "operands": [
      {
        "type": "rel32",
        "encoding": "Offset"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "RTM",
    "desc": "Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."
  },
  {
    "opcode": "90+rw",
    "name": "XCHG",
    "operands": [
      {
        "type": "AX",
        "encoding": "opcode + rd (r, w)"
      },
      {
        "type": "r16",
        "encoding": "AX/EAX/RAX (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange r16 with AX."
  },
  {
    "opcode": "90+rw",
    "name": "XCHG",
    "operands": [
      {
        "type": "r16",
        "encoding": "opcode + rd (r, w)"
      },
      {
        "type": "AX",
        "encoding": "AX/EAX/RAX (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange AX with r16."
  },
  {
    "opcode": "90+rd",
    "name": "XCHG",
    "operands": [
      {
        "type": "EAX",
        "encoding": "opcode + rd (r, w)"
      },
      {
        "type": "r32",
        "encoding": "AX/EAX/RAX (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange r32 with EAX."
  },
  {
    "opcode": "REX.W + 90+rd",
    "name": "XCHG",
    "operands": [
      {
        "type": "RAX",
        "encoding": "opcode + rd (r, w)"
      },
      {
        "type": "r64",
        "encoding": "AX/EAX/RAX (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Exchange r64 with RAX."
  },
  {
    "opcode": "90+rd",
    "name": "XCHG",
    "operands": [
      {
        "type": "r32",
        "encoding": "opcode + rd (r, w)"
      },
      {
        "type": "EAX",
        "encoding": "AX/EAX/RAX (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange EAX with r32."
  },
  {
    "opcode": "REX.W + 90+rd",
    "name": "XCHG",
    "operands": [
      {
        "type": "r64",
        "encoding": "opcode + rd (r, w)"
      },
      {
        "type": "RAX",
        "encoding": "AX/EAX/RAX (r, w)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Exchange RAX with r64."
  },
  {
    "opcode": "86 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange r8 (byte register) with byte from r/m8."
  },
  {
    "opcode": "REX + 86 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Exchange r8 (byte register) with byte from r/m8."
  },
  {
    "opcode": "86 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange byte from r/m8 with r8 (byte register)."
  },
  {
    "opcode": "REX + 86 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Exchange byte from r/m8 with r8 (byte register)."
  },
  {
    "opcode": "87 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange r16 with word from r/m16."
  },
  {
    "opcode": "87 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange word from r/m16 with r16."
  },
  {
    "opcode": "87 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange r32 with doubleword from r/m32."
  },
  {
    "opcode": "REX.W + 87 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Exchange r64 with quadword from r/m64."
  },
  {
    "opcode": "87 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Exchange doubleword from r/m32 with r32."
  },
  {
    "opcode": "REX.W + 87 /r",
    "name": "XCHG",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Exchange quadword from r/m64 with r64."
  },
  {
    "opcode": "NP 0F 01 D5",
    "name": "XEND",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "RTM",
    "desc": "Specifies the end of an RTM code region."
  },
  {
    "opcode": "NP 0F 01 D0",
    "name": "XGETBV",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Reads an XCR specified by ECX into EDX:EAX."
  },
  {
    "opcode": "D7",
    "name": "XLAT",
    "operands": [
      {
        "type": "m8"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set AL to memory byte DS:[(E)BX + unsigned AL]."
  },
  {
    "opcode": "D7",
    "name": "XLATB",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Set AL to memory byte DS:[(E)BX + unsigned AL]."
  },
  {
    "opcode": "REX.W + D7",
    "name": "XLATB",
    "operands": [],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "Set AL to memory byte [RBX + unsigned AL]."
  },
  {
    "opcode": "34 ib",
    "name": "XOR",
    "operands": [
      {
        "type": "AL",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AL XOR imm8."
  },
  {
    "opcode": "35 iw",
    "name": "XOR",
    "operands": [
      {
        "type": "AX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "AX XOR imm16."
  },
  {
    "opcode": "35 id",
    "name": "XOR",
    "operands": [
      {
        "type": "EAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "EAX XOR imm32."
  },
  {
    "opcode": "REX.W + 35 id",
    "name": "XOR",
    "operands": [
      {
        "type": "RAX",
        "encoding": "AL/AX/EAX/RAX"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "RAX XOR imm32 (sign-extended)."
  },
  {
    "opcode": "80 /6 ib",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m8 XOR imm8."
  },
  {
    "opcode": "REX + 80 /6 ib",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m8 XOR imm8."
  },
  {
    "opcode": "81 /6 iw",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm16",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 XOR imm16."
  },
  {
    "opcode": "81 /6 id",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 XOR imm32."
  },
  {
    "opcode": "REX.W + 81 /6 id",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm32",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 XOR imm32 (sign-extended)."
  },
  {
    "opcode": "83 /6 ib",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 XOR imm8 (sign-extended)."
  },
  {
    "opcode": "83 /6 ib",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 XOR imm8 (sign-extended)."
  },
  {
    "opcode": "REX.W + 83 /6 ib",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "imm8",
        "encoding": "imm8/16/32"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 XOR imm8 (sign-extended)."
  },
  {
    "opcode": "30 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m8 XOR r8."
  },
  {
    "opcode": "REX + 30 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m8 XOR r8."
  },
  {
    "opcode": "31 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r16",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m16 XOR r16."
  },
  {
    "opcode": "31 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r32",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r/m32 XOR r32."
  },
  {
    "opcode": "REX.W + 31 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r, w)"
      },
      {
        "type": "r64",
        "encoding": "ModRM:reg (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r/m64 XOR r64."
  },
  {
    "opcode": "32 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r8",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r8 XOR r/m8."
  },
  {
    "opcode": "REX + 32 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r8*",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m8*",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r8 XOR r/m8."
  },
  {
    "opcode": "33 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r16",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m16",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r16 XOR r/m16."
  },
  {
    "opcode": "33 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r32",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m32",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "r32 XOR r/m32."
  },
  {
    "opcode": "REX.W + 33 /r",
    "name": "XOR",
    "operands": [
      {
        "type": "r64",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "r/m64",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "valid",
    "compatibility": "n.e.",
    "desc": "r64 XOR r/m64."
  },
  {
    "opcode": "66 0F 57/r",
    "name": "XORPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE2",
    "desc": "Return the bitwise logical XOR of packed double-precision floating-point values in xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.66.0F.WIG 57 /r V",
    "name": "XORPD",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.66.0F.WIG 57 /r V",
    "name": "XORPD",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.66.0F.W1 57 /r V",
    "name": "XORPD",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "xmm3/m128/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.66.0F.W1 57 /r V",
    "name": "XORPD",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "ymm3/m256/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.66.0F.W1 57 /r V",
    "name": "XORPD",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv (r)"
      },
      {
        "type": "zmm3/m512/m64bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Return the bitwise logical XOR of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
  },
  {
    "opcode": "NP 0F 57 /r",
    "name": "XORPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (r, w)"
      },
      {
        "type": "xmm2/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "SSE",
    "desc": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm1 and xmm2/mem."
  },
  {
    "opcode": "VEX.128.0F.WIG 57 /r V",
    "name": "XORPS",
    "operands": [
      {
        "type": "xmm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "xmm3/m128",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem."
  },
  {
    "opcode": "VEX.256.0F.WIG 57 /r V",
    "name": "XORPS",
    "operands": [
      {
        "type": "ymm1",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "VEX.vvvv"
      },
      {
        "type": "ymm3/m256",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX",
    "desc": "Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem."
  },
  {
    "opcode": "EVEX.128.0F.W0 57 /r V",
    "name": "XORPS",
    "operands": [
      {
        "type": "xmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "xmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "xmm3/m128/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.256.0F.W0 57 /r V",
    "name": "XORPS",
    "operands": [
      {
        "type": "ymm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "ymm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "ymm3/m256/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512VL AVX512DQ",
    "desc": "Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
  },
  {
    "opcode": "EVEX.512.0F.W0 57 /r V",
    "name": "XORPS",
    "operands": [
      {
        "type": "zmm1 {k1}{z}",
        "encoding": "ModRM:reg (w)"
      },
      {
        "type": "zmm2",
        "encoding": "EVEX.vvvv"
      },
      {
        "type": "zmm3/m512/m32bcst",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "AVX512DQ",
    "desc": "Return the bitwise logical XOR of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
  },
  {
    "opcode": "NP 0F AE /5",
    "name": "XRSTOR",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "XSAVE",
    "desc": "Restore state components specified by EDX:EAX from mem."
  },
  {
    "opcode": "NP REX.W + 0F AE /5",
    "name": "XRSTOR64",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "XSAVE",
    "desc": "Restore state components specified by EDX:EAX from mem."
  },
  {
    "opcode": "NP 0F C7 /3",
    "name": "XRSTORS",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "XSS",
    "desc": "Restore state components specified by EDX:EAX from mem."
  },
  {
    "opcode": "NP REX.W + 0F C7 /3",
    "name": "XRSTORS64",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (r)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "XSS",
    "desc": "Restore state components specified by EDX:EAX from mem."
  },
  {
    "opcode": "NP 0F AE /4",
    "name": "XSAVE",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "XSAVE",
    "desc": "Save state components specified by EDX:EAX to mem."
  },
  {
    "opcode": "NP REX.W + 0F AE /4",
    "name": "XSAVE64",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "XSAVE",
    "desc": "Save state components specified by EDX:EAX to mem."
  },
  {
    "opcode": "NP 0F C7 /4",
    "name": "XSAVEC",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "XSAVEC",
    "desc": "Save state components specified by EDX:EAX to mem with compaction."
  },
  {
    "opcode": "NP REX.W + 0F C7 /4",
    "name": "XSAVEC64",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "XSAVEC",
    "desc": "Save state components specified by EDX:EAX to mem with compaction."
  },
  {
    "opcode": "NP 0F AE /6",
    "name": "XSAVEOPT",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "XSAVEOPT",
    "desc": "Save state components specified by EDX:EAX to mem, optimizing if possible."
  },
  {
    "opcode": "NP REX.W + 0F AE /6",
    "name": "XSAVEOPT64",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "XSAVEOPT",
    "desc": "Save state components specified by EDX:EAX to mem, optimizing if possible."
  },
  {
    "opcode": "NP 0F C7 /5",
    "name": "XSAVES",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "v",
    "flag": "XSS",
    "desc": "Save state components specified by EDX:EAX to mem with compaction, optimizing if possible."
  },
  {
    "opcode": "NP REX.W + 0F C7 /5",
    "name": "XSAVES64",
    "operands": [
      {
        "type": "mem",
        "encoding": "ModRM:r/m (w)"
      }
    ],
    "support64": "v",
    "support32": "n.e.",
    "flag": "XSS",
    "desc": "Save state components specified by EDX:EAX to mem with compaction, optimizing if possible."
  },
  {
    "opcode": "NP 0F 01 D1",
    "name": "XSETBV",
    "operands": [],
    "support64": "valid",
    "compatibility": "valid",
    "desc": "Write the value in EDX:EAX to the XCR specified by ECX."
  },
  {
    "opcode": "NP 0F 01 D6",
    "name": "XTEST",
    "operands": [],
    "support64": "v",
    "support32": "v",
    "flag": "HLE or RTM",
    "desc": "Test if executing in a transactional region"
  }
]
