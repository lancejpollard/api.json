{
  "path": "android.graphics",
  "name": "Path",
  "values": [
    {
      "type": "ctor",
      "ctor": "<init>()\n            Create an empty path"
    },
    {
      "type": "ctor",
      "ctor": "<init>(src: Path?)\n            Create a new path, copying the contents from the src path."
    },
    {
      "type": "method",
      "status": "public"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addArc(oval: RectF, startAngle: Float, sweepAngle: Float)",
      "desc": "Add the specified arc to the path as a new contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addArc(left: Float, top: Float, right: Float, bottom: Float, startAngle: Float, sweepAngle: Float)",
      "desc": "Add the specified arc to the path as a new contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addCircle(x: Float, y: Float, radius: Float, dir: Path.Direction)",
      "desc": "Add a closed circle contour to the path"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addOval(oval: RectF, dir: Path.Direction)",
      "desc": "Add a closed oval contour to the path"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addOval(left: Float, top: Float, right: Float, bottom: Float, dir: Path.Direction)",
      "desc": "Add a closed oval contour to the path"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addPath(src: Path, dx: Float, dy: Float)",
      "desc": "Add a copy of src to the path, offset by (dx,dy)"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addPath(src: Path)",
      "desc": "Add a copy of src to the path"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addPath(src: Path, matrix: Matrix)",
      "desc": "Add a copy of src to the path, transformed by matrix"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addRect(rect: RectF, dir: Path.Direction)",
      "desc": "Add a closed rectangle contour to the path"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addRect(left: Float, top: Float, right: Float, bottom: Float, dir: Path.Direction)",
      "desc": "Add a closed rectangle contour to the path"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addRoundRect(rect: RectF, rx: Float, ry: Float, dir: Path.Direction)",
      "desc": "Add a closed round-rectangle contour to the path"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addRoundRect(left: Float, top: Float, right: Float, bottom: Float, rx: Float, ry: Float, dir: Path.Direction)",
      "desc": "Add a closed round-rectangle contour to the path"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addRoundRect(rect: RectF, radii: FloatArray, dir: Path.Direction)",
      "desc": "Add a closed round-rectangle contour to the path."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "addRoundRect(left: Float, top: Float, right: Float, bottom: Float, radii: FloatArray, dir: Path.Direction)",
      "desc": "Add a closed round-rectangle contour to the path."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "FloatArray",
      "code": "approximate(acceptableError: Float)",
      "desc": "Approximate the Path with a series of line segments."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "arcTo(oval: RectF, startAngle: Float, sweepAngle: Float, forceMoveTo: Boolean)",
      "desc": "Append the specified arc to the path as a new contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "arcTo(oval: RectF, startAngle: Float, sweepAngle: Float)",
      "desc": "Append the specified arc to the path as a new contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "arcTo(left: Float, top: Float, right: Float, bottom: Float, startAngle: Float, sweepAngle: Float, forceMoveTo: Boolean)",
      "desc": "Append the specified arc to the path as a new contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "close()",
      "desc": "Close the current contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "computeBounds(bounds: RectF, exact: Boolean)",
      "desc": "Compute the bounds of the control points of the path, and write the answer into bounds."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "cubicTo(x1: Float, y1: Float, x2: Float, y2: Float, x3: Float, y3: Float)",
      "desc": "Add a cubic bezier from the last point, approaching control points (x1,y1) and (x2,y2), and ending at (x3,y3)."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Path.FillType",
      "code": "getFillType()",
      "desc": "Return the path's fill type."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "incReserve(extraPtCount: Int)",
      "desc": "Hint to the path to prepare for adding more points."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isConvex()",
      "desc": "Returns the path's convexity, as defined by the content of the path."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isEmpty()",
      "desc": "Returns true if the path is empty (contains no lines or curves)"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isInverseFillType()",
      "desc": "Returns true if the filltype is one of the INVERSE variants"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isRect(rect: RectF?)",
      "desc": "Returns true if the path specifies a rectangle."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "lineTo(x: Float, y: Float)",
      "desc": "Add a line from the last point to the specified point (x,y)."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "moveTo(x: Float, y: Float)",
      "desc": "Set the beginning of the next contour to the point (x,y)."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "offset(dx: Float, dy: Float, dst: Path?)",
      "desc": "Offset the path by (dx,dy)"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "offset(dx: Float, dy: Float)",
      "desc": "Offset the path by (dx,dy)"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "op(path: Path, op: Path.Op)",
      "desc": "Set this path to the result of applying the Op to this path and the specified path."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "op(path1: Path, path2: Path, op: Path.Op)",
      "desc": "Set this path to the result of applying the Op to the two specified paths."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "quadTo(x1: Float, y1: Float, x2: Float, y2: Float)",
      "desc": "Add a quadratic bezier from the last point, approaching control point (x1,y1), and ending at (x2,y2)."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "rCubicTo(x1: Float, y1: Float, x2: Float, y2: Float, x3: Float, y3: Float)",
      "desc": "Same as cubicTo, but the coordinates are considered relative to the current point on this contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "rLineTo(dx: Float, dy: Float)",
      "desc": "Same as lineTo, but the coordinates are considered relative to the last point on this contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "rMoveTo(dx: Float, dy: Float)",
      "desc": "Set the beginning of the next contour relative to the last point on the previous contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "rQuadTo(dx1: Float, dy1: Float, dx2: Float, dy2: Float)",
      "desc": "Same as quadTo, but the coordinates are considered relative to the last point on this contour."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "reset()",
      "desc": "Clear any lines and curves from the path, making it empty."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "rewind()",
      "desc": "Rewinds the path: clears any lines and curves from the path but keeps the internal data structure for faster reuse."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "set(src: Path)",
      "desc": "Replace the contents of this with the contents of src."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "setFillType(ft: Path.FillType)",
      "desc": "Set the path's fill type."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "setLastPoint(dx: Float, dy: Float)",
      "desc": "Sets the last point of the path."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "toggleInverseFillType()",
      "desc": "Toggles the INVERSE state of the filltype"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "transform(matrix: Matrix, dst: Path?)",
      "desc": "Transform the points in this path by matrix, and write the answer into dst."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "transform(matrix: Matrix)",
      "desc": "Transform the points in this path by matrix."
    },
    {
      "type": "nested-classes"
    },
    {
      "type": "nested-classes",
      "code": "Direction",
      "desc": "Specifies how closed shapes (e.g. rects, ovals) are oriented when they are added to a path."
    },
    {
      "type": "nested-classes",
      "code": "FillType",
      "desc": "Enum for the ways a path may be filled."
    },
    {
      "type": "nested-classes",
      "code": "Op",
      "desc": "The logical operations that can be performed when combining two paths."
    }
  ]
}