{
  "path": "java.lang.invoke",
  "name": "MethodHandles",
  "values": [
    {
      "type": "method",
      "status": "public"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "arrayElementGetter(arrayClass: Class<*>!)",
      "desc": "Produces a method handle giving read access to elements of an array.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "arrayElementSetter(arrayClass: Class<*>!)",
      "desc": "Produces a method handle giving write access to elements of an array.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "catchException(target: MethodHandle!, exType: Class<out Throwable!>!, handler: MethodHandle!)",
      "desc": "Makes a method handle which adapts a target method handle, by running it inside an exception handler.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "collectArguments(target: MethodHandle!, pos: Int, filter: MethodHandle!)",
      "desc": "Adapts a target method handle by pre-processing a sub-sequence of its arguments with a filter (another method handle).",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "constant(type: Class<*>!, value: Any!)",
      "desc": "Produces a method handle of the requested return type which returns the given constant value every time it is invoked.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "dropArguments(target: MethodHandle!, pos: Int, valueTypes: MutableList<Class<*>!>!)",
      "desc": "Produces a method handle which will discard some dummy arguments before calling some other specified target method handle.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "dropArguments(target: MethodHandle!, pos: Int, vararg valueTypes: Class<*>!)",
      "desc": "Produces a method handle which will discard some dummy arguments before calling some other specified target method handle.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "exactInvoker(type: MethodType!)",
      "desc": "Produces a special invoker method handle which can be used to invoke any method handle of the given type, as if by MethodHandle#invokeExact.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "explicitCastArguments(target: MethodHandle!, newType: MethodType!)",
      "desc": "Produces a method handle which adapts the type of the given method handle to a new type by pairwise argument and return type conversion.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "filterArguments(target: MethodHandle!, pos: Int, vararg filters: MethodHandle!)",
      "desc": "Adapts a target method handle by pre-processing one or more of its arguments, each with its own unary filter function, and then calling the target with each pre-processed argument replaced by the result of its corresponding filter function.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "filterReturnValue(target: MethodHandle!, filter: MethodHandle!)",
      "desc": "Adapts a target method handle by post-processing its return value (if any) with a filter (another method handle).",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "foldArguments(target: MethodHandle!, combiner: MethodHandle!)",
      "desc": "Adapts a target method handle by pre-processing some of its arguments, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "guardWithTest(test: MethodHandle!, target: MethodHandle!, fallback: MethodHandle!)",
      "desc": "Makes a method handle which adapts a target method handle, by guarding it with a test, a boolean-valued method handle.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "identity(type: Class<*>!)",
      "desc": "Produces a method handle which returns its sole argument when invoked.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "insertArguments(target: MethodHandle!, pos: Int, vararg values: Any!)",
      "desc": "Provides a target method handle with one or more bound arguments in advance of the method handle's invocation.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "invoker(type: MethodType!)",
      "desc": "Produces a special invoker method handle which can be used to invoke any method handle compatible with the given type, as if by MethodHandle#invoke.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandles.Lookup",
      "code": "lookup()",
      "desc": "Returns a Lookup with full capabilities to emulate all supported bytecode behaviors of the caller.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "permuteArguments(target: MethodHandle!, newType: MethodType!, vararg reorder: Int)",
      "desc": "Produces a method handle which adapts the calling sequence of the given method handle to a new type, by reordering the arguments.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandles.Lookup",
      "code": "publicLookup()",
      "desc": "Returns a Lookup which is trusted minimally.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "T",
      "code": "reflectAs(expected: Class<T>!, target: MethodHandle!)",
      "desc": "Performs an unchecked \"crack\" of a direct method handle."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "spreadInvoker(type: MethodType!, leadingArgCount: Int)",
      "desc": "Produces a method handle which will invoke any method handle of the given type, with a given number of trailing arguments replaced by a single trailing Object[] array.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "MethodHandle",
      "code": "throwException(returnType: Class<*>!, exType: Class<out Throwable!>!)",
      "desc": "Produces a method handle which will throw exceptions of the given exType.",
      "symbol": "!"
    },
    {
      "type": "nested-classes"
    },
    {
      "type": "nested-classes",
      "code": "Lookup",
      "desc": "A lookup object is a factory for creating method handles, when the creation requires access checking."
    }
  ]
}