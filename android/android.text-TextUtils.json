{
  "path": "android.text",
  "name": "TextUtils",
  "values": [
    {
      "type": "constant"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "CAP_MODE_CHARACTERS",
      "desc": "Capitalization mode for getCapsMode: capitalize all characters."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "CAP_MODE_SENTENCES",
      "desc": "Capitalization mode for getCapsMode: capitalize the first character of each sentence."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "CAP_MODE_WORDS",
      "desc": "Capitalization mode for getCapsMode: capitalize the first character of all words."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "SAFE_STRING_FLAG_FIRST_LINE",
      "desc": "Return only first line of text (truncate at first newline)."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "SAFE_STRING_FLAG_SINGLE_LINE",
      "desc": "Force entire string into single line of text (no newlines)."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "SAFE_STRING_FLAG_TRIM",
      "desc": "Remove Character#isWhitespace(int) and non-breaking spaces from the edges of the label."
    },
    {
      "type": "method",
      "status": "public"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "commaEllipsize(text: CharSequence!, p: TextPaint!, avail: Float, oneMore: String!, more: String!)",
      "desc": "Converts a CharSequence of the comma-separated form \"Andy, Bob, Charles, David\" that is too wide to fit into the specified width into one like \"Andy, Bob, 2 more\".",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "concat(vararg text: CharSequence!)",
      "desc": "Returns a CharSequence concatenating the specified CharSequences, retaining their spans if any.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "copySpansFrom(source: Spanned!, start: Int, end: Int, kind: Class<Any!>!, dest: Spannable!, destoff: Int)",
      "desc": "Copies the spans from the region start...end in source to the region destoff...destoff+end-start in dest."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "dumpSpans(cs: CharSequence!, printer: Printer!, prefix: String!)",
      "desc": "Debugging tool to print the spans in a CharSequence."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "ellipsize(text: CharSequence!, p: TextPaint!, avail: Float, where: TextUtils.TruncateAt!)",
      "desc": "Returns the original text if it fits in the specified width given the properties of the specified Paint, or, if it does not fit, a truncated copy with ellipsis character added at the specified edge or center.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "ellipsize(text: CharSequence!, paint: TextPaint!, avail: Float, where: TextUtils.TruncateAt!, preserveLength: Boolean, callback: TextUtils.EllipsizeCallback?)",
      "desc": "Returns the original text if it fits in the specified width given the properties of the specified Paint, or, if it does not fit, a copy with ellipsis character added at the specified edge or center.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "equals(a: CharSequence!, b: CharSequence!)",
      "desc": "Returns true if a and b are equal, including if they are both null."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "expandTemplate(template: CharSequence!, vararg values: CharSequence!)",
      "desc": "Replace instances of \"^1\", \"^2\", etc.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "getCapsMode(cs: CharSequence!, off: Int, reqModes: Int)",
      "desc": "Determine what caps mode should be in effect at the current offset in the text."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "getChars(s: CharSequence!, start: Int, end: Int, dest: CharArray!, destoff: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "getLayoutDirectionFromLocale(locale: Locale!)",
      "desc": "Return the layout direction for a given Locale"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "getOffsetAfter(text: CharSequence!, offset: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "getOffsetBefore(text: CharSequence!, offset: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "getReverse(source: CharSequence!, start: Int, end: Int)",
      "desc": "This function only reverses individual chars and not their associated spans.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "getTrimmedLength(s: CharSequence!)",
      "desc": "Returns the length that the specified CharSequence would have if spaces and ASCII control characters were trimmed from the start and end, as by String#trim."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "String",
      "code": "htmlEncode(s: String!)",
      "desc": "Html-encode the string.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "indexOf(s: CharSequence!, ch: Char)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "indexOf(s: CharSequence!, ch: Char, start: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "indexOf(s: CharSequence!, ch: Char, start: Int, end: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "indexOf(s: CharSequence!, needle: CharSequence!)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "indexOf(s: CharSequence!, needle: CharSequence!, start: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "indexOf(s: CharSequence!, needle: CharSequence!, start: Int, end: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isDigitsOnly(str: CharSequence!)",
      "desc": "Returns whether the given CharSequence contains only digits."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isEmpty(str: CharSequence?)",
      "desc": "Returns true if the string is null or 0-length."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isGraphic(str: CharSequence!)",
      "desc": "Returns whether the given CharSequence contains any printable characters."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isGraphic(c: Char)",
      "desc": "Returns whether this character is a printable character."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "String",
      "code": "join(delimiter: CharSequence, tokens: Array<Any!>)",
      "desc": "Returns a string containing the tokens joined by delimiters.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "String",
      "code": "join(delimiter: CharSequence, tokens: MutableIterable<Any?>)",
      "desc": "Returns a string containing the tokens joined by delimiters.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "lastIndexOf(s: CharSequence!, ch: Char)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "lastIndexOf(s: CharSequence!, ch: Char, last: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "lastIndexOf(s: CharSequence!, ch: Char, start: Int, last: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "listEllipsize(context: Context?, elements: MutableList<CharSequence!>?, separator: String, paint: TextPaint, avail: Float, moreId: Int)",
      "desc": "Formats a list of CharSequences by repeatedly inserting the separator between them, but stopping when the resulting sequence is too wide for the specified width.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "makeSafeForPresentation(unclean: String, maxCharactersToConsider: Int, ellipsizeDip: Float, flags: Int)",
      "desc": "Remove html, remove bad characters, and truncate string."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "regionMatches(one: CharSequence!, toffset: Int, two: CharSequence!, ooffset: Int, len: Int)",
      "desc": ""
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "replace(template: CharSequence!, sources: Array<String!>!, destinations: Array<CharSequence!>!)",
      "desc": "Return a new CharSequence in which each of the source strings is replaced by the corresponding element of the destinations.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Array",
      "code": "split(text: String!, expression: String!)",
      "desc": "This method yields the same result as text.split(expression, -1) except that if text.isEmpty() then this method returns an empty array whereas \"\".split(expression, -1) would have returned an array with a single \"\".",
      "symbol": "<"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Array",
      "code": "split(text: String!, pattern: Pattern!)",
      "desc": "Splits a string on a pattern.",
      "symbol": "<"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "CharSequence",
      "code": "stringOrSpannedString(source: CharSequence!)",
      "desc": "",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "String",
      "code": "substring(source: CharSequence!, start: Int, end: Int)",
      "desc": "Create a new String object containing the given range of characters from the source string.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "writeToParcel(cs: CharSequence?, p: Parcel, parcelableFlags: Int)",
      "desc": "Flatten a CharSequence and whatever styles can be copied across processes into the parcel."
    },
    {
      "type": "nested-classes"
    },
    {
      "type": "nested-classes",
      "keyword": "abstract",
      "code": "EllipsizeCallback",
      "desc": ""
    },
    {
      "type": "nested-classes",
      "keyword": "open",
      "code": "SimpleStringSplitter",
      "desc": "A simple string splitter."
    },
    {
      "type": "nested-classes",
      "keyword": "abstract",
      "code": "StringSplitter",
      "desc": "An interface for splitting strings according to rules that are opaque to the user of this interface."
    },
    {
      "type": "nested-classes",
      "code": "TruncateAt",
      "desc": ""
    }
  ]
}