{
  "path": "android.media",
  "name": "MediaParser",
  "values": [
    {
      "type": "constant"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_ADTS_ENABLE_CBR_SEEKING",
      "desc": "Sets whether constant bitrate seeking should be enabled for ADTS parsing."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_AMR_ENABLE_CBR_SEEKING",
      "desc": "Sets whether constant bitrate seeking should be enabled for AMR."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_FLAC_DISABLE_ID3",
      "desc": "Sets whether the ID3 track should be disabled for FLAC."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_MATROSKA_DISABLE_CUES_SEEKING",
      "desc": "Sets whether Matroska parsing should avoid seeking to the cues element."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_MP3_DISABLE_ID3",
      "desc": "Sets whether the ID3 track should be disabled for MP3."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_MP3_ENABLE_CBR_SEEKING",
      "desc": "Sets whether constant bitrate seeking should be enabled for MP3."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_MP3_ENABLE_INDEX_SEEKING",
      "desc": "Sets whether MP3 parsing should generate a time-to-byte mapping."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_MP4_IGNORE_EDIT_LISTS",
      "desc": "Sets whether MP4 parsing should ignore edit lists."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_MP4_IGNORE_TFDT_BOX",
      "desc": "Sets whether MP4 parsing should ignore the tfdt box."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_MP4_TREAT_VIDEO_FRAMES_AS_KEYFRAMES",
      "desc": "Sets whether MP4 parsing should treat all video frames as key frames."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_TS_ALLOW_NON_IDR_AVC_KEYFRAMES",
      "desc": "Sets whether TS should treat samples consisting of non-IDR I slices as synchronization samples (key-frames)."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_TS_DETECT_ACCESS_UNITS",
      "desc": "Sets whether TS parsing should split AVC stream into access units based on slice headers."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_TS_ENABLE_HDMV_DTS_AUDIO_STREAMS",
      "desc": "Sets whether TS parsing should handle HDMV DTS audio streams."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_TS_IGNORE_AAC_STREAM",
      "desc": "Sets whether TS parsing should ignore AAC elementary streams."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_TS_IGNORE_AVC_STREAM",
      "desc": "Sets whether TS parsing should ignore AVC elementary streams."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_TS_IGNORE_SPLICE_INFO_STREAM",
      "desc": "Sets whether TS parsing should ignore splice information streams."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARAMETER_TS_MODE",
      "desc": "Sets the operation mode for TS parsing."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_AC3",
      "desc": "Parser for the AC-3 container format, as defined in Digital Audio Compression Standard (AC-3)."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_AC4",
      "desc": "Parser for the AC-4 container format, as defined by Dolby AC-4: Audio delivery for Next-Generation Entertainment Services."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_ADTS",
      "desc": "Parser for the ADTS container format, as defined in ISO/IEC 13818-7."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_AMR",
      "desc": "Parser for the AMR container format, as defined in RFC 4867."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_FLAC",
      "desc": "Parser for the FLAC container format, as defined in the spec."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_FLV",
      "desc": "Parser for the FLV container format, as defined in Adobe Flash Video File Format Specification."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_FMP4",
      "desc": "Parser for fragmented files using the MP4 container format, as defined in ISO/IEC 14496-12."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_MATROSKA",
      "desc": "Parser for the Matroska container format, as defined in the spec."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_MP3",
      "desc": "Parser for the MP3 container format, as defined in ISO/IEC 11172-3."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_MP4",
      "desc": "Parser for non-fragmented files using the MP4 container format, as defined in ISO/IEC 14496-12."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_OGG",
      "desc": "Parser for the OGG container format, as defined in RFC 3533."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_PS",
      "desc": "Parser for the PS container format, as defined in ISO/IEC 11172-1."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_TS",
      "desc": "Parser for the TS container format, as defined in ISO/IEC 13818-1."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_UNKNOWN",
      "desc": "Parser name returned by getParserName() when no parser has been selected yet."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "String",
      "code": "PARSER_NAME_WAV",
      "desc": "Parser for the WAV container format, as defined in Multimedia Programming Interface and Data Specifications."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "SAMPLE_FLAG_DECODE_ONLY",
      "desc": "Indicates that the sample should be decoded but not rendered."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "SAMPLE_FLAG_ENCRYPTED",
      "desc": "Indicates that the sample is (at least partially) encrypted."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "SAMPLE_FLAG_HAS_SUPPLEMENTAL_DATA",
      "desc": "Indicates that the sample has supplemental data."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "SAMPLE_FLAG_KEY_FRAME",
      "desc": "Indicates that the sample holds a synchronization sample."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "SAMPLE_FLAG_LAST_SAMPLE",
      "desc": "Indicates that the sample is known to contain the last media sample of the stream."
    },
    {
      "type": "method",
      "status": "public"
    },
    {
      "type": "method",
      "status": "public",
      "identifier": "Boolean",
      "code": "advance(seekableInputReader: MediaParser.SeekableInputReader)",
      "desc": "Makes progress in the extraction of the input media stream, unless the end of the input has been reached."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "static",
      "identifier": "MediaParser",
      "code": "create(outputConsumer: MediaParser.OutputConsumer, vararg parserNames: String!)",
      "desc": "Creates an instance whose backing parser will be selected by sniffing the content during the first advance call."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "static",
      "identifier": "MediaParser",
      "code": "createByName(name: String, outputConsumer: MediaParser.OutputConsumer)",
      "desc": "Creates an instance backed by the parser with the given name."
    },
    {
      "type": "method",
      "status": "public",
      "identifier": "String",
      "code": "getParserName()",
      "desc": "Returns the name of the backing parser implementation."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "static",
      "identifier": "MutableList",
      "code": "getParserNames(mediaFormat: MediaFormat)",
      "desc": "Returns an immutable list with the names of the parsers that are suitable for container formats with the given MediaFormat.",
      "symbol": "<"
    },
    {
      "type": "method",
      "status": "public",
      "identifier": "Unit",
      "code": "release()",
      "desc": "Releases any acquired resources."
    },
    {
      "type": "method",
      "status": "public",
      "identifier": "Unit",
      "code": "seek(seekPoint: MediaParser.SeekPoint)",
      "desc": "Seeks within the media container being extracted."
    },
    {
      "type": "method",
      "status": "public",
      "identifier": "MediaParser",
      "code": "setParameter(parameterName: String, value: Any)",
      "desc": "Sets parser-specific parameters which allow customizing behavior."
    },
    {
      "type": "method",
      "status": "public",
      "identifier": "Boolean",
      "code": "supportsParameter(parameterName: String)",
      "desc": "Returns whether the given parameterName is supported by this parser."
    },
    {
      "type": "nested-classes"
    },
    {
      "type": "nested-classes",
      "keyword": "abstract",
      "code": "InputReader",
      "desc": "Provides input data to MediaParser."
    },
    {
      "type": "nested-classes",
      "keyword": "abstract",
      "code": "OutputConsumer",
      "desc": "Receives extracted media sample data and metadata from MediaParser."
    },
    {
      "type": "nested-classes",
      "code": "ParsingException",
      "desc": "Thrown when an error occurs while parsing a media stream."
    },
    {
      "type": "nested-classes",
      "code": "SeekMap",
      "desc": "Maps seek positions to SeekPoint in the stream."
    },
    {
      "type": "nested-classes",
      "code": "SeekPoint",
      "desc": "Defines a seek point in a media stream."
    },
    {
      "type": "nested-classes",
      "keyword": "abstract",
      "code": "SeekableInputReader",
      "desc": "InputReader that allows setting the read position."
    },
    {
      "type": "nested-classes",
      "code": "TrackData",
      "desc": "Holds information associated with a track."
    },
    {
      "type": "nested-classes",
      "code": "UnrecognizedInputFormatException",
      "desc": "Thrown if all parser implementations provided to create failed to sniff the input content."
    }
  ]
}