{
  "path": "android.icu.text",
  "name": "BreakIterator",
  "values": [
    {
      "type": "constant"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "DONE",
      "desc": "DONE is returned by previous() and next() after all valid boundaries have been returned."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "KIND_CHARACTER",
      "desc": "[icu]"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "KIND_LINE",
      "desc": "[icu]"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "KIND_SENTENCE",
      "desc": "[icu]"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "KIND_TITLE",
      "desc": "[icu]"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "KIND_WORD",
      "desc": "[icu]"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_IDEO",
      "desc": "Tag value for words containing ideographic characters, lower limit"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_IDEO_LIMIT",
      "desc": "Tag value for words containing ideographic characters, upper limit"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_KANA",
      "desc": "Tag value for words containing kana characters, lower limit"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_KANA_LIMIT",
      "desc": "Tag value for words containing kana characters, upper limit"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_LETTER",
      "desc": "Tag value for words that contain letters, excluding hiragana, katakana or ideographic characters, lower limit."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_LETTER_LIMIT",
      "desc": "Tag value for words containing letters, upper limit"
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_NONE",
      "desc": "Tag value for \"words\" that do not fit into any of other categories."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_NONE_LIMIT",
      "desc": "Upper bound for tags for uncategorized words."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_NUMBER",
      "desc": "Tag value for words that appear to be numbers, lower limit."
    },
    {
      "type": "constant",
      "keyword": "static",
      "identifier": "Int",
      "code": "WORD_NUMBER_LIMIT",
      "desc": "Tag value for words that appear to be numbers, upper limit."
    },
    {
      "type": "method",
      "status": "public"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Any",
      "code": "clone()",
      "desc": "Clone method."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "Int",
      "code": "current()",
      "desc": "Return the iterator's current position."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "Int",
      "code": "first()",
      "desc": "Set the iterator to the first boundary position."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "Int",
      "code": "following(offset: Int)",
      "desc": "Sets the iterator's current iteration position to be the first boundary position following the specified position."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Array",
      "code": "getAvailableLocales()",
      "desc": "Returns a list of locales for which BreakIterators can be used.",
      "symbol": "<"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getCharacterInstance()",
      "desc": "Returns a new instance of BreakIterator that locates logical-character boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getCharacterInstance(where: Locale!)",
      "desc": "Returns a new instance of BreakIterator that locates logical-character boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getCharacterInstance(where: ULocale!)",
      "desc": "[icu] Returns a new instance of BreakIterator that locates logical-character boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getLineInstance()",
      "desc": "Returns a new instance of BreakIterator that locates legal line- wrapping positions.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getLineInstance(where: Locale!)",
      "desc": "Returns a new instance of BreakIterator that locates legal line- wrapping positions.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getLineInstance(where: ULocale!)",
      "desc": "[icu] Returns a new instance of BreakIterator that locates legal line- wrapping positions.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "getRuleStatus()",
      "desc": "For RuleBasedBreakIterators, return the status tag from the break rule that determined the boundary at the current iteration position."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "getRuleStatusVec(fillInArray: IntArray!)",
      "desc": "For RuleBasedBreakIterators, get the status (tag) values from the break rule(s) that determined the the boundary at the current iteration position."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getSentenceInstance()",
      "desc": "Returns a new instance of BreakIterator that locates sentence boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getSentenceInstance(where: Locale!)",
      "desc": "Returns a new instance of BreakIterator that locates sentence boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getSentenceInstance(where: ULocale!)",
      "desc": "[icu] Returns a new instance of BreakIterator that locates sentence boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "CharacterIterator",
      "code": "getText()",
      "desc": "Returns a CharacterIterator over the text being analyzed.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getTitleInstance()",
      "desc": "[icu] Returns a new instance of BreakIterator that locates title boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getTitleInstance(where: Locale!)",
      "desc": "[icu] Returns a new instance of BreakIterator that locates title boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getTitleInstance(where: ULocale!)",
      "desc": "[icu] Returns a new instance of BreakIterator that locates title boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getWordInstance()",
      "desc": "Returns a new instance of BreakIterator that locates word boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getWordInstance(where: Locale!)",
      "desc": "Returns a new instance of BreakIterator that locates word boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "BreakIterator",
      "code": "getWordInstance(where: ULocale!)",
      "desc": "[icu] Returns a new instance of BreakIterator that locates word boundaries.",
      "symbol": "!"
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Boolean",
      "code": "isBoundary(offset: Int)",
      "desc": "Return true if the specified position is a boundary position."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "Int",
      "code": "last()",
      "desc": "Set the iterator to the last boundary position."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "Int",
      "code": "next(n: Int)",
      "desc": "Move the iterator by the specified number of steps in the text."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "Int",
      "code": "next()",
      "desc": "Advances the iterator forward one boundary."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Int",
      "code": "preceding(offset: Int)",
      "desc": "Sets the iterator's current iteration position to be the last boundary position preceding the specified position."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "Int",
      "code": "previous()",
      "desc": "Move the iterator backward one boundary."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "setText(newText: String!)",
      "desc": "Sets the iterator to analyze a new piece of text."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "open",
      "identifier": "Unit",
      "code": "setText(newText: CharSequence!)",
      "desc": "Sets the iterator to analyze a new piece of text."
    },
    {
      "type": "method",
      "status": "public",
      "keyword": "abstract",
      "identifier": "Unit",
      "code": "setText(newText: CharacterIterator!)",
      "desc": "Sets the iterator to analyze a new piece of text."
    }
  ]
}